将 Spring Cache 与 Redis 结合，是构建分布式应用时实现集中式、可共享缓存的常用方案。Spring Boot 通过 `spring-boot-starter-data-redis`提供了开箱即用的集成支持。

### 核心原理

用 `RedisCacheManager`替换默认的缓存管理器，将注解（如 `@Cacheable`）驱动的缓存数据存储到 Redis 服务器中，而非应用本地内存。

### 集成步骤 (Spring Boot)

1. **添加依赖**
    
    在 `pom.xml`中引入必要的 starter。
    
    ```
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-cache</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>
    <!-- 如果使用 Jackson 进行序列化，通常已经包含在 web starter 中 -->
    ```
    
2. **配置 Redis 连接**
    
    在 `application.yml`或 `application.properties`中配置 Redis 服务器地址。
    
    ```
    spring:
      data:
        redis:
          host: localhost # Redis 服务器地址
          port: 6379      # Redis 端口
          password:       # 密码（如果没有则省略）
          database: 0     # 使用的数据库索引
      cache:
        type: redis       # 显式指定缓存类型为 redis（Spring Boot 通常会自动检测）
    ```
    
3. **自定义缓存配置（关键：序列化）**
    
    默认的 JDK 序列化方式可读性差且可能带来兼容性问题。通常需要自定义 `RedisCacheManager`来配置 JSON 序列化。
    
    ```
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.data.redis.cache.RedisCacheConfiguration;
    import org.springframework.data.redis.cache.RedisCacheManager;
    import org.springframework.data.redis.connection.RedisConnectionFactory;
    import org.springframework.data.redis.serializer.*;
    
    @Configuration
    public class RedisCacheConfig {
    
        @Bean
        public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
            // 1. 配置 Key 和 Value 的序列化器
            // Key 通常使用 String 序列化
            RedisSerializationContext.SerializationPair<String> keySerializationPair =
                    RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer());
            // Value 使用 JSON 序列化
            RedisSerializationContext.SerializationPair<Object> valueSerializationPair =
                    RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer());
    
            // 2. 创建默认缓存配置
            RedisCacheConfiguration defaultCacheConfig = RedisCacheConfiguration.defaultCacheConfig()
                    .serializeKeysWith(keySerializationPair)
                    .serializeValuesWith(valueSerializationPair)
                    .entryTtl(java.time.Duration.ofHours(1)) // 设置全局默认过期时间，例如1小时
                    .disableCachingNullValues(); // 不缓存 null 值
    
            // 3. 构建 CacheManager
            return RedisCacheManager.builder(connectionFactory)
                    .cacheDefaults(defaultCacheConfig)
                    .build();
        }
    }
    ```
    
4. **启用缓存**
    
    在启动类上添加 `@EnableCaching`注解。
    

### 使用方式

配置完成后，**业务代码中的注解使用方式与本地缓存完全一致**，但数据将自动存储到 Redis。

```
@Service
public class ProductService {
    @Cacheable(value = “products”， key = “#id”)
    public Product getProductById(String id) {
        // 此方法结果将被缓存到 Redis 的 “products” 区域中，键为 id 参数的值
        return fetchFromDatabase(id);
    }

    @CacheEvict(value = “products”， key = “#id”)
    public void updateProduct(Product product) {
        // 更新数据库后，会删除 Redis 中对应的缓存
        saveToDatabase(product);
    }
}
```

### 结合 Redis 的优势与注意事项

|优势|注意事项 / 潜在问题|
|---|---|
|**分布式共享**：多个服务实例共享同一份缓存，数据一致。|**序列化**：必须妥善配置，推荐 JSON。存储对象需实现 `Serializable`（使用 Jackson 时非强制，但建议）。|
|**持久化**：Redis 支持数据持久化，重启后数据不丢失（取决于配置）。|**网络开销**：相比本地缓存有网络 IO 延迟，适用于需要共享或数据量较大的场景。|
|**丰富数据结构**：可利用 Redis 的 Hash、List 等结构存储复杂数据。|**缓存维护**：`@CacheEvict`、`@CachePut`需正确使用，保证缓存一致性。|
|**高可用**：可通过哨兵、集群模式实现高可用。|**额外配置**：需为不同的 `cacheNames`配置独立的 TTL 或序列化方式时，配置会稍复杂。|
|**集中管理**：方便查看、统计和管理所有缓存数据。|**穿透/雪崩/击穿**：分布式场景下这些问题影响更大，需在业务代码或缓存配置中增加防护（如缓存空值、随机过期时间、分布式锁）。|

### 查看缓存数据

配置完成后，可以通过 Redis 命令行工具（如 `redis-cli`）直接查看缓存的数据，键的格式通常为 `cacheName::key`（例如 `products::123`）。

**总结**：只需更换依赖并配置 `RedisCacheManager`，即可将 Spring Cache 无缝切换到 Redis 后端，获得分布式缓存能力，而业务代码无需任何修改。配置的重点和核心在于**序列化方案**和**过期时间**的管理。