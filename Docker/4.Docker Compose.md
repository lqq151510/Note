# **Docker Compose 完全指南**

Docker Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过一个 YAML 文件配置所有服务，实现一键启动整个应用栈。

## **一、 为什么需要 Docker Compose？**

### **传统 Docker 的问题**

```
# 启动一个完整的应用需要多个命令
docker run -d --name db -v db_data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql
docker run -d --name redis redis:alpine
docker run -d --name app --link db --link redis -p 3000:3000 myapp
docker run -d --name nginx --link app -p 80:80 nginx
```

### **Docker Compose 的优势**

1. **一键启动/停止**：所有服务统一管理
    
2. **配置即代码**：YAML 文件版本化管理
    
3. **服务依赖**：自动处理启动顺序
    
4. **网络管理**：自动创建内部网络
    
5. **环境隔离**：不同环境使用不同配置
    

## **二、 核心概念**

|概念|说明|对应 Docker 命令|
|---|---|---|
|**服务 (Service)**​|一个容器实例|`docker run`|
|**项目 (Project)**​|一组关联的服务|一组容器|
|**网络 (Network)**​|服务间的通信网络|`docker network`|
|**数据卷 (Volume)**​|持久化存储|`docker volume`|

## **三、 安装与版本**

### **安装 Docker Compose**

```
# 方法1：独立安装（旧版）
sudo curl -L "https://github.com/docker/compose/releases/download/v2.23.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose

# 方法2：Docker Desktop 自带（推荐）
# Windows/Mac 安装 Docker Desktop 即包含

# 方法3：使用 Docker Plugin（新版）
# Docker Compose V2 已集成到 Docker CLI 中
docker compose version  # V2 命令
docker-compose version  # V1 命令
```

### **版本兼容性**

```
# docker-compose.yml 文件开头指定版本
version: '3.8'  # 推荐使用 3.x 版本
```

## **四、 docker-compose.yml 语法详解**

### **基本结构**

```
version: '3.8'  # Compose 文件版本
services:       # 定义所有服务
  web:          # 服务名称
    image: nginx:latest  # 使用的镜像
    ports:
      - "80:80"  # 端口映射
  db:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: 123456

volumes:        # 定义数据卷
  db_data:

networks:       # 定义网络
  app_network:
    driver: bridge
```

### **services 配置详解**

#### **1. 镜像相关**

```
services:
  app:
    # 方式1：使用现有镜像
    image: nginx:alpine
    
    # 方式2：从 Dockerfile 构建
    build: 
      context: .  # Dockerfile 所在目录
      dockerfile: Dockerfile.prod  # 指定 Dockerfile
      args:  # 构建参数
        VERSION: 1.0
      cache_from:  # 缓存来源
        - myapp:latest
    
    # 方式3：指定构建上下文和标签
    build: ./dir
    image: myapp:custom
```

#### **2. 容器配置**

```
services:
  app:
    container_name: myapp  # 指定容器名
    restart: unless-stopped  # 重启策略：always, on-failure, unless-stopped, no
    
    # 环境变量
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://user:pass@db:5432/mydb
    # 或使用环境文件
    env_file:
      - .env
      - .env.production
    
    # 工作目录和用户
    working_dir: /app
    user: "1000:1000"  # UID:GID
    
    # 容器标签
    labels:
      com.example.description: "Web application"
      com.example.version: "1.0"
```

#### **3. 网络配置**

```
services:
  web:
    networks:
      - frontend
      - backend
    
    # 自定义网络配置
    networks:
      frontend:
        ipv4_address: 172.16.238.10
        aliases:  # 网络别名
          - webapp
          - app.local

networks:
  frontend:
    driver: bridge
    ipam:  # IP 地址管理
      config:
        - subnet: 172.16.238.0/24
  backend:
    driver: bridge
    external: true  # 使用外部网络
```

#### **4. 存储配置**

```
services:
  db:
    # 数据卷挂载
    volumes:
      # 方式1：具名卷
      - db_data:/var/lib/mysql
      
      # 方式2：绑定挂载
      - ./data:/app/data
      - /宿主机路径:/容器路径
      
      # 方式3：匿名卷
      - /var/lib/mysql
      
      # 方式4：只读挂载
      - ./config:/etc/config:ro
      
      # 方式5：tmpfs 挂载
      - type: tmpfs
        target: /tmp
        tmpfs:
          size: 10000000  # 10MB

volumes:
  db_data:
    driver: local
    driver_opts:
      type: none
      device: /path/to/data
      o: bind
```

#### **5. 端口与健康检查**

```
services:
  web:
    # 端口映射
    ports:
      - "80:80"           # 主机:容器
      - "3000:3000"
      - "127.0.0.1:8080:80"  # 指定主机IP
      - "443:443/tcp"     # 指定协议
      - "53:53/udp"
    
    # 暴露端口（不映射到主机）
    expose:
      - "3000"
    
    # 健康检查
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
```

#### **6. 依赖与扩展**

```
services:
  web:
    depends_on:
      - db
      - redis
      - cache
    
    # 条件依赖
    depends_on:
      db:
        condition: service_healthy  # 等待健康检查通过
      redis:
        condition: service_started  # 等待服务启动
    
    # 扩展配置（用于 docker compose up --scale）
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: '0.50'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 256M
```

#### **7. 日志与资源限制**

```
services:
  app:
    # 日志配置
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    
    # 资源限制
    mem_limit: 512m
    mem_reservation: 256m
    cpus: 0.5
    
    # 设备映射
    devices:
      - "/dev/ttyUSB0:/dev/ttyUSB0"
    
    # 特权模式
    privileged: true
    
    # 内核参数
    sysctls:
      - net.core.somaxconn=1024
      - net.ipv4.tcp_syncookies=0
    
    # 安全选项
    security_opt:
      - seccomp:unconfined
      - apparmor:unconfined
```

## **五、 常用命令**

### **基本命令**

```
# 启动所有服务（后台运行）
docker compose up -d

# 停止所有服务
docker compose down

# 查看服务状态
docker compose ps

# 查看服务日志
docker compose logs
docker compose logs -f  # 实时追踪
docker compose logs web  # 查看指定服务

# 重启服务
docker compose restart
docker compose restart web  # 重启指定服务

# 停止服务（不删除容器）
docker compose stop

# 启动已停止的服务
docker compose start
```

### **构建与镜像**

```
# 构建镜像
docker compose build
docker compose build --no-cache  # 不使用缓存

# 拉取镜像
docker compose pull

# 推送镜像
docker compose push

# 列出镜像
docker compose images
```

### **执行命令**

```
# 在服务容器中执行命令
docker compose exec web bash
docker compose exec db mysql -u root -p

# 在服务容器中执行一次性命令
docker compose run --rm web python manage.py migrate

# 进入容器（交互模式）
docker compose exec -it web sh
```

### **管理与维护**

```
# 查看服务配置
docker compose config
docker compose config --services  # 查看服务列表
docker compose config --volumes   # 查看数据卷

# 暂停/恢复服务
docker compose pause
docker compose unpause

# 删除停止的容器
docker compose rm

# 强制重建服务
docker compose up -d --force-recreate

# 只重建变化的服务
docker compose up -d --build

# 扩展服务实例数
docker compose up -d --scale web=3 --scale worker=2
```

### **环境与变量**

```
# 指定环境文件
docker compose --env-file .env.production up -d

# 查看环境变量
docker compose config --environment
```

## **六、 实战示例**

### **示例1：WordPress + MySQL**

```
version: '3.8'

services:
  db:
    image: mysql:8.0
    volumes:
      - db_data:/var/lib/mysql
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: somewordpress
      MYSQL_DATABASE: wordpress
      MYSQL_USER: wordpress
      MYSQL_PASSWORD: wordpress
    networks:
      - wp_network

  wordpress:
    depends_on:
      - db
    image: wordpress:latest
    volumes:
      - wp_data:/var/www/html
    ports:
      - "8000:80"
    restart: always
    environment:
      WORDPRESS_DB_HOST: db:3306
      WORDPRESS_DB_USER: wordpress
      WORDPRESS_DB_PASSWORD: wordpress
      WORDPRESS_DB_NAME: wordpress
    networks:
      - wp_network

volumes:
  db_data:
  wp_data:

networks:
  wp_network:
    driver: bridge
```

### **示例2：微服务应用**

```
version: '3.8'

services:
  # API 网关
  gateway:
    build: ./gateway
    ports:
      - "8080:8080"
    depends_on:
      - user-service
      - order-service
    environment:
      - USER_SERVICE_URL=http://user-service:3001
      - ORDER_SERVICE_URL=http://order-service:3002
    networks:
      - app-network

  # 用户服务
  user-service:
    build: ./user-service
    environment:
      - DB_HOST=user-db
      - DB_PORT=5432
      - DB_NAME=users
      - DB_USER=postgres
      - DB_PASSWORD=secret
    depends_on:
      user-db:
        condition: service_healthy
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3001/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # 订单服务
  order-service:
    build: ./order-service
    environment:
      - DB_HOST=order-db
      - DB_PORT=5432
    networks:
      - app-network

  # 用户数据库
  user-db:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: users
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: secret
    volumes:
      - user_db_data:/var/lib/postgresql/data
    networks:
      - app-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  # 订单数据库
  order-db:
    image: postgres:15-alpine
    environment:
      POSTGRES_PASSWORD: secret
    volumes:
      - order_db_data:/var/lib/postgresql/data
    networks:
      - app-network

  # Redis 缓存
  redis:
    image: redis:alpine
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    networks:
      - app-network

  # Nginx 负载均衡
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - gateway
    networks:
      - app-network

volumes:
  user_db_data:
  order_db_data:
  redis_data:

networks:
  app-network:
    driver: bridge
```

### **示例3：开发环境配置**

```
version: '3.8'

services:
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile.dev
    volumes:
      - ./frontend:/app
      - /app/node_modules  # 避免覆盖容器内的node_modules
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=development
      - CHOKIDAR_USEPOLLING=true  # 文件监听优化
    command: npm start

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile.dev
    volumes:
      - ./backend:/app
      - /app/node_modules
    ports:
      - "5000:5000"
    environment:
      - NODE_ENV=development
      - DATABASE_URL=postgresql://postgres:secret@db:5432/dev
    depends_on:
      - db
    command: npm run dev

  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: dev
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: secret
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis:
    image: redis:alpine
    ports:
      - "6379:6379"

  pgadmin:
    image: dpage/pgadmin4
    environment:
      PGADMIN_DEFAULT_EMAIL: admin@example.com
      PGADMIN_DEFAULT_PASSWORD: admin
    ports:
      - "5050:80"
    depends_on:
      - db

volumes:
  postgres_data:
```

## **七、 多环境配置**

### **使用多个 Compose 文件**

```
# 基础配置
docker-compose.yml

# 开发环境覆盖配置
docker-compose.override.yml

# 生产环境配置
docker-compose.prod.yml
```

### **docker-compose.yml（基础）**

```
version: '3.8'

services:
  web:
    image: nginx:alpine
    ports:
      - "80:80"
    environment:
      - APP_ENV=production
```

### **docker-compose.override.yml（开发）**

```
version: '3.8'

services:
  web:
    build: .
    volumes:
      - .:/app
    ports:
      - "3000:3000"
    environment:
      - APP_ENV=development
      - DEBUG=true
```

### **docker-compose.prod.yml（生产）**

```
version: '3.8'

services:
  web:
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
```

### **使用方式**

```
# 开发环境（自动加载 override）
docker compose up -d

# 生产环境
docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d

# 测试环境
docker compose -f docker-compose.yml -f docker-compose.test.yml up -d
```

## **八、 最佳实践**

### **1. 配置文件组织**

```
project/
├── docker-compose.yml          # 基础配置
├── docker-compose.override.yml # 开发环境覆盖
├── docker-compose.prod.yml     # 生产环境配置
├── .env                        # 环境变量
├── nginx/
│   ├── Dockerfile
│   └── nginx.conf
├── backend/
│   ├── Dockerfile
│   └── src/
└── frontend/
    ├── Dockerfile
    └── src/
```

### **2. 环境变量管理**

```
# .env 文件
DB_HOST=db
DB_PORT=5432
DB_NAME=mydb
DB_USER=postgres
DB_PASSWORD=${DB_PASSWORD}  # 从系统环境变量读取

# docker-compose.yml 中使用
services:
  app:
    environment:
      - DB_HOST=${DB_HOST}
      - DB_PORT=${DB_PORT}
```

### **3. 网络优化**

```
networks:
  frontend:
    driver: bridge
    ipam:
      config:
        - subnet: 10.10.0.0/16
          gateway: 10.10.0.1
  
  backend:
    internal: true  # 内部网络，不对外暴露
    driver: bridge
```

### **4. 健康检查配置**

```
services:
  web:
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    
  db:
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5
```

### **5. 资源限制**

```
services:
  app:
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M
```

## **九、 常见问题解决**

### **1. 服务启动顺序问题**

```
services:
  app:
    depends_on:
      db:
        condition: service_healthy  # 等待健康检查通过
      redis:
        condition: service_started  # 等待服务启动
```

### **2. 容器间通信**

```
# 使用服务名作为主机名
# app 容器中可以通过 db:5432 访问数据库
services:
  app:
    networks:
      - app-network
  
  db:
    networks:
      - app-network

networks:
  app-network:
    driver: bridge
```

### **3. 文件权限问题**

```
services:
  app:
    user: "1000:1000"  # 指定用户ID和组ID
    volumes:
      - ./data:/app/data
```

### **4. 时区设置**

```
services:
  app:
    environment:
      - TZ=Asia/Shanghai
    volumes:
      - /etc/localtime:/etc/localtime:ro
      - /etc/timezone:/etc/timezone:ro
```

## **十、 进阶技巧**

### **1. 使用扩展字段**

```
version: '3.8'

# 定义扩展字段
x-logging: &default-logging
  driver: "json-file"
  options:
    max-size: "10m"
    max-file: "3"

x-environment: &default-env
  - NODE_ENV=production
  - TZ=Asia/Shanghai

services:
  web:
    logging: *default-logging
    environment: *default-env
  
  api:
    logging: *default-logging
    environment: *default-env
```

### **2. 动态配置**

```
services:
  web:
    image: nginx:alpine
    environment:
      - VIRTUAL_HOST=${DOMAIN:-localhost}
      - LETSENCRYPT_HOST=${DOMAIN:-localhost}
      - LETSENCRYPT_EMAIL=${EMAIL:-admin@example.com}
```

### **3. 使用 Docker Compose V2**

```
# V2 命令（集成到 Docker CLI）
docker compose up -d
docker compose down

# 兼容 V1 命令
docker-compose up -d  # 旧版独立命令
```

### **4. 与 Docker Swarm 集成**

```
version: '3.8'

services:
  web:
    image: nginx:alpine
    deploy:
      mode: replicated
      replicas: 3
      placement:
        constraints:
          - node.role == worker
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
        window: 120s
```

## **总结**

Docker Compose 的核心价值在于**简化多容器应用的管理**。记住以下关键点：

1. **一个文件定义所有服务**：`docker-compose.yml`
    
2. **一键操作**：`docker compose up/down`
    
3. **环境隔离**：通过多个 Compose 文件管理不同环境
    
4. **服务依赖**：自动处理启动顺序和网络连接
    
5. **配置即代码**：所有配置版本化管理
    

通过合理使用 Docker Compose，你可以轻松管理从简单应用到复杂微服务架构的各种场景。