您提供的爬楼梯问题解法非常高效，它掌握了动态规划的空间优化精髓。下面为您整理了一份清晰的解题笔记，涵盖了从核心思路到代码分析的完整内容。

## 1. 问题理解

**题目要求**：计算爬 n 阶楼梯的不同方法数，每次可以爬 1 或 2 个台阶。

**关键观察**：到达第 n 阶楼梯的方法数，等于到达第 n-1 阶（再爬1阶）和到达第 n-2 阶（再爬2阶）的方法数之和。这形成了递推关系：`f(n) = f(n-1) + f(n-2)`。

## 2. 核心思路：动态规划与空间优化

您代码的核心是**动态规划的滚动数组优化**。下面是解题思路的演进过程：

|思路阶段|核心思想|空间复杂度|评价|
|---|---|---|---|
|**基础递归**​|直接实现递推公式，存在大量重复计算|O(n)|直观但效率低|
|**记忆化递归**​|存储已计算结果，避免重复计算|O(n)|效率提升|
|**标准动态规划**​|使用数组存储所有中间结果|O(n)|标准解法|
|**滚动数组(您的解法)**​|仅保存前两个状态，动态更新|**O(1)**​|**最优解**​|

您的解法属于最后一种，也是**最推荐的写法**，它发现每一步的结果只依赖于前两步，因此不需要保存完整的 dp 数组。

## 3. 代码逐行解析

```
class Solution {
    public int climbStairs(int n) {
        // 初始化：a代表到达第1阶的方法数(1种)，b代表到达第2阶的方法数(2种)
        int a = 1;
        int b = 2;
        
        // 边界情况处理：当n=1或2时，直接返回对应值
        if (n == 1 || n == 2) {
            return n;
        } else {
            // 从第3阶开始计算到第n阶
            for (int i = 3; i <= n; i++) {
                // 计算当前阶的方法数：前两阶方法数之和
                int c = a + b;
                // 更新状态：a和b向前滚动一步
                a = b;  // 原来的b变成新的a（前第2阶）
                b = c;  // 当前计算结果变成新的b（前第1阶）
            }
        }
        return b;  // 返回最终结果
    }
}
```

### 执行过程示例（以 n=5 为例）

|迭代|i值|a|b|c=a+b|说明|
|---|---|---|---|---|---|
|初始|-|1|2|-|f(1)=1, f(2)=2|
|1|3|2|3|3|f(3)=f(1)+f(2)=3|
|2|4|3|5|5|f(4)=f(2)+f(3)=5|
|3|5|5|8|8|f(5)=f(3)+f(4)=8|

最终返回 b=8，即爬 5 阶楼梯有 8 种方法。

## 4. 复杂度分析

- **时间复杂度**：O(n)，只需要单次循环从 3 到 n。
    
- **空间复杂度**：O(1)，只使用了三个固定变量，是常数空间。
    

## 5. 关键要点总结

1. **递推关系**是核心：`f(n) = f(n-1) + f(n-2)`。
    
2. **边界条件**很重要：n=1 和 n=2 需要单独处理。
    
3. **空间优化**的技巧：识别状态依赖关系，用有限变量代替数组。
    
4. **变量滚动更新**：通过交替赋值实现状态的向前推进。
    

## 6. 扩展思考

### 问题变形

如果每次可以爬 1、2 或 3 个台阶，递推公式将变为 `f(n) = f(n-1) + f(n-2) + f(n-3)`，但核心的优化思想不变。

### 算法选择建议

- **面试场景**：您的这种 O(1) 空间解法是最佳选择。
    
- **学习路径**：建议理解从递归 → 记忆化 → 动态规划 → 空间优化的完整演进过程。
    

这份解法高效且优雅，体现了对动态规划本质的深刻理解——识别重叠子问题并优化状态存储。