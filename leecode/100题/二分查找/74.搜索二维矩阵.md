

## **代码分析**

### **核心思路**

利用矩阵的**特殊性质**：每行按非递减顺序排列，且**每行的第一个整数大于前一行的最后一个整数**。这意味着：

1. 整个矩阵如果按行展开，会形成一个**完全升序**的一维数组
    
2. 因此可以直接使用**二分查找**
    

### **算法步骤**

```
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        // 1. 获取矩阵维度
        int m = matrix.length;      // 行数
        int n = matrix[0].length;   // 列数
        
        // 2. 定义搜索范围（虚拟的一维数组）
        int left = 0;
        int right = n * m - 1;      // 总元素数 - 1
        
        // 3. 二分查找
        while (left <= right) {
            int mid = left + (right - left) / 2;  // 防止溢出
            
            // 4. 将一维索引 mid 转换为二维坐标 (x, y)
            // x = mid / 列数（因为每行有 n 个元素）
            // y = mid % 列数（余数就是列索引）
            int x = mid / n;
            int y = mid % n;
            
            int t = matrix[x][y];
            
            // 5. 比较并调整搜索区间
            if (t == target) {
                return true;        // 找到目标
            } else if (t < target) {
                left = mid + 1;     // 目标在右侧
            } else {
                right = mid - 1;    // 目标在左侧
            }
        }
        
        // 6. 未找到目标
        return false;
    }
}
```

### **时间复杂度与空间复杂度**

- **时间复杂度**：O(log(m × n))，标准的二分查找复杂度
    
- **空间复杂度**：O(1)，只使用了常数级别的额外空间
    

### **关键技巧**

1. **坐标转换公式**：将一维索引 `mid`转换为二维坐标是关键
    
    ```
    int x = mid / n;  // 行索引
    int y = mid % n;  // 列索引
    ```
    
2. **循环条件**：使用 `while (left <= right)`确保能检查到所有可能的元素
    
3. **防溢出**：使用 `left + (right - left) / 2`而不是 `(left + right) / 2`
    

### **测试用例验证**

```
// 测试用例1：目标存在
int[][] matrix1 = {
    {1, 3, 5, 7},
    {10, 11, 16, 20},
    {23, 30, 34, 60}
};
// searchMatrix(matrix1, 3) -> true
// searchMatrix(matrix1, 11) -> true

// 测试用例2：目标不存在
// searchMatrix(matrix1, 13) -> false
// searchMatrix(matrix1, 0) -> false
// searchMatrix(matrix1, 100) -> false

// 测试用例3：边界情况
int[][] matrix2 = {{1}};
// searchMatrix(matrix2, 1) -> true
// searchMatrix(matrix2, 2) -> false
```

### **代码优化建议**

您的代码已经很简洁高效，但可以添加**边界检查**使其更健壮：

```
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        // 边界情况检查
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }
        
        int m = matrix.length;
        int n = matrix[0].length;
        
        // 快速判断：如果target小于矩阵最小值或大于最大值，直接返回false
        if (target < matrix[0][0] || target > matrix[m-1][n-1]) {
            return false;
        }
        
        // 原有的二分查找逻辑...
    }
}
```

### **总结**

您的代码正确实现了 LeetCode 74 题的解法，该解法利用了矩阵的**完全有序特性**，通过**二分查找**将二维搜索问题转化为一维搜索问题。这是一个经典且高效的解法，复杂度为 O(log(m × n))，在大多数编程面试中都会被认可为最佳解法。