## **题目总结**

### **问题描述**

给定一个**非递减排序**的整数数组 `nums`和一个目标值 `target`，要求：

1. 找到 `target`在数组中出现的**起始位置**和**结束位置**
    
2. 如果 `target`不存在于数组中，返回 `[-1, -1]`
    
3. 必须实现 **O(log n)**​ 时间复杂度算法
    

### **关键约束**

- 数组已按**非递减顺序**排列（允许重复元素）
    
- 时间复杂度必须是 **O(log n)**，不能使用线性扫描
    
- 需要返回两个索引值：`[起始位置, 结束位置]`
    

---

## **代码总结**

### **核心算法：两次二分查找**

```
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] result = new int[]{-1, -1};
        if (nums == null || nums.length == 0) {
            return result;
        }
        
        // 1. 查找起始位置（第一个等于target的位置）
        result[0] = findFirstPosition(nums, target);
        
        // 如果起始位置没找到，直接返回[-1, -1]
        if (result[0] == -1) {
            return result;
        }
        
        // 2. 查找结束位置（最后一个等于target的位置）
        result[1] = findLastPosition(nums, target);
        
        return result;
    }
    
    // 查找第一个等于target的位置
    private int findFirstPosition(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] >= target) {
                right = mid - 1;  // 向左收缩边界
            } else {
                left = mid + 1;   // 向右移动边界
            }
        }
        
        // 验证找到的位置是否有效
        if (left < nums.length && nums[left] == target) {
            return left;
        }
        return -1;
    }
    
    // 查找最后一个等于target的位置
    private int findLastPosition(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] <= target) {
                left = mid + 1;   // 向右移动边界
            } else {
                right = mid - 1;  // 向左收缩边界
            }
        }
        
        // 验证找到的位置是否有效
        if (right >= 0 && nums[right] == target) {
            return right;
        }
        return -1;
    }
}
```

### **算法特点**

1. **分治策略**：将问题分解为两个独立的子问题
    
    - 子问题1：找到第一个等于 `target`的位置
        
    - 子问题2：找到最后一个等于 `target`的位置
        
    
2. **二分查找变体**：
    
    - 不是标准的"找到等于target就返回"的二分
        
    - 通过调整等号的处理方式，继续向左/右搜索边界
        
    
3. **边界处理**：
    
    - 检查数组是否为空
        
    - 检查索引是否越界
        
    - 找到起始位置后提前返回优化
        
    

### **关键技巧对比**

|查找类型|判断条件|移动方向|最终检查|
|---|---|---|---|
|**起始位置**​|`nums[mid] >= target`|向左收缩 (`right = mid - 1`)|检查 `left`是否有效|
|**结束位置**​|`nums[mid] <= target`|向右移动 (`left = mid + 1`)|检查 `right`是否有效|

### **时间复杂度分析**

- **两次独立的二分查找**：每次 O(log n)
    
- **总时间复杂度**：O(log n) + O(log n) = **O(log n)**
    
- **空间复杂度**：O(1)，只使用了常数空间
    

---

## **解题思路总结**

### **1. 问题转换**

将"查找目标值范围"问题转换为**两个边界查找**问题：

- **左边界**：第一个等于 `target`的位置
    
- **右边界**：最后一个等于 `target`的位置
    

### **2. 算法设计**

1. **特殊情况处理**：空数组直接返回 `[-1, -1]`
    
2. **查找左边界**：
    
    - 使用二分查找，当 `nums[mid] >= target`时，继续向左搜索
        
    - 这样可以找到第一个等于或大于 `target`的位置
        
    - 最后验证找到的值是否等于 `target`
        
    
3. **提前终止优化**：如果左边界没找到，直接返回 `[-1, -1]`
    
4. **查找右边界**：
    
    - 使用二分查找，当 `nums[mid] <= target`时，继续向右搜索
        
    - 这样可以找到最后一个等于或小于 `target`的位置
        
    - 最后验证找到的值是否等于 `target`
        
    

### **3. 边界情况考虑**

- **数组为空**：直接返回 `[-1, -1]`
    
- **目标值不存在**：左边界查找返回 `-1`，提前返回
    
- **目标值只有一个**：起始位置和结束位置相同
    
- **目标值有多个**：正常返回范围
    
- **目标值在数组两端**：正确处理索引边界
    

### **4. 算法优化**

- **提前返回**：如果左边界没找到，不需要查找右边界
    
- **索引检查**：二分查找结束后，必须验证找到的索引是否有效
    
- **防溢出**：使用 `mid = left + (right - left) / 2`防止整数溢出
    

---

## **应用场景**

这类问题在实际开发中常见于：

1. **日志时间范围查询**：在按时间排序的日志中查找特定时间段的记录
    
2. **数据库索引查询**：在有序数据集中查找某个值的所有记录
    
3. **统计频率计算**：统计某个值在有序数组中出现的次数（结束位置 - 起始位置 + 1）
    
4. **二分查找的扩展应用**：解决"查找第一个/最后一个"类型的问题
    

这是一个典型的**二分查找变体**问题，考查对二分查找原理的深入理解和灵活应用能力。