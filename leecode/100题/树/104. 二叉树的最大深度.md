

### 题目描述

给定一个二叉树的根节点 `root`，返回其最大深度。

二叉树的**最大深度**是指从根节点到最远叶子节点的最长路径上的节点数。

### 示例

**示例 1：**

输入：root = [3,9,20,null,null,15,7]

输出：3

解释：

```
3
   / \
  9  20
    /  \
   15   7
最大深度 = 3
```

**示例 2：**

输入：root = [1,null,2]

输出：2

**示例 3：**

输入：root = []

输出：0

### 解法（递归实现）

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        return root == null ? 0 : Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
```

### 复杂度分析

- **时间复杂度：**​ O(n)，其中 n 是二叉树的节点数。每个节点恰好被访问一次。
    
- **空间复杂度：**​ O(h)，其中 h 是二叉树的高度。空间复杂度主要取决于递归调用的栈深度，最坏情况下树呈链状，空间复杂度为 O(n)。
    

### 其他解法

#### 迭代实现（BFS广度优先搜索）

```
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int depth = 0;
        
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            
            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            
            depth++;
        }
        
        return depth;
    }
}
```

#### 迭代实现（DFS深度优先搜索）

```
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        
        Stack<TreeNode> nodeStack = new Stack<>();
        Stack<Integer> depthStack = new Stack<>();
        nodeStack.push(root);
        depthStack.push(1);
        int maxDepth = 0;
        
        while (!nodeStack.isEmpty()) {
            TreeNode node = nodeStack.pop();
            int currentDepth = depthStack.pop();
            
            maxDepth = Math.max(maxDepth, currentDepth);
            
            if (node.left != null) {
                nodeStack.push(node.left);
                depthStack.push(currentDepth + 1);
            }
            if (node.right != null) {
                nodeStack.push(node.right);
                depthStack.push(currentDepth + 1);
            }
        }
        
        return maxDepth;
    }
}
```

### 关键点

1. **问题定义**：二叉树的最大深度是从根节点到最远叶子节点的最长路径上的节点数
    
2. **递归思路**：二叉树的最大深度 = 1 + 左右子树最大深度的较大值
    
3. **递归公式**：`maxDepth(root) = 1 + max(maxDepth(root.left), maxDepth(root.right))`
    
4. **边界条件**：当根节点为null时，深度为0
    
5. **BFS解法**：层次遍历，每遍历完一层，深度加1
    
6. **DFS解法**：使用栈模拟递归，同时记录每个节点的深度
    

### 解题思路

1. 如果根节点为空，深度为0
    
2. 否则，计算左子树的最大深度
    
3. 计算右子树的最大深度
    
4. 取左右子树深度的较大值，加上当前根节点的深度1，即为整棵树的最大深度