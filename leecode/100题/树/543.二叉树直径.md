
## 问题描述

给定一棵二叉树的根节点，返回该树的直径。二叉树的直径是指树中任意两个节点之间最长路径的长度。这条路径可能经过也可能不经过根节点。两节点之间路径的长度由它们之间边数表示。

**示例：**

输入：

```
      1
     / \
    2   3
   / \
  4   5
```

输出：3

解释：最长路径是 [4,2,1,3] 或 [5,2,1,3]，长度为3条边。

## 代码实现

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    private int maxdepth = 0;
    
    public int diameterOfBinaryTree(TreeNode root) {
        depth(root);
        return maxdepth;
    }
    
    private int depth(TreeNode node) {
        if (node == null) {
            return 0;
        }
        int leftdepth = depth(node.left);
        int rightdepth = depth(node.right);
        
        maxdepth = Math.max(maxdepth, leftdepth + rightdepth);
        
        return Math.max(leftdepth, rightdepth) + 1;
    }
}
```

## 详细解释

### 算法思路

二叉树的直径本质上是树中任意两个节点之间最长路径的长度。这条路径可能出现在三种情况中：

1. 完全位于左子树内
    
2. 完全位于右子树内
    
3. 跨越根节点（经过根节点）
    

算法的核心思想是：对于树中的每个节点，计算以该节点为"转折点"的路径长度（即左子树深度 + 右子树深度），并记录其中的最大值。

### 递归过程详解

`depth(TreeNode node)`方法执行以下操作：

1. **递归终止条件**：如果节点为空，返回深度0
    
2. **计算左子树深度**：递归调用 `depth(node.left)`得到左子树的最大深度
    
3. **计算右子树深度**：递归调用 `depth(node.right)`得到右子树的最大深度
    
4. **更新最大直径**：以当前节点为根的路径长度为 `leftdepth + rightdepth`，将其与全局变量 `maxdepth`比较并更新
    
5. **返回当前子树深度**：返回 `Math.max(leftdepth, rightdepth) + 1`，这是当前节点的子树深度
    

### 示例说明

以示例二叉树为例：

```
1
     / \
    2   3
   / \
  4   5
```

递归计算过程：

1. 节点4：leftdepth=0，rightdepth=0，路径长度=0，返回深度1
    
2. 节点5：leftdepth=0，rightdepth=0，路径长度=0，返回深度1
    
3. 节点2：leftdepth=1（节点4的深度），rightdepth=1（节点5的深度），路径长度=2（4→2→5），返回深度2
    
4. 节点3：leftdepth=0，rightdepth=0，路径长度=0，返回深度1
    
5. 根节点1：leftdepth=2（节点2的深度），rightdepth=1（节点3的深度），路径长度=3（4→2→1→3），返回深度3
    

最终得到最大直径为3。

### 时间复杂度与空间复杂度

- **时间复杂度**：O(n)，其中n是节点数。每个节点只被访问一次。
    
- **空间复杂度**：O(h)，其中h是树的高度。这是递归调用栈的最大深度。
    

### 算法特点

1. **自底向上计算**：采用后序遍历（左右根）的方式，先计算子节点的深度，再处理当前节点
    
2. **避免重复计算**：在计算深度的同时更新直径，每个节点只处理一次
    
3. **全局变量记录结果**：使用成员变量 `maxdepth`记录遍历过程中发现的最大直径
    

### 边界情况处理

1. **空树**：直接返回0
    
2. **单节点树**：直径为0（没有边）
    
3. **倾斜树**（如所有节点都只有左子节点）：直径会在叶子节点到根节点的路径上
    
4. **平衡树**：直径可能经过根节点，也可能完全在某个子树中
    

这个算法简洁高效地解决了二叉树直径问题，是递归思想的典型应用。