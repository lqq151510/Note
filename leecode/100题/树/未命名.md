```
/**
 * 二叉树节点定义
 */
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

/**
 * 二叉树的直径
 * 
 * 题目描述：
 * 给定一棵二叉树的根节点 root，返回该树的直径。
 * 
 * 二叉树的直径是指树中任意两个节点之间最长路径的长度。
 * 这条路径可能经过也可能不经过根节点 root。
 * 两节点之间路径的长度由它们之间边数表示。
 * 
 * 示例：
 * 输入：root = [1,2,3,4,5]
 * 输出：3
 * 解释：最长路径是 [4,2,1,3] 或 [5,2,1,3]，边数为3。
 */
class Solution {
    private int maxDiameter = 0; // 记录最大直径
    
    public int diameterOfBinaryTree(TreeNode root) {
        depth(root); // 启动深度计算
        return maxDiameter;
    }
    
    /**
     * 计算以当前节点为根的子树的最大深度
     * 深度定义：从节点到叶子节点的最长路径边数
     * 
     * 同时，利用左右子树深度更新最大直径
     * 直径 = 左子树深度 + 右子树深度
     */
    private int depth(TreeNode node) {
        if (node == null) {
            return 0; // 空节点深度为0
        }
        
        // 递归计算左右子树深度
        int leftDepth = depth(node.left);
        int rightDepth = depth(node.right);
        
        // 更新最大直径：以当前节点为连接点的路径长度
        maxDiameter = Math.max(maxDiameter, leftDepth + rightDepth);
        
        // 返回当前子树深度：左右子树的最大深度 + 1（当前节点到父节点的边）
        return Math.max(leftDepth, rightDepth) + 1;
    }
}
```

**算法复杂度**：

- **时间复杂度**：O(n)，其中 n 是二叉树节点数，每个节点只访问一次
    
- **空间复杂度**：O(h)，其中 h 是树的高度，递归调用栈的深度
    

**算法原理**：

1. 对每个节点，计算其左右子树的最大深度
    
2. 经过该节点的最长路径长度 = 左子树深度 + 右子树深度
    
3. 在递归过程中，用所有节点的路径长度最大值更新最终答案
    
4. 该方法通过一次后序遍历，在计算深度的同时统计直径，避免重复计算
    

**关键点**：

- 树的直径不一定经过根节点
    
- 深度计算的是边数，不是节点数
    
- 递归函数在返回子树深度的同时，更新了全局最大直径