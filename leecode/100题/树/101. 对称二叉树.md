

**题目描述**​

给定一个二叉树的根节点 `root`，检查它是否轴对称（即镜像对称）。

**示例**​

```
输入：root = [1,2,2,3,4,4,3]
输出：true

输入：root = [1,2,2,null,3,null,3]
输出：false
```

**代码实现**​

```
class Solution {
    public boolean isSymmetric(TreeNode root) {
        // 空树视为对称
        if (root == null) {
            return true;
        }
        // 比较左右子树是否互为镜像
        return isMirror(root.left, root.right);
    }
    
    private boolean isMirror(TreeNode left, TreeNode right) {
        // 两个节点都为空，对称
        if (left == null && right == null) {
            return true;
        }
        // 只有一个为空，不对称
        if (left == null || right == null) {
            return false;
        }
        // 节点值不相等，不对称
        if (left.val != right.val) {
            return false;
        }
        // 递归比较：左左对右右，左右对右左
        return isMirror(left.left, right.right) && isMirror(left.right, right.left);
    }
}
```

**算法解析**​

1. **递归终止条件**​
    
    - 两个节点都为空 → 对称
        
    - 一个为空一个非空 → 不对称
        
    - 两个节点值不相等 → 不对称
        
    
2. **递归逻辑**​
    
    - 左子树的左节点必须与右子树的右节点对称
        
    - 左子树的右节点必须与右子树的左节点对称
        
    
3. **复杂度分析**​
    
    - 时间复杂度：O(n)，每个节点访问一次
        
    - 空间复杂度：O(h)，递归栈深度，h为树的高度
        
    

**关键点**​

- 对称二叉树的定义是左右子树互为镜像
    
- 递归比较时注意对应关系：`left.left`↔ `right.right`，`left.right`↔ `right.left`