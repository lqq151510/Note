以下是整理后的完整代码和题目信息

### 题目描述

给定一个二叉树的根节点 `root`，返回它的 **中序**​ 遍历。

### 示例

**示例 1：**

输入：root = [1,null,2,3]

输出：[1,3,2]

解释：

```
1
   \
    2
   /
  3
```

**示例 2：**

输入：root = []

输出：[]

**示例 3：**

输入：root = [1]

输出：[1]

### 解法（递归实现）

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        add(root, list);
        return list;
    }
    
    public void add(TreeNode node, List<Integer> list) {
        if (node == null) {
            return;
        }
        
        // 中序遍历：左 -> 根 -> 右
        add(node.left, list);
        list.add(node.val);
        add(node.right, list);
    }
}
```

### 复杂度分析

- **时间复杂度：**​ O(n)，其中 n 是二叉树的节点数。每个节点恰好被遍历一次。
    
- **空间复杂度：**​ O(h)，其中 h 是二叉树的高度。空间复杂度主要取决于递归调用的栈深度，最坏情况下树呈链状，空间复杂度为 O(n)。
    

### 其他解法

#### 迭代实现（使用栈）

```
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode curr = root;
        
        while (curr != null || !stack.isEmpty()) {
            // 将左子节点全部入栈
            while (curr != null) {
                stack.push(curr);
                curr = curr.left;
            }
            
            // 弹出栈顶节点并访问
            curr = stack.pop();
            result.add(curr.val);
            
            // 转向右子树
            curr = curr.right;
        }
        
        return result;
    }
}
```

#### Morris 中序遍历（空间复杂度 O(1)）

```
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        TreeNode curr = root;
        
        while (curr != null) {
            if (curr.left == null) {
                result.add(curr.val);
                curr = curr.right;
            } else {
                TreeNode prev = curr.left;
                while (prev.right != null && prev.right != curr) {
                    prev = prev.right;
                }
                
                if (prev.right == null) {
                    prev.right = curr;
                    curr = curr.left;
                } else {
                    prev.right = null;
                    result.add(curr.val);
                    curr = curr.right;
                }
            }
        }
        
        return result;
    }
}
```

### 关键点

1. **中序遍历定义**：按照访问左子树 → 根节点 → 右子树的顺序遍历二叉树
    
2. **递归实现**：代码简洁直观，是解决此类问题的首选方法
    
3. **迭代实现**：使用栈模拟递归过程，避免了递归可能导致的栈溢出问题
    
4. **Morris遍历**：无需额外空间，通过修改树的结构实现遍历，遍历完成后恢复原结构