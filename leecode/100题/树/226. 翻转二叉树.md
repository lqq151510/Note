

**题目描述**

给你一棵二叉树的根节点 `root`，翻转这棵二叉树（将每个节点的左右子节点交换），并返回翻转后的根节点。

**示例**

```
输入:
     4
   /   \
  2     7
 / \   / \
1   3 6   9

输出:
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

**代码实现**

```
class Solution {
    public TreeNode invertTree(TreeNode root) {
        // 递归翻转二叉树
        flip(root);
        return root;
    }
    
    private void flip(TreeNode root) {
        // 递归终止条件：当前节点为空
        if (root == null) {
            return;
        }
        
        // 交换当前节点的左右子树
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        
        // 递归翻转左子树和右子树
        flip(root.left);
        flip(root.right);
    }
}
```

**算法解析**

1. **递归方法**：采用深度优先遍历的方式，从根节点开始递归处理
    
2. **交换操作**：对于每个非空节点，交换其左右子节点的引用
    
3. **时间复杂度**：O(n)，其中 n 为节点数量，需要访问每个节点一次
    
4. **空间复杂度**：O(h)，其中 h 为树的高度，递归调用栈的深度
    

**关键点**

- 递归终止条件是当前节点为 `null`
    
- 先交换当前节点的左右子树，再递归处理交换后的左右子树
    
- 返回的根节点与输入的根节点相同，但树的结构已经翻转