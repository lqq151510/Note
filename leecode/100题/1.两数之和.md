以下是您提供的两数之和（Two Sum）问题的Java解决方案的Markdown文档整理。代码的核心思路正确，但存在一个**关键错误**和若干可优化点，已在下文修正。

# 两数之和（Two Sum）问题解决方案

## 问题描述

给定一个整数数组 `nums`和一个整数目标值 `target`，请在数组中找出和为目标值 `target`的那两个整数，并返回它们的数组下标。可以假设每种输入只会对应一个答案，且不能重复使用同一个元素。

## 代码实现

```
import java.util.HashMap;
import java.util.Map;

class Solution {
    public int[] twoSum(int[] nums, int target) {
        // 使用HashMap存储数值和对应的索引 (Key: 数值, Value: 索引)
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) { // 修正1：循环条件应为 i < nums.length
            int complement = target - nums[i];
            // 检查补数是否已存在于HashMap中
            if (map.containsKey(complement)) {
                // 找到答案，返回两个数的索引
                return new int[]{map.get(complement), i};
            }
            // 将当前数值及其索引存入HashMap
            map.put(nums[i], i);
        }
        // 未找到符合条件的结果
        return new int[0];
    }
}
```

## 算法思路（哈希表法）

此解法利用哈希表实现**一次遍历**，核心步骤如下：

1. **初始化哈希表**：用于存储已经遍历过的数字及其索引（Key: 数值，Value: 索引）。
    
2. **遍历与计算**：对于每个元素 `nums[i]`，计算其所需的补数 `complement = target - nums[i]`。
    
3. **查找与判断**：检查补数是否已经存在于哈希表中。
    
    - 如果存在，说明找到了答案，即 `complement`的索引 `map.get(complement)`和当前索引 `i`。
        
    - 如果不存在，则将当前的数字 `nums[i]`和它的索引 `i`存入哈希表，供后续的数字查找。
        
    
4. **返回结果**：找到答案时直接返回，遍历完毕仍未找到则返回空数组。
    

## 复杂度分析

- **时间复杂度**：O(n)。只需遍历数组一次，哈希表的每次查找操作的时间复杂度为 O(1)。
    
- **空间复杂度**：O(n)。主要为哈希表的开销，最坏情况下需要存储所有元素。
    

## 其他解法对比

|解法|核心思路|时间复杂度|空间复杂度|特点|
|---|---|---|---|---|
|**暴力枚举**​|双层循环检查所有可能的数对组合。|O(n²)|O(1)|思路简单，效率低，适用于小数据集。|
|**两遍哈希表**​|先将所有元素存入哈希表，再遍历查找补数。|O(n)|O(n)|逻辑清晰，但需遍历两次。|

## 总结

- **推荐方案**：哈希表法是解决此问题的最优方案之一，通过空间换时间，将查找效率提升至 O(1)。
    
- **关键点**：理解在遍历时“先查找，后放入”的策略，这避免了元素被重复使用。