您提供的代码是解决“最长连续序列”问题的**优化哈希集合方案**，它通过巧妙避免重复计算来达到O(n)时间复杂度。以下是对其思路和实现的详细解析。

---

### 算法思路

这个问题要求找到最长的连续数字序列，核心挑战在于如何高效判断一个数字是否在数组中。您的代码采用了以下策略：

1. **去重与快速查找**：利用`HashSet`存储所有数字，既去除了重复元素，又提供了O(1)时间复杂度的查找能力。
    
2. **避免重复计算**：只从**每个连续序列的起始点**（即某个数字`x`，且`x-1`不在集合中）开始向后扩展计数。如果`x-1`存在于集合中，说明`x`不是序列起点，可以跳过，从而确保每个连续序列只被完整计算一次。
    

### 代码解析

```
class Solution {
    public int longestConsecutive(int[] nums) {
        // 1. 边界情况处理
        if (nums == null || nums.length == 0) {
            return 0;
        }
        
        // 2. 使用HashSet去重并提供O(1)查找
        Set<Integer> set = new HashSet<>();
        for (int n : nums) {
            set.add(n);
        }
        
        int maxlen = 0;
        
        // 3. 遍历去重后的集合，避免重复元素的无用计算
        for (int s : set) {
            // 4. 关键：只有当s是某个连续序列的起点时才进行处理
            if (!set.contains(s - 1)) {
                int cur = s;
                int curlen = 1;
                
                // 5. 从起点开始，向后连续扩展
                while (set.contains(cur + 1)) {
                    cur++;
                    curlen++;
                }
                
                // 6. 更新找到的最长序列长度
                maxlen = Math.max(maxlen, curlen);
            }
        }
        return maxlen;
    }
}
```

### 复杂度分析

- **时间复杂度**：O(n)。虽然代码有嵌套循环，但每个数字最多被访问两次（一次在外层循环判断是否为起点，一次在内层循环作为序列的一部分被统计），总操作次数与数组大小n成线性关系。
    
- **空间复杂度**：O(n)。主要用于存储哈希集合。
    

### 其他解法对比

|解法|思路|时间复杂度|空间复杂度|评价|
|---|---|---|---|---|
|**哈希集合（您的解法）**​|利用`HashSet`快速查找，仅从序列起点开始扩展|**O(n)**​|O(n)|**最优解**，满足题目要求|
|**排序**​|先排序数组，再遍历统计连续序列长度|O(n log n)|O(1) 或 O(n)|思路直观，但时间复杂度不满足题目要求|

### 总结与注意事项

- **核心技巧**：判断`x-1`是否存在以确定序列起点，是避免重复计算、实现O(n)时间复杂度的关键。
    
- **代码优化点**：您的代码直接遍历`HashSet`而非原数组，避免了重复元素的无用判断，是一个很好的实践。
    
- **提前终止优化（可选）**：在内层循环后，如果当前找到的序列长度已超过集合大小的一半，理论上剩余元素不可能组成更长序列，可以提前终止循环。但这属于锦上添花的优化。
    

> 注：虽然题目要求O(n)时间复杂度，但许多面试官也接受先给出排序解法，再逐步优化到哈希集合解法的思路。理解优化过程本身比单纯记住答案更有价值。