你提供的代码是解决“三数之和”问题的经典且正确的实现。它巧妙地结合了**排序**与**双指针**技巧，高效地找到了所有不重复的三元组。下面我们来系统性地梳理其核心思想、代码细节以及相关优化。

### 🔍 解题思路

解决此问题的关键在于如何**高效地搜索**和**避免重复结果**。暴力枚举所有三元组的时间复杂度为 O(n³)，不可行。排序与双指针结合的策略可以将复杂度优化至 O(n²) 。

1. **排序预处理**：这是整个算法的基石。排序后，相同的元素会聚集在一起，这为后续跳过重复元素（去重）提供了极大便利。同时，数组的有序性使得我们可以利用双指针根据求和结果智能地移动指针 。
    
2. **固定第一个数**：遍历数组，将当前元素 `nums[i]`作为三元组的第一个数。这一步将“三数之和”问题转化为了在 `i`之后的子数组中寻找“两数之和为 `-nums[i]`”的问题 。
    
3. **双指针寻找两数**：对于固定的 `nums[i]`，设置两个指针：
    
    - `left`指针初始指向 `i+1`。
        
    - `right`指针初始指向数组末尾。
        
        计算三数之和 `sum = nums[i] + nums[left] + nums[right]`，然后根据 `sum`与目标值 `0`的关系移动指针：
        
    - `sum == 0`：找到解，记录并移动指针继续搜索。
        
    - `sum < 0`：总和太小，需要增大，因此 `left`右移。
        
    - `sum > 0`：总和太大，需要减小，因此 `right`左移 。
        
    

### ✅ 你的代码分析

你的代码准确实现了上述思路，下面逐部分解读：

```
public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    int n = nums.length;
    // 1. 排序
    Arrays.sort(nums); // 
    
    for (int i = 0; i < n - 2; i++) {
        // 优化：若第一个数已大于0，三数之和不可能为0
        if (nums[i] > 0) break; // 
        
        // 对第一个数去重：避免重复的起始值
        if (i > 0 && nums[i] == nums[i - 1]) { // 
            continue;
        }
        
        int left = i + 1;
        int right = n - 1;
        while (left < right) {
            int sum = nums[i] + nums[left] + nums[right];
            if (sum == 0) {
                // 找到有效三元组
                result.add(Arrays.asList(nums[i], nums[left], nums[right])); // 
                
                // 关键：找到解后，跳过所有重复的left和right值
                while (left < right && nums[left] == nums[left + 1]) left++; // 
                while (left < right && nums[right] == nums[right - 1]) right--; // 
                
                // 移动指针，寻找下一组可能解
                left++;
                right--;
            } else if (sum < 0) {
                left++;
            } else {
                right--;
            }
        }
    }
    return result;
}
```

#### 关键点与优化

- **去重逻辑**：这是本题最易错的地方。你的代码正确地进行了两次去重 ：
    
    1. **对 `i`去重**：使用 `if (i > 0 && nums[i] == nums[i - 1]) continue;`。这里比较的是 `nums[i]`和 `nums[i-1]`，这确保了即使有连续多个相同数字，也只有第一个会被用作起始值，避免了重复三元组。如果错误地比较 `nums[i]`和 `nums[i+1]`，则会漏掉一些有效组合 。
        
    2. **找到解后对 `left`/`right`去重**：在记录三元组后，通过 `while`循环跳过所有与当前 `left`和 `right`指向的值相同的元素，确保下一个搜索的是一组新值。
        
    
- **提前终止**：当 `nums[i] > 0`时，由于数组已排序，后面的数都更大，三数之和不可能为0，直接 `break`循环，这是一个有效的优化 。
    

### ⚠️ 一个值得注意的细节

在你当前的代码中，**去重和移动指针的逻辑是紧密耦合的**。还有一种常见的写法是将指针的移动统一放在条件判断之后：

```
// ... 在sum == 0的条件内
result.add(Arrays.asList(nums[i], nums[left], nums[right]));
// 先去重
while (left < right && nums[left] == nums[left + 1]) left++;
while (left < right && nums[right] == nums[right - 1]) right--;
// 再移动指针（此时left和right指向的是最后一个重复元素，再移动一次就指向新元素了）
left++;
right--;
```

这两种写法在逻辑上是等价的。你的写法是“移动一次指针，然后跳过所有重复项”，而上面这种是“跳过所有重复项，再移动一次指针”。只要理解其意图，都是正确的。

### 📊 复杂度分析

- **时间复杂度**：O(n²)。排序需要 O(n log n) 时间。外层循环遍历 O(n) 次，内层双指针在每个外层循环中最多遍历 O(n) 次，因此双指针部分为 O(n²)。总复杂度为 O(n log n + n²) = O(n²) 。
    
- **空间复杂度**：O(log n) 或 O(n)，主要取决于排序算法的实现。通常认为是 O(log n) 。如果不考虑存储结果的空间，额外的空间复杂度是 O(1)。
    

### 💡 总结与扩展

你提供的代码是解决“三数之和”问题的**标准且高效**的答案。它完美地体现了如何通过**排序**来启用**双指针**技巧，并通过**精细的去重逻辑**来保证结果的正确性。

这套“排序+双指针”的范式非常强大，可以推广到类似问题，例如：

- **最接近的三数之和**：在找到解时更新最接近的值，其他逻辑类似 。
    
- **四数之和**：在外部再套一层循环，将问题转化为内部的三数之和 。
    

希望这个详细的梳理能帮助你更好地理解这个经典算法！如果还有其他疑问，欢迎随时提出。