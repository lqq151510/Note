我已将题目描述和判断环形链表的Java代码整理如下。核心解法是使用**快慢指针**（Floyd判圈算法），在O(n)时间复杂度和O(1)空间复杂度内高效检测环。

```
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        // 初始化快慢指针，均指向头节点
        ListNode slow = head;
        ListNode fast = head;
        
        // 快指针移动更快，需检查fast及fast.next是否为空
        while (fast != null && fast.next != null) {
            slow = slow.next;           // 慢指针移动一步
            fast = fast.next.next;      // 快指针移动两步
            if (slow == fast) {         // 两指针相遇，说明有环
                return true;
            }
        }
        // 快指针抵达链表末端，无环
        return false;
    }
}
```

### 💡 算法核心思路

该算法的原理简洁而巧妙：

- **快指针**每次走两步，**慢指针**每次走一步。
    
- 如果链表**无环**，快指针将首先到达链表末尾（遇到`null`）。
    
- 如果链表**有环**，快慢指针最终都会进入环内。由于快指针速度更快，它会在环中追上慢指针（相遇）。
    

### ⚠️ 边界情况处理

代码已妥善处理以下边界情况：

- 链表为 `null`（`head == null`）。
    
- 链表只有一个节点，且其 `next`为 `null`。
    
- 各种有环和无环的链表结构。
    

### 📊 复杂度分析

- **时间复杂度**：O(n)。最坏情况下需要遍历链表中的每个节点一次。
    
- **空间复杂度**：O(1)。只使用了两个指针变量，是常数级别的额外空间，满足题目进阶要求。
    

希望这个整理对您有帮助！如果您想进一步了解如何寻找环的入口点，我可以为您补充相关算法。