我为您整理了环形链表找入口节点的题目描述和代码实现。您提供的代码是正确的，采用了经典的**快慢指针法**（Floyd判圈算法）。

### **题目描述**

给定一个链表的头节点 `head`，如果链表中有环，则返回环的入口节点；如果链表无环，则返回 `null`。

- **说明**：不允许修改给定的链表。
    

### **算法代码**

```
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        // 第一阶段：使用快慢指针判断是否有环
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            // 如果快慢指针相遇，说明有环
            if (slow == fast) {
                // 第二阶段：寻找环的入口
                slow = head; // 将慢指针重新指向头节点
                // 两个指针以相同速度前进，直到再次相遇
                while (fast != slow) {
                    fast = fast.next;
                    slow = slow.next;
                }
                // 相遇点即为环的入口节点
                return slow;
            }
        }
        // 快指针遇到null，说明链表无环
        return null;
    }
}
```

### **算法思路详解**

该算法的工作原理可以清晰地分为两个阶段，下面的流程图展示了完整的执行过程：

```
flowchart TD
    A([开始]) --> B{链表是否为空?}
    B -- 是 --> C([返回 null])
    B -- 否 --> D[初始化: slow = head, fast = head]
    D --> E{fast 与 fast.next<br>不为空?}
    E -- 否 --> C
    E -- 是 --> F[移动指针: slow走一步, fast走两步]
    F --> G{slow == fast?}
    G -- 否 --> E
    G -- 是 --> H[slow 重新指向 head]
    H --> I{slow != fast?}
    I -- 是 --> J[slow和fast各走一步]
    J --> I
    I -- 否 --> K([返回 slow<br>相遇点即为环入口])
```

#### **第一阶段：检测环是否存在**

- 使用**快慢指针**，`slow`指针每次移动一步，`fast`指针每次移动两步。
    
- 如果链表中**不存在环**，`fast`指针会首先到达链表末尾（遇到 `null`），函数返回 `null`。
    
- 如果链表中**存在环**，两个指针最终都会进入环内，由于存在速度差，它们必定会在环中的某个节点相遇（`slow == fast`）。
    

#### **第二阶段：寻找环的入口**

- 当快慢指针相遇后，将 `slow`指针重新指向链表头节点 `head`，而 `fast`指针保持在相遇点。
    
- 然后，两个指针以**相同的速度**（每次一步）向前移动。
    
- 当它们**再次相遇**时，所在的节点就是环的入口节点。
    

#### **数学原理（为什么这样能找到入口？）**

设：

- `a`：从链表头节点到环入口节点的距离。
    
- `b`：从环入口节点到快慢指针第一次相遇点的距离。
    
- `c`：环的剩余长度（从相遇点回到入口的距离）。环的总长度为 `b + c`。
    

当第一次相遇时：

- 慢指针走过的距离为：`a + b`。
    
- 快指针走过的距离为：`a + b + n*(b + c)`，其中 `n`是快指针在环中绕的圈数（`n >= 1`）。
    
- 因为快指针的速度是慢指针的两倍，所以有：`2(a + b) = a + b + n(b + c)`，化简后得到 `a = n(b + c) - b = c + (n-1)(b+c)`。
    

这个等式意味着：**从链表头到环入口的距离 `a`，等于从相遇点走 `c`步（可能再加上整数圈）就能到达环入口**。因此，当两个指针第二次以相同速度移动时，它们会在环入口处相遇。

希望这个详细的解释对您有帮助！这是链表问题中一个非常经典且重要的算法。