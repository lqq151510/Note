
给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。
你给出的这段代码是解决相交链表问题的**双指针法**，它通过一种巧妙的方式让两个指针走过相同的路径，从而在相交点相遇。下面为你详细解析其原理和代码。

### 🔍 算法原理：等长路径相遇

核心思想是消除两个链表的长度差。假设链表A的独有部分长度为 `a`，链表B的独有部分长度为 `b`，两者的公共部分长度为 `c`。

- 指针 `pA`的遍历路径为：`a`+ `c`+ `b`(先走完A，再走B的独有部分)
    
- 指针 `pB`的遍历路径为：`b`+ `c`+ `a`(先走完B，再走A的独有部分)
    

如果两链表相交（`c`> 0），`pA`和 `pB`会在走完 `a + b + c`后于相交节点相遇。如果不相交（`c`= 0），它们会同时走向 `null`，最终以 `pA == pB == null`结束循环。

### 🧩 代码逐步分析

```
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    ListNode pA = headA;
    ListNode pB = headB;
    while (pA != pB) { // 1. 当两个指针未指向同一节点时继续循环
        // 2. 指针pA的移动规则：如果当前不为空，则后移；如果已走到A链表末尾，则跳转到B链表头部
        pA = (pA == null) ? headB : pA.next;
        // 3. 指针pB的移动规则：如果当前不为空，则后移；如果已走到B链表末尾，则跳转到A链表头部
        pB = (pB == null) ? headA : pB.next;
    }
    // 4. 循环退出时，pA和pB要么指向相交节点，要么都为null
    return pA;
}
```

_注：代码中的三元运算符确保了指针在到达链表末尾后能正确切换路径。_

### ⚙️ 关键点与边界情况

1. **时间复杂度**：O(m + n)，其中 m 和 n 分别是链表A和B的长度。每个指针最多遍历两个链表各一次。
    
2. **空间复杂度**：O(1)，仅使用了两个固定指针。
    
3. **不相交情况**：当两链表不相交时，`pA`和 `pB`会同时变为 `null`，循环结束并返回 `null`。
    
4. **有环链表**：题目已明确链表中无环，此解法安全。若链表可能有环，则需先判断环的存在。
    

### 🔄 与其他方法对比

|方法|思路|时间复杂度|空间复杂度|优点|
|---|---|---|---|---|
|**双指针法（本文代码）**​|指针交替遍历两链表，路径补偿|O(m+n)|**O(1)**​|**空间效率最优**，代码简洁|
|**哈希表法**​|遍历A链表节点存入哈希表，遍历B链表时检查|O(m+n)|O(m) 或 O(n)|思路直观，但需要额外空间|
|**计算长度法**​|计算两链表长度差，长链表指针先走差值步|O(m+n)|O(1)|理解容易，但需两次遍历|

### 💎 总结

你提供的这段双指针代码是解决相交链表问题的**优雅且高效**的实现。它通过让两个指针走过相同的总长度，巧妙地规避了直接计算链表长度的步骤，在保证O(m+n)时间复杂度的同时，将空间复杂度降至O(1)，是面试和实践中非常受欢迎的解法。

希望这个分析能帮助你更深入地理解这个经典的算法问题！如果还有疑问，可以随时提出。

