我为您整理了合并两个有序链表的题目描述和代码。您提供的递归解法是正确的，下面同时为您提供递归和迭代两种解法的详细说明。

### **题目描述**

将两个升序链表合并为一个新的 **升序**​ 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例 1：**

- 输入：`list1 = [1,2,4]`, `list2 = [1,3,4]`
    
- 输出：`[1,1,2,3,4,4]`
    

**示例 2：**

- 输入：`list1 = []`, `list2 = []`
    
- 输出：`[]`
    

**示例 3：**

- 输入：`list1 = []`, `list2 = [0]`
    
- 输出：`[0]`
    

**提示：**

- 两个链表的节点数目范围是 `[0, 50]`
    
- `-100 <= Node.val <= 100`
    
- `list1`和 `list2`均按 **非递减顺序**​ 排列
    

---

### **解法一：递归（您提供的方法）**

您提供的代码使用了递归策略，其核心思想是：比较两个链表头节点的值，将较小值的节点作为合并后链表的当前节点，然后递归地合并剩余部分。

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        // 基准情况：如果 list1 为空，直接返回 list2
        if (list1 == null) {
            return list2;
        }
        // 基准情况：如果 list2 为空，直接返回 list1
        if (list2 == null) {
            return list1;
        }
        
        ListNode newNode = new ListNode();
        // 选择值较小的节点作为新链表的头节点
        if (list1.val < list2.val) {
            newNode.val = list1.val;
            // 递归合并 list1 的下一个节点和 list2
            newNode.next = mergeTwoLists(list1.next, list2);
        } else {
            newNode.val = list2.val;
            // 递归合并 list1 和 list2 的下一个节点
            newNode.next = mergeTwoLists(list1, list2.next);
        }
        return newNode;
    }
}
```

**复杂度分析：**

- **时间复杂度**：O(n + m)，其中 n 和 m 分别为两个链表的长度。每个节点都会被访问一次。
    
- **空间复杂度**：O(n + m)，递归调用栈的深度最多为 n + m。
    

---

### **解法二：迭代（常用方法）**

迭代法通过使用一个**哨兵节点（Dummy Node）**​ 来简化边界条件的处理，代码逻辑清晰直观。

```
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        // 创建一个哨兵节点，其next指针将指向合并后链表的头节点
        ListNode prehead = new ListNode(-1);
        // prev 指针用于构建新链表
        ListNode prev = prehead;
        
        // 当两个链表都还有节点时，进行比较和链接
        while (list1 != null && list2 != null) {
            if (list1.val <= list2.val) {
                prev.next = list1;
                list1 = list1.next;
            } else {
                prev.next = list2;
                list2 = list2.next;
            }
            prev = prev.next;
        }
        
        // 循环结束后，直接将剩余的非空链表连接到新链表的末尾
        prev.next = (list1 == null) ? list2 : list1;
        
        // 哨兵节点的next即为新链表的实际头节点
        return prehead.next;
    }
}
```

**复杂度分析：**

- **时间复杂度**：O(n + m)。
    
- **空间复杂度**：O(1)，只使用了固定的额外空间（哨兵节点和指针）。
    

### **总结**

|特性|递归法|迭代法|
|---|---|---|
|**思路**​|通过递归调用，每次选择较小的节点链接|使用循环和指针，逐个比较和链接节点|
|**空间复杂度**​|O(n+m)（递归栈）|O(1)|
|**优点**​|代码简洁，逻辑直接|空间效率高，适合处理大链表|
|**推荐场景**​|理解递归思想，链表长度不大时|追求最优空间效率，生产环境常用|

两种方法都是解决此问题的有效策略。您的递归解法是正确的，迭代法则在空间效率上更优。