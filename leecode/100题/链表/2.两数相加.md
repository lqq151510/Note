### 题目描述

给你两个 **非空**​ 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序**​ 的方式存储的，并且每个节点只能存储 **一位**​ 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例**：

|示例|输入|输出|解释|
|---|---|---|---|
|1|l1 = [2,4,3], l2 = [5,6,4]|[7,0,8]|342 + 465 = 807|
|2|l1 = [0], l2 = [0]|[0]|0 + 0 = 0|
|3|l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]|[8,9,9,9,0,0,0,1]|表示两个大数相加，最后有进位|

### 代码实现

以下Java解决方案模拟了手工竖式加法的过程，逐位相加并处理进位，是最高效且正确的方法。

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        // 创建一个虚拟头节点，简化链表操作
        ListNode dummyHead = new ListNode(0);
        // 当前指针，用于构建新链表
        ListNode curr = dummyHead;
        // 进位值，初始为0
        int carry = 0;

        // 循环条件：只要两个链表有一个不为空，或者还有进位，就继续计算
        while (l1 != null || l2 != null || carry != 0) {
            // 获取当前节点的值，如果节点为空则视为0
            int x = (l1 != null) ? l1.val : 0;
            int y = (l2 != null) ? l2.val : 0;
            // 计算当前位的和（包括进位）
            int sum = carry + x + y;
            // 更新进位值
            carry = sum / 10;
            // 创建新节点，存储当前位的计算结果（个位数）
            curr.next = new ListNode(sum % 10);
            // 将当前指针移动到新节点
            curr = curr.next;
            // 移动原链表的指针，如果已经为空则不再移动
            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }
        // 返回虚拟头节点的下一个节点，即结果链表的真正头节点
        return dummyHead.next;
    }
}
```

### 关键点解读

- **虚拟头节点（Dummy Head）**：这是一个常用的技巧，可以避免对空链表的特殊判断，简化代码逻辑。最终返回 `dummyHead.next`即可。
    
- **进位处理**：变量 `carry`是算法的核心，它记录每一位相加后产生的进位（0或1），并参与到下一位的计算中。这是正确解决此问题的关键。
    
- **循环条件**：`while (l1 != null || l2 != null || carry != 0)`这个条件确保了即使两个链表都遍历完毕，只要还有进位，就会多进行一次循环来处理最高位的进位（如示例3）。
    

### 总结

这个解法的时间复杂度为 O(max(m, n))，空间复杂度为 O(max(m, n))，其中 m 和 n 分别是两个链表的长度。它是一种最优解法。 在编写代码时，请特别注意在循环内移动 `curr`指针，这是保证结果正确的关键步骤。你可以使用题目中的示例来验证代码逻辑。