
## 题目描述

给定一个整数数组 `temperatures`，表示每天的温度，返回一个数组 `answer`，其中 `answer[i]`是指对于第 `i`天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0`来代替。

**示例 1:**

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

**示例 2:**

```
输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
```

**示例 3:**

```
输入: temperatures = [30,60,90]
输出: [1,1,0]
```

## 解题思路

本题可以使用**单调递减栈**来高效解决：

- 栈中存储的是数组的**索引**而非温度值
    
- 维护一个单调递减的栈（栈顶到栈底是递减的）
    
- 遍历每个温度，当当前温度大于栈顶索引对应的温度时，说明找到了栈顶元素的下一个更高温度
    
- 计算天数差（当前索引 - 栈顶索引）并更新结果数组
    
- 将当前索引压入栈中
    

## 代码实现

```
import java.util.ArrayDeque;
import java.util.Deque;

class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        int[] answer = new int[n]; // 结果数组，默认全是0
        
        // 栈里存的是「索引」，不是温度值！
        // 因为我们需要通过索引计算「天数差」，还要通过索引拿到温度值比较
        Deque<Integer> stack = new ArrayDeque<>();
        
        for (int i = 0; i < n; i++) {
            // 当栈不为空且当前温度大于栈顶索引对应的温度时
            while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
                int prev = stack.pop(); // 取出栈顶索引
                answer[prev] = i - prev; // 计算天数差
            }
            stack.push(i); // 将当前索引压入栈中
        }
        
        return answer;
    }
}
```

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是数组的长度。每个元素最多入栈和出栈一次。
    
- **空间复杂度**：O(n)，最坏情况下栈中会存储所有元素的索引。
    

## 关键点

1. 使用单调递减栈，栈中存储的是索引而非温度值
    
2. 当遇到更高的温度时，更新栈中所有比当前温度低的元素
    
3. 结果数组中默认值为0，无需额外处理找不到更高温度的情况