# Java算法：斐波那契查找

## 定义

斐波那契查找（Fibonacci Search）是一种在**有序数组**中查找目标值的算法，是**二分查找**的一种改进版本。它利用**黄金分割原理**（约0.618）来划分查找区间，而不是简单的二分。

### 核心思想

1. 基于**斐波那契数列**（0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...）
    
2. 每个数字是前两个数字之和：F(k) = F(k-1) + F(k-2)
    
3. 利用斐波那契数列的性质来划分查找区间
    
4. 时间复杂度：O(log n)，与二分查找相同
    

### 斐波那契数列的性质

- 相邻两个斐波那契数的比值趋近于黄金分割比0.618
    
- F(k) = F(k-1) + F(k-2)
    
- 当n趋向无穷大时，F(k-1)/F(k) ≈ 0.618
    

## 算法原理

### 算法步骤

1. 找到大于或等于数组长度的最小斐波那契数F(k)
    
2. 将数组长度扩展到F(k)-1（不足部分用最后一个元素填充）
    
3. 比较目标值与位置F(k-1)-1处的元素
    
4. 根据比较结果调整查找区间
    
5. 重复直到找到或区间为空
    

### 与二分查找的比较

|特性|斐波那契查找|二分查找|
|---|---|---|
|**分割点**​|使用黄金分割点（约0.618）|使用中点（0.5）|
|**除法运算**​|只有加减法，无除法|需要除法运算|
|**效率**​|在特定情况下比二分查找更快|稳定的O(log n)|
|**实现复杂度**​|较复杂|较简单|

## Java实现示例

### 1. 基础实现

```
import java.util.Arrays;

public class FibonacciSearch {
    
    /**
     * 斐波那契查找算法
     * @param arr 有序数组
     * @param target 目标值
     * @return 目标值的索引，未找到返回-1
     */
    public static int fibonacciSearch(int[] arr, int target) {
        // 边界检查
        if (arr == null || arr.length == 0) {
            return -1;
        }
        
        int n = arr.length;
        
        // 1. 初始化斐波那契数列
        int fibMMinus2 = 0;  // F(k-2)
        int fibMMinus1 = 1;  // F(k-1)
        int fibM = fibMMinus1 + fibMMinus2;  // F(k)
        
        // 2. 找到大于等于数组长度的最小斐波那契数
        while (fibM < n) {
            fibMMinus2 = fibMMinus1;
            fibMMinus1 = fibM;
            fibM = fibMMinus1 + fibMMinus2;
        }
        
        // 3. 初始化偏移量
        int offset = -1;
        
        // 4. 开始查找
        while (fibM > 1) {
            // 计算当前分割点索引
            int i = Math.min(offset + fibMMinus2, n - 1);
            
            if (arr[i] < target) {
                // 目标值在右侧
                fibM = fibMMinus1;
                fibMMinus1 = fibMMinus2;
                fibMMinus2 = fibM - fibMMinus1;
                offset = i;
            } else if (arr[i] > target) {
                // 目标值在左侧
                fibM = fibMMinus2;
                fibMMinus1 = fibMMinus1 - fibMMinus2;
                fibMMinus2 = fibM - fibMMinus1;
            } else {
                // 找到目标值
                return i;
            }
        }
        
        // 5. 检查最后一个元素
        if (fibMMinus1 == 1 && arr[offset + 1] == target) {
            return offset + 1;
        }
        
        return -1;  // 未找到
    }
    
    /**
     * 生成斐波那契数列
     * @param n 生成数列长度
     * @return 斐波那契数列数组
     */
    public static int[] generateFibonacci(int n) {
        if (n <= 0) return new int[0];
        
        int[] fib = new int[n];
        if (n >= 1) fib[0] = 0;
        if (n >= 2) fib[1] = 1;
        
        for (int i = 2; i < n; i++) {
            fib[i] = fib[i-1] + fib[i-2];
        }
        
        return fib;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29};
        int target = 13;
        
        System.out.println("有序数组: " + Arrays.toString(arr));
        System.out.println("目标值: " + target);
        
        int index = fibonacciSearch(arr, target);
        
        if (index != -1) {
            System.out.println("找到目标值，索引: " + index);
        } else {
            System.out.println("未找到目标值");
        }
        
        // 测试多个查找
        int[] targets = {1, 15, 29, 8, 30};
        for (int t : targets) {
            int result = fibonacciSearch(arr, t);
            System.out.println("查找 " + t + ": " + 
                (result != -1 ? "找到，索引 " + result : "未找到"));
        }
    }
}
```

### 2. 详细步骤演示版本

```
import java.util.Arrays;

public class FibonacciSearchDetailed {
    
    /**
     * 带详细步骤输出的斐波那契查找
     */
    public static int fibonacciSearchWithSteps(int[] arr, int target) {
        if (arr == null || arr.length == 0) {
            System.out.println("数组为空！");
            return -1;
        }
        
        System.out.println("=== 斐波那契查找开始 ===");
        System.out.println("目标数组: " + Arrays.toString(arr));
        System.out.println("数组长度: " + arr.length);
        System.out.println("查找目标: " + target);
        System.out.println();
        
        int n = arr.length;
        
        // 1. 生成斐波那契数列
        System.out.println("步骤1: 初始化斐波那契数列");
        int fibMMinus2 = 0;  // F(k-2)
        int fibMMinus1 = 1;  // F(k-1)
        int fibM = fibMMinus1 + fibMMinus2;  // F(k)
        
        System.out.println("  F(k-2) = " + fibMMinus2);
        System.out.println("  F(k-1) = " + fibMMinus1);
        System.out.println("  F(k)   = " + fibM);
        
        // 2. 找到合适的斐波那契数
        System.out.println("\n步骤2: 找到大于等于数组长度的最小斐波那契数");
        while (fibM < n) {
            fibMMinus2 = fibMMinus1;
            fibMMinus1 = fibM;
            fibM = fibMMinus1 + fibMMinus2;
            System.out.println("  F(k-2)=" + fibMMinus2 + 
                             ", F(k-1)=" + fibMMinus1 + 
                             ", F(k)=" + fibM);
        }
        
        // 3. 初始化
        int offset = -1;
        int step = 1;
        
        System.out.println("\n步骤3: 开始查找循环");
        System.out.println("  初始: offset = " + offset + 
                         ", F(k) = " + fibM + 
                         ", F(k-1) = " + fibMMinus1 + 
                         ", F(k-2) = " + fibMMinus2);
        
        // 4. 查找循环
        while (fibM > 1) {
            System.out.println("\n  --- 第" + step + "次迭代 ---");
            
            // 计算当前索引
            int i = Math.min(offset + fibMMinus2, n - 1);
            System.out.println("  当前索引 i = min(" + offset + " + " + 
                             fibMMinus2 + ", " + (n-1) + ") = " + i);
            System.out.println("  比较 arr[" + i + "] = " + arr[i] + 
                             " 和 target = " + target);
            
            if (arr[i] < target) {
                System.out.println "  " + arr[i] + " < " + target + 
                                 " → 目标在右侧，向右移动");
                fibM = fibMMinus1;
                fibMMinus1 = fibMMinus2;
                fibMMinus2 = fibM - fibMMinus1;
                offset = i;
                System.out.println("    更新: offset = " + offset + 
                                 ", F(k) = " + fibM + 
                                 ", F(k-1) = " + fibMMinus1 + 
                                 ", F(k-2) = " + fibMMinus2);
            } else if (arr[i] > target) {
                System.out.println("  " + arr[i] + " > " + target + 
                                 " → 目标在左侧，向左移动");
                fibM = fibMMinus2;
                fibMMinus1 = fibMMinus1 - fibMMinus2;
                fibMMinus2 = fibM - fibMMinus1;
                System.out.println("    更新: F(k) = " + fibM + 
                                 ", F(k-1) = " + fibMMinus1 + 
                                 ", F(k-2) = " + fibMMinus2);
            } else {
                System.out.println("  √ 找到目标值！索引: " + i);
                return i;
            }
            step++;
        }
        
        // 5. 检查最后一个元素
        System.out.println("\n步骤4: 检查最后一个元素");
        if (fibMMinus1 == 1 && offset + 1 < n && arr[offset + 1] == target) {
            System.out.println("  √ 在索引 " + (offset + 1) + " 找到目标值");
            return offset + 1;
        }
        
        System.out.println("  × 未找到目标值");
        return -1;
    }
    
    public static void main(String[] args) {
        int[] arr = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30};
        int target = 18;
        
        int result = fibonacciSearchWithSteps(arr, target);
        System.out.println("\n=== 查找结果 ===");
        System.out.println("目标值 " + target + " 的位置: " + 
            (result != -1 ? "索引 " + result : "未找到"));
    }
}
```

### 3. 扩展：斐波那契查找工具类

```
import java.util.Arrays;

public class FibonacciSearchUtil {
    
    /**
     * 斐波那契查找工具类
     */
    public static class SearchResult {
        private boolean found;
        private int index;
        private int comparisons;
        private int[] fibonacciSequence;
        
        public SearchResult(boolean found, int index, int comparisons, int[] fibonacciSequence) {
            this.found = found;
            this.index = index;
            this.comparisons = comparisons;
            this.fibonacciSequence = fibonacciSequence;
        }
        
        public boolean isFound() { return found; }
        public int getIndex() { return index; }
        public int getComparisons() { return comparisons; }
        public int[] getFibonacciSequence() { return fibonacciSequence; }
        
        @Override
        public String toString() {
            return String.format("找到: %s, 索引: %d, 比较次数: %d, 使用的斐波那契数: %s",
                found, index, comparisons, Arrays.toString(fibonacciSequence));
        }
    }
    
    /**
     * 带统计信息的斐波那契查找
     */
    public static SearchResult fibonacciSearchWithStats(int[] arr, int target) {
        int comparisons = 0;
        
        if (arr == null || arr.length == 0) {
            return new SearchResult(false, -1, comparisons, new int[0]);
        }
        
        int n = arr.length;
        
        // 生成斐波那契数列直到找到合适的
        int fibMMinus2 = 0;
        int fibMMinus1 = 1;
        int fibM = fibMMinus1 + fibMMinus2;
        
        // 记录使用的斐波那契数
        java.util.List<Integer> fibList = new java.util.ArrayList<>();
        fibList.add(fibMMinus2);
        fibList.add(fibMMinus1);
        
        while (fibM < n) {
            fibMMinus2 = fibMMinus1;
            fibMMinus1 = fibM;
            fibM = fibMMinus1 + fibMMinus2;
            fibList.add(fibM);
        }
        
        int offset = -1;
        
        while (fibM > 1) {
            int i = Math.min(offset + fibMMinus2, n - 1);
            comparisons++;
            
            if (arr[i] < target) {
                fibM = fibMMinus1;
                fibMMinus1 = fibMMinus2;
                fibMMinus2 = fibM - fibMMinus1;
                offset = i;
            } else if (arr[i] > target) {
                fibM = fibMMinus2;
                fibMMinus1 = fibMMinus1 - fibMMinus2;
                fibMMinus2 = fibM - fibMMinus1;
            } else {
                return new SearchResult(true, i, comparisons, 
                    fibList.stream().mapToInt(Integer::intValue).toArray());
            }
        }
        
        comparisons++;
        if (fibMMinus1 == 1 && offset + 1 < n && arr[offset + 1] == target) {
            return new SearchResult(true, offset + 1, comparisons,
                fibList.stream().mapToInt(Integer::intValue).toArray());
        }
        
        return new SearchResult(false, -1, comparisons,
            fibList.stream().mapToInt(Integer::intValue).toArray());
    }
    
    /**
     * 比较斐波那契查找和二分查找的性能
     */
    public static void compareWithBinarySearch(int[] arr, int target) {
        System.out.println("=== 性能比较: 斐波那契查找 vs 二分查找 ===");
        
        // 斐波那契查找
        long startTime = System.nanoTime();
        SearchResult fibResult = fibonacciSearchWithStats(arr, target);
        long fibTime = System.nanoTime() - startTime;
        
        // 二分查找
        startTime = System.nanoTime();
        int binResult = binarySearch(arr, target);
        long binTime = System.nanoTime() - startTime;
        
        System.out.println("数组大小: " + arr.length);
        System.out.println("目标值: " + target);
        System.out.println("\n斐波那契查找:");
        System.out.println("  结果: " + (fibResult.isFound() ? "找到" : "未找到"));
        System.out.println("  比较次数: " + fibResult.getComparisons());
        System.out.println("  用时: " + fibTime + " 纳秒");
        
        System.out.println("\n二分查找:");
        System.out.println("  结果: " + (binResult != -1 ? "找到" : "未找到"));
        System.out.println("  用时: " + binTime + " 纳秒");
        
        System.out.println("\n性能差异: " + (fibTime - binTime) + " 纳秒");
    }
    
    /**
     * 标准二分查找
     */
    public static int binarySearch(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        int comparisons = 0;
        
        while (left <= right) {
            comparisons++;
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return -1;
    }
    
    public static void main(String[] args) {
        // 创建测试数组
        int[] arr = new int[100];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = i * 2;  // 偶数序列
        }
        
        // 测试不同的目标值
        int[] targets = {0, 50, 99, 100, 198, 199};
        
        for (int target : targets) {
            System.out.println("\n=== 测试目标值: " + target + " ===");
            SearchResult result = fibonacciSearchWithStats(arr, target);
            System.out.println(result);
            
            int binIndex = binarySearch(arr, target);
            System.out.println("二分查找结果: " + 
                (binIndex != -1 ? "索引 " + binIndex : "未找到"));
        }
        
        // 性能比较
        compareWithBinarySearch(arr, 150);
    }
}
```

## 算法详细解释

### 工作原理示例

假设数组：`[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]`，查找目标：`13`

1. **初始化**：
    
    - 数组长度 n = 10
        
    - 斐波那契数列：0, 1, 1, 2, 3, 5, 8, 13, 21, ...
        
    - 大于等于10的最小斐波那契数是13（F(7) = 13）
        
    - 所以：F(k) = 13, F(k-1) = 8, F(k-2) = 5
        
    - offset = -1
        
    
2. **第1次迭代**：
    
    - i = min(-1 + 5, 9) = 4
        
    - arr[4] = 9 < 13
        
    - 目标在右侧，更新：
        
        - F(k) = 8, F(k-1) = 5, F(k-2) = 3
            
        - offset = 4
            
        
    
3. **第2次迭代**：
    
    - i = min(4 + 3, 9) = 7
        
    - arr[7] = 15 > 13
        
    - 目标在左侧，更新：
        
        - F(k) = 3, F(k-1) = 2, F(k-2) = 1
            
        
    
4. **第3次迭代**：
    
    - i = min(4 + 1, 9) = 5
        
    - arr[5] = 11 < 13
        
    - 目标在右侧，更新：
        
        - F(k) = 2, F(k-1) = 1, F(k-2) = 1
            
        - offset = 5
            
        
    
5. **第4次迭代**：
    
    - i = min(5 + 1, 9) = 6
        
    - arr[6] = 13 == 13
        
    - 找到目标，返回索引6
        
    

## 扩展：斐波那契查找的变体

### 1. 递归实现

```
public class FibonacciSearchRecursive {
    
    /**
     * 递归实现斐波那契查找
     */
    public static int fibonacciSearchRecursive(int[] arr, int target) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        
        int n = arr.length;
        
        // 生成斐波那契数列
        int fibMMinus2 = 0;
        int fibMMinus1 = 1;
        int fibM = fibMMinus1 + fibMMinus2;
        
        while (fibM < n) {
            fibMMinus2 = fibMMinus1;
            fibMMinus1 = fibM;
            fibM = fibMMinus1 + fibMMinus2;
        }
        
        return fibonacciSearchRecursive(arr, target, 0, n-1, 
                                       fibM, fibMMinus1, fibMMinus2);
    }
    
    private static int fibonacciSearchRecursive(int[] arr, int target, 
                                               int offset, int n, 
                                               int fibM, int fibMMinus1, int fibMMinus2) {
        if (fibM <= 1) {
            if (fibMMinus1 == 1 && offset < n && arr[offset] == target) {
                return offset;
            }
            return -1;
        }
        
        int i = Math.min(offset + fibMMinus2, n);
        
        if (i > n) {
            return -1;
        }
        
        if (arr[i] < target) {
            return fibonacciSearchRecursive(arr, target, i, n, 
                                          fibMMinus1, fibMMinus2, fibMMinus1 - fibMMinus2);
        } else if (arr[i] > target) {
            return fibonacciSearchRecursive(arr, target, offset, i-1, 
                                          fibMMinus2, fibMMinus1 - fibMMinus2, 
                                          fibMMinus2 - (fibMMinus1 - fibMMinus2));
        } else {
            return i;
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20};
        int target = 12;
        
        int index = fibonacciSearchRecursive(arr, target);
        
        if (index != -1) {
            System.out.println("找到目标值 " + target + "，索引: " + index);
        } else {
            System.out.println("未找到目标值 " + target);
        }
    }
}
```

### 2. 带扩展数组的版本

```
public class FibonacciSearchExtended {
    
    /**
     * 斐波那契查找（带数组扩展）
     * 将数组扩展到斐波那契数的大小
     */
    public static int fibonacciSearchWithExtension(int[] arr, int target) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        
        int n = arr.length;
        
        // 找到大于等于n的最小斐波那契数
        int fibMMinus2 = 0;
        int fibMMinus1 = 1;
        int fibM = fibMMinus1 + fibMMinus2;
        
        while (fibM < n) {
            fibMMinus2 = fibMMinus1;
            fibMMinus1 = fibM;
            fibM = fibMMinus1 + fibMMinus2;
        }
        
        // 扩展数组
        int[] extendedArr = new int[fibM];
        System.arraycopy(arr, 0, extendedArr, 0, n);
        
        // 用最后一个元素填充扩展部分
        for (int i = n; i < fibM; i++) {
            extendedArr[i] = arr[n-1];
        }
        
        int offset = -1;
        
        while (fibM > 1) {
            int i = Math.min(offset + fibMMinus2, fibM - 1);
            
            if (extendedArr[i] < target) {
                fibM = fibMMinus1;
                fibMMinus1 = fibMMinus2;
                fibMMinus2 = fibM - fibMMinus1;
                offset = i;
            } else if (extendedArr[i] > target) {
                fibM = fibMMinus2;
                fibMMinus1 = fibMMinus1 - fibMMinus2;
                fibMMinus2 = fibM - fibMMinus1;
            } else {
                // 如果找到的位置在原始数组范围内
                if (i < n) {
                    return i;
                } else {
                    // 如果找到的位置是扩展部分，返回最后一个元素的索引
                    return n - 1;
                }
            }
        }
        
        if (fibMMinus1 == 1 && offset + 1 < n && extendedArr[offset + 1] == target) {
            return offset + 1;
        }
        
        return -1;
    }
    
    public static void main(String[] args) {
        int[] arr = {10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100};
        int target = 85;
        
        System.out.println("原始数组: " + java.util.Arrays.toString(arr));
        System.out.println("数组长度: " + arr.length);
        
        int index = fibonacciSearchWithExtension(arr, target);
        
        if (index != -1) {
            System.out.println("找到目标值 " + target + "，索引: " + index);
        } else {
            System.out.println("未找到目标值 " + target);
        }
        
        // 测试边界情况
        System.out.println("\n测试边界值:");
        System.out.println("查找10: " + fibonacciSearchWithExtension(arr, 10));
        System.out.println("查找100: " + fibonacciSearchWithExtension(arr, 100));
        System.out.println("查找95: " + fibonacciSearchWithExtension(arr, 95));
    }
}
```

## 性能分析

### 时间复杂度

- **最好情况**：O(1) - 第一次比较就找到
    
- **平均情况**：O(log n)
    
- **最坏情况**：O(log n)
    

### 空间复杂度

- **迭代版本**：O(1) - 只使用常数级别的额外空间
    
- **递归版本**：O(log n) - 递归调用栈的空间
    

### 比较次数

对于长度为n的数组：

- 斐波那契查找的比较次数约为 1.44 * log₂(n)
    
- 二分查找的比较次数约为 log₂(n)
    
- 斐波那契查找的比较次数略多于二分查找，但避免了除法运算
    

## 适用场景

### 适合使用斐波那契查找的情况：

1. **大型有序数组**
    
2. **数组访问成本较高**的情况
    
3. **CPU除法运算较慢**的嵌入式系统
    
4. **对算法效率有严格要求**的场合
    

### 不适合使用斐波那契查找的情况：

1. **小型数组**（直接使用顺序查找即可）
    
2. **无序数组**（需要先排序）
    
3. **频繁插入删除**的动态数组
    
4. **内存受限**的环境
    

## 总结

斐波那契查找是一种基于黄金分割原理的高效查找算法，具有以下特点：

1. **优点**：
    
    - 时间复杂度O(log n)，与二分查找相当
        
    - 避免了除法运算，在某些系统中性能更好
        
    - 基于斐波那契数列，具有数学美感
        
    
2. **缺点**：
    
    - 实现比二分查找复杂
        
    - 需要额外的斐波那契数计算
        
    - 实际性能提升有限，大多数情况下不如二分查找简单高效
        
    
3. **选择建议**：
    
    - 大多数情况下，使用二分查找更简单直观
        
    - 只有在特定硬件（除法运算慢）或特殊需求下才考虑使用斐波那契查找
        
    - 作为算法学习的经典案例，有助于理解不同的查找策略
        
    

虽然在实际应用中二分查找更为常见，但斐波那契查找作为一种经典的查找算法，对于理解算法设计和优化思想仍有重要价值。