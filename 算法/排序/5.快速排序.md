# Java算法：快速排序

## 定义

**快速排序**（Quick Sort）是一种高效的排序算法，采用**分治法**（Divide and Conquer）策略。它通过一趟排序将待排序的数据分割成独立的两部分，其中一部分的所有数据都比另一部分的所有数据小，然后再按此方法对这两部分数据分别进行快速排序，整个过程递归进行，以此达到整个数据变成有序序列。

### 算法原理

1. **选择基准**：从数组中选择一个元素作为基准（pivot）
    
2. **分区操作**：重新排列数组，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数组的中间位置
    
3. **递归排序**：递归地将小于基准值的子数组和大于基准值的子数组排序
    

### 特点

|特性|描述|
|---|---|
|**时间复杂度**​|最好O(n log n)，平均O(n log n)，最坏O(n²)|
|**空间复杂度**​|平均O(log n)，最坏O(n)（递归调用栈）|
|**稳定性**​|不稳定排序算法|
|**原地排序**​|是|
|**适应性**​|对部分有序数组效率可能降低|

## 算法可视化

```
初始数组: [3, 6, 8, 10, 1, 2, 1]

选择基准（最右边元素1）:
分区: 将小于等于基准的元素放在左边，大于基准的元素放在右边
结果: [1, 1, 3, 6, 8, 10, 2] → 基准1在位置1

左子数组: [1] (已排序)
右子数组: [3, 6, 8, 10, 2]
选择基准2:
分区: [2, 3, 6, 8, 10] → 基准2在位置0

继续递归...
最终结果: [1, 1, 2, 3, 6, 8, 10]
```

## Java实现示例

### 1. 基础快速排序（递归实现）

```
import java.util.Arrays;

public class QuickSort {
    
    /**
     * 快速排序（递归）
     * @param arr 待排序数组
     */
    public static void quickSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        quickSort(arr, 0, arr.length - 1);
    }
    
    private static void quickSort(int[] arr, int left, int right) {
        if (left < right) {
            // 分区操作，返回基准值的正确位置索引
            int pivotIndex = partition(arr, left, right);
            
            // 递归排序左子数组
            quickSort(arr, left, pivotIndex - 1);
            // 递归排序右子数组
            quickSort(arr, pivotIndex + 1, right);
        }
    }
    
    /**
     * 分区操作，选择最右边的元素作为基准
     */
    private static int partition(int[] arr, int left, int right) {
        int pivot = arr[right];  // 选择最右边的元素作为基准
        int i = left - 1;  // 指向小于基准的区域的最后一个元素
        
        System.out.println("分区: 基准 = " + pivot + 
                         ", 范围 [" + left + ", " + right + "]");
        System.out.println("初始数组: " + Arrays.toString(Arrays.copyOfRange(arr, left, right + 1)));
        
        for (int j = left; j < right; j++) {
            // 如果当前元素小于等于基准
            if (arr[j] <= pivot) {
                i++;
                swap(arr, i, j);
                System.out.println("  交换 arr[" + i + "]=" + arr[i] + 
                                 " 和 arr[" + j + "]=" + arr[j]);
            }
        }
        
        // 将基准放到正确位置
        swap(arr, i + 1, right);
        System.out.println("  将基准放到位置 " + (i + 1));
        System.out.println("  分区后: " + Arrays.toString(Arrays.copyOfRange(arr, left, right + 1)));
        System.out.println("  基准位置: " + (i + 1));
        
        return i + 1;  // 返回基准的索引
    }
    
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    public static void main(String[] args) {
        int[] arr = {3, 6, 8, 10, 1, 2, 1};
        
        System.out.println("=== 基础快速排序演示 ===");
        System.out.println("原始数组: " + Arrays.toString(arr));
        System.out.println();
        
        int[] arrCopy = arr.clone();
        quickSort(arrCopy);
        
        System.out.println("\n排序结果: " + Arrays.toString(arrCopy));
    }
}
```

### 2. 快速排序优化（三数取中法）

```
import java.util.Arrays;

public class QuickSortOptimized {
    
    /**
     * 快速排序（优化版本）
     * 1. 三数取中法选择基准
     * 2. 小数组使用插入排序
     */
    private static final int INSERTION_SORT_THRESHOLD = 7;
    
    public static void quickSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        quickSort(arr, 0, arr.length - 1);
    }
    
    private static void quickSort(int[] arr, int left, int right) {
        // 小数组使用插入排序
        if (right - left + 1 <= INSERTION_SORT_THRESHOLD) {
            insertionSort(arr, left, right);
            return;
        }
        
        if (left < right) {
            int pivotIndex = partition(arr, left, right);
            quickSort(arr, left, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, right);
        }
    }
    
    /**
     * 分区操作，使用三数取中法选择基准
     */
    private static int partition(int[] arr, int left, int right) {
        // 三数取中法：选择左、中、右三个数的中位数作为基准
        int mid = left + (right - left) / 2;
        int pivotIndex = medianOfThree(arr, left, mid, right);
        
        // 将基准放到最右边
        swap(arr, pivotIndex, right);
        int pivot = arr[right];
        
        System.out.println("分区: 基准 = " + pivot + " (三数取中)" + 
                         ", 范围 [" + left + ", " + right + "]");
        
        int i = left - 1;
        for (int j = left; j < right; j++) {
            if (arr[j] <= pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        swap(arr, i + 1, right);
        return i + 1;
    }
    
    /**
     * 返回三个数的中位数的索引
     */
    private static int medianOfThree(int[] arr, int a, int b, int c) {
        int valA = arr[a];
        int valB = arr[b];
        int valC = arr[c];
        
        if (valA < valB) {
            if (valB < valC) {
                return b;  // a < b < c
            } else if (valA < valC) {
                return c;  // a < c <= b
            } else {
                return a;  // c <= a < b
            }
        } else {
            if (valA < valC) {
                return a;  // b <= a < c
            } else if (valB < valC) {
                return c;  // b < c <= a
            } else {
                return b;  // c <= b <= a
            }
        }
    }
    
    /**
     * 插入排序
     */
    private static void insertionSort(int[] arr, int left, int right) {
        System.out.println("小数组 [" + left + ", " + right + 
                         "] 使用插入排序");
        
        for (int i = left + 1; i <= right; i++) {
            int key = arr[i];
            int j = i - 1;
            
            while (j >= left && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            
            arr[j + 1] = key;
        }
    }
    
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    public static void main(String[] args) {
        int[] arr = {3, 6, 8, 10, 1, 2, 1, 5, 7, 4, 9};
        
        System.out.println("=== 优化快速排序演示 ===");
        System.out.println("原始数组: " + Arrays.toString(arr));
        System.out.println();
        
        int[] arrCopy = arr.clone();
        quickSort(arrCopy);
        
        System.out.println("\n排序结果: " + Arrays.toString(arrCopy));
        
        // 测试小数组优化
        System.out.println("\n=== 测试小数组优化 ===");
        int[] smallArr = {5, 2, 4, 1, 3};
        System.out.println("原始数组: " + Arrays.toString(smallArr));
        
        quickSort(smallArr.clone());
    }
}
```

### 3. 三路快速排序（处理大量重复元素）

```
import java.util.Arrays;

public class ThreeWayQuickSort {
    
    /**
     * 三路快速排序
     * 将数组分为三部分：小于基准、等于基准、大于基准
     * 适用于大量重复元素的数组
     */
    public static void threeWayQuickSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        threeWayQuickSort(arr, 0, arr.length - 1);
    }
    
    private static void threeWayQuickSort(int[] arr, int left, int right) {
        if (left < right) {
            // 随机选择基准，避免最坏情况
            int pivotIndex = left + (int)(Math.random() * (right - left + 1));
            swap(arr, pivotIndex, right);
            int pivot = arr[right];
            
            System.out.println("三路分区: 基准 = " + pivot + 
                             ", 范围 [" + left + ", " + right + "]");
            System.out.println("初始: " + Arrays.toString(Arrays.copyOfRange(arr, left, right + 1)));
            
            int lt = left;      // 小于基准的区域的右边界
            int gt = right;     // 大于基准的区域的左边界
            int i = left;       // 当前遍历的指针
            
            while (i <= gt) {
                if (arr[i] < pivot) {
                    swap(arr, lt, i);
                    System.out.println("  arr[" + i + "]=" + arr[i] + " < 基准 → 交换到左边");
                    lt++;
                    i++;
                } else if (arr[i] > pivot) {
                    swap(arr, i, gt);
                    System.out.println("  arr[" + i + "]=" + arr[i] + " > 基准 → 交换到右边");
                    gt--;
                } else {
                    System.out.println("  arr[" + i + "]=" + arr[i] + " = 基准 → 保持");
                    i++;
                }
            }
            
            System.out.println("分区后: " + Arrays.toString(Arrays.copyOfRange(arr, left, right + 1)));
            System.out.println("小于基准: [" + left + ", " + (lt-1) + "]");
            System.out.println("等于基准: [" + lt + ", " + gt + "]");
            System.out.println("大于基准: [" + (gt+1) + ", " + right + "]");
            
            // 递归排序小于和大于的部分
            threeWayQuickSort(arr, left, lt - 1);
            threeWayQuickSort(arr, gt + 1, right);
        }
    }
    
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    public static void main(String[] args) {
        int[] arr = {3, 6, 8, 3, 1, 2, 1, 5, 3, 4, 3};
        
        System.out.println("=== 三路快速排序演示（大量重复元素） ===");
        System.out.println("原始数组: " + Arrays.toString(arr));
        System.out.println();
        
        int[] arrCopy = arr.clone();
        threeWayQuickSort(arrCopy);
        
        System.out.println("\n排序结果: " + Arrays.toString(arrCopy));
    }
}
```

### 4. 非递归快速排序（使用栈）

```
import java.util.Arrays;
import java.util.Stack;

public class QuickSortIterative {
    
    /**
     * 非递归快速排序（使用栈模拟递归）
     */
    public static void quickSortIterative(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        
        Stack<Integer> stack = new Stack<>();
        stack.push(0);
        stack.push(arr.length - 1);
        
        int iteration = 0;
        
        while (!stack.isEmpty()) {
            int right = stack.pop();
            int left = stack.pop();
            
            iteration++;
            System.out.println("迭代 " + iteration + ": 处理范围 [" + left + ", " + right + "]");
            
            if (left < right) {
                int pivotIndex = partition(arr, left, right);
                
                // 将左子数组的边界压入栈
                if (pivotIndex - 1 > left) {
                    stack.push(left);
                    stack.push(pivotIndex - 1);
                }
                
                // 将右子数组的边界压入栈
                if (pivotIndex + 1 < right) {
                    stack.push(pivotIndex + 1);
                    stack.push(right);
                }
            }
        }
    }
    
    private static int partition(int[] arr, int left, int right) {
        int pivot = arr[right];
        int i = left - 1;
        
        for (int j = left; j < right; j++) {
            if (arr[j] <= pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        swap(arr, i + 1, right);
        return i + 1;
    }
    
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    public static void main(String[] args) {
        int[] arr = {3, 6, 8, 10, 1, 2, 1, 5, 7, 4, 9};
        
        System.out.println("=== 非递归快速排序演示 ===");
        System.out.println("原始数组: " + Arrays.toString(arr));
        System.out.println();
        
        int[] arrCopy = arr.clone();
        quickSortIterative(arrCopy);
        
        System.out.println("\n排序结果: " + Arrays.toString(arrCopy));
        
        // 测试避免栈溢出
        System.out.println("\n=== 测试大数组（避免递归栈溢出） ===");
        int[] largeArr = new int[10000];
        for (int i = 0; i < largeArr.length; i++) {
            largeArr[i] = (int)(Math.random() * 10000);
        }
        
        long startTime = System.currentTimeMillis();
        quickSortIterative(largeArr.clone());
        long endTime = System.currentTimeMillis();
        
        System.out.println("非递归快速排序 10000 个元素用时: " + (endTime - startTime) + "ms");
    }
}
```

### 5. 泛型快速排序

```
import java.util.Arrays;
import java.util.Comparator;
import java.util.Random;

public class GenericQuickSort {
    
    /**
     * 泛型快速排序（使用Comparable接口）
     */
    public static <T extends Comparable<T>> void quickSort(T[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        quickSort(arr, 0, arr.length - 1);
    }
    
    private static <T extends Comparable<T>> void quickSort(T[] arr, int left, int right) {
        if (left < right) {
            int pivotIndex = partition(arr, left, right);
            quickSort(arr, left, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, right);
        }
    }
    
    private static <T extends Comparable<T>> int partition(T[] arr, int left, int right) {
        // 随机选择基准，避免最坏情况
        int randomIndex = left + new Random().nextInt(right - left + 1);
        swap(arr, randomIndex, right);
        
        T pivot = arr[right];
        int i = left - 1;
        
        for (int j = left; j < right; j++) {
            if (arr[j].compareTo(pivot) <= 0) {
                i++;
                swap(arr, i, j);
            }
        }
        
        swap(arr, i + 1, right);
        return i + 1;
    }
    
    /**
     * 泛型快速排序（使用Comparator比较器）
     */
    public static <T> void quickSort(T[] arr, Comparator<T> comparator) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        quickSort(arr, 0, arr.length - 1, comparator);
    }
    
    private static <T> void quickSort(T[] arr, int left, int right, Comparator<T> comparator) {
        if (left < right) {
            int pivotIndex = partition(arr, left, right, comparator);
            quickSort(arr, left, pivotIndex - 1, comparator);
            quickSort(arr, pivotIndex + 1, right, comparator);
        }
    }
    
    private static <T> int partition(T[] arr, int left, int right, Comparator<T> comparator) {
        int randomIndex = left + new Random().nextInt(right - left + 1);
        swap(arr, randomIndex, right);
        
        T pivot = arr[right];
        int i = left - 1;
        
        for (int j = left; j < right; j++) {
            if (comparator.compare(arr[j], pivot) <= 0) {
                i++;
                swap(arr, i, j);
            }
        }
        
        swap(arr, i + 1, right);
        return i + 1;
    }
    
    private static <T> void swap(T[] arr, int i, int j) {
        T temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    /**
     * 学生类，用于演示
     */
    static class Student implements Comparable<Student> {
        String name;
        int score;
        int age;
        
        Student(String name, int score, int age) {
            this.name = name;
            this.score = score;
            this.age = age;
        }
        
        @Override
        public int compareTo(Student other) {
            return Integer.compare(this.score, other.score);
        }
        
        @Override
        public String toString() {
            return String.format("%s(分数:%d, 年龄:%d)", name, score, age);
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== 泛型快速排序演示 ===");
        
        // 测试1: 整数数组
        System.out.println("\n1. 排序整数数组:");
        Integer[] intArray = {5, 2, 8, 1, 9, 3};
        System.out.println("排序前: " + Arrays.toString(intArray));
        
        quickSort(intArray);
        System.out.println("排序后: " + Arrays.toString(intArray));
        
        // 测试2: 字符串数组
        System.out.println("\n2. 排序字符串数组:");
        String[] strArray = {"banana", "apple", "orange", "grape", "cherry"};
        System.out.println("排序前: " + Arrays.toString(strArray));
        
        quickSort(strArray);
        System.out.println("排序后: " + Arrays.toString(strArray));
        
        // 测试3: 自定义对象数组
        System.out.println("\n3. 排序学生对象（按分数）:");
        Student[] students = {
            new Student("Alice", 85, 20),
            new Student("Bob", 92, 19),
            new Student("Charlie", 78, 21),
            new Student("David", 90, 20)
        };
        
        System.out.println("排序前: " + Arrays.toString(students));
        quickSort(students);
        System.out.println("排序后: " + Arrays.toString(students));
        
        // 测试4: 使用自定义比较器
        System.out.println("\n4. 使用自定义比较器排序学生（按年龄）:");
        Student[] students2 = students.clone();
        Comparator<Student> ageComparator = Comparator.comparing(s -> s.age);
        
        System.out.println("排序前: " + Arrays.toString(students2));
        quickSort(students2, ageComparator);
        System.out.println("排序后: " + Arrays.toString(students2));
        
        // 测试5: 降序排序
        System.out.println("\n5. 降序排序整数数组:");
        Integer[] intArray2 = {5, 2, 8, 1, 9, 3};
        System.out.println("排序前: " + Arrays.toString(intArray2));
        
        Comparator<Integer> descendingComparator = Comparator.reverseOrder();
        quickSort(intArray2, descendingComparator);
        System.out.println("排序后: " + Arrays.toString(intArray2));
    }
}
```

## 快速排序的应用场景

### 1. 实际应用示例

```
import java.util.Arrays;

public class QuickSortApplications {
    
    /**
     * 快速选择算法：查找第k小的元素
     */
    public static int quickSelect(int[] arr, int k) {
        if (arr == null || k < 1 || k > arr.length) {
            throw new IllegalArgumentException("Invalid input");
        }
        
        return quickSelect(arr, 0, arr.length - 1, k - 1);
    }
    
    private static int quickSelect(int[] arr, int left, int right, int k) {
        if (left == right) {
            return arr[left];
        }
        
        int pivotIndex = partition(arr, left, right);
        
        if (k == pivotIndex) {
            return arr[k];
        } else if (k < pivotIndex) {
            return quickSelect(arr, left, pivotIndex - 1, k);
        } else {
            return quickSelect(arr, pivotIndex + 1, right, k);
        }
    }
    
    private static int partition(int[] arr, int left, int right) {
        int pivot = arr[right];
        int i = left - 1;
        
        for (int j = left; j < right; j++) {
            if (arr[j] <= pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        swap(arr, i + 1, right);
        return i + 1;
    }
    
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    /**
     * 查找数组中的中位数
     */
    public static double findMedian(int[] arr) {
        int n = arr.length;
        
        if (n % 2 == 1) {
            // 奇数个元素，中位数是第(n+1)/2小的元素
            return quickSelect(arr, (n + 1) / 2);
        } else {
            // 偶数个元素，中位数是第n/2小和第n/2+1小的元素的平均值
            int first = quickSelect(arr, n / 2);
            int second = quickSelect(arr, n / 2 + 1);
            return (first + second) / 2.0;
        }
    }
    
    /**
     * 荷兰国旗问题：三色排序
     * 将只包含0,1,2的数组排序
     */
    public static void dutchNationalFlag(int[] arr) {
        int low = 0;
        int mid = 0;
        int high = arr.length - 1;
        
        System.out.println("初始数组: " + Arrays.toString(arr));
        
        while (mid <= high) {
            if (arr[mid] == 0) {
                swap(arr, low, mid);
                System.out.println("  arr[" + mid + "]=0 → 交换到左边，low=" + (low+1));
                low++;
                mid++;
            } else if (arr[mid] == 1) {
                System.out.println("  arr[" + mid + "]=1 → 保持");
                mid++;
            } else { // arr[mid] == 2
                swap(arr, mid, high);
                System.out.println("  arr[" + mid + "]=2 → 交换到右边，high=" + (high-1));
                high--;
            }
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== 快速选择算法演示 ===");
        int[] arr = {3, 6, 8, 10, 1, 2, 1};
        System.out.println("数组: " + Arrays.toString(arr));
        
        int k = 4;
        int kthSmallest = quickSelect(arr.clone(), k);
        System.out.println("第" + k + "小的元素是: " + kthSmallest);
        
        System.out.println("\n=== 查找中位数演示 ===");
        int[] arr2 = {7, 3, 1, 9, 5, 4};
        System.out.println("数组: " + Arrays.toString(arr2));
        double median = findMedian(arr2.clone());
        System.out.println("中位数: " + median);
        
        System.out.println("\n=== 荷兰国旗问题演示 ===");
        int[] colors = {2, 0, 2, 1, 1, 0};
        System.out.println("排序前: " + Arrays.toString(colors));
        dutchNationalFlag(colors.clone());
        System.out.println("排序后: " + Arrays.toString(colors));
    }
}
```

## 总结

### 快速排序的优缺点

**优点：**

1. **平均性能优秀**：平均时间复杂度为O(n log n)，在实践中通常比其他O(n log n)算法更快
    
2. **原地排序**：只需要O(log n)的栈空间
    
3. **缓存友好**：访问模式是顺序的，能有效利用CPU缓存
    
4. **适应性强**：有多种优化策略应对不同场景
    

**缺点：**

1. **最坏情况性能差**：最坏情况下时间复杂度为O(n²)
    
2. **不稳定**：不保持相等元素的相对顺序
    
3. **递归深度**：在最坏情况下递归深度为O(n)，可能导致栈溢出
    
4. **基准选择敏感**：性能高度依赖于基准选择策略
    

### 与归并排序、堆排序的比较

|特性|快速排序|归并排序|堆排序|
|---|---|---|---|
|**时间复杂度**​|平均O(n log n)，最坏O(n²)|O(n log n)|O(n log n)|
|**空间复杂度**​|O(log n)~O(n)|O(n)|O(1)|
|**稳定性**​|不稳定|稳定|不稳定|
|**原地排序**​|是|否|是|
|**最佳适用场景**​|通用内部排序|外部排序、需要稳定性|内存有限、需要原地排序|
|**缓存友好性**​|好|一般|差|

### 使用建议

1. **通用排序**：快速排序通常是实践中最快的通用排序算法
    
2. **内存有限**：当内存是主要限制时，快速排序是好的选择
    
3. **随机数据**：对随机分布的数据表现优异
    
4. **避免最坏情况**：通过随机化或三数取中法避免已排序数组的最坏情况
    
5. **大量重复元素**：使用三路快速排序
    
6. **小数组**：可结合插入排序优化
    

### 优化技巧

1. **随机化基准**：避免最坏情况
    
2. **三数取中**：选择左、中、右三个元素的中位数作为基准
    
3. **小数组切换**：当子数组较小时切换到插入排序
    
4. **三路划分**：处理大量重复元素
    
5. **尾递归优化**：减少递归深度
    
6. **非递归实现**：使用栈模拟递归，避免栈溢出
    

### 学习价值

快速排序是理解**分治法**和**随机化算法**的经典案例，它展示了：

1. 如何通过划分将问题分解
    
2. 随机化在算法设计中的重要性
    
3. 如何通过优化常数因子提高实际性能
    
4. 递归算法的实现和优化
    
5. 算法的时间复杂度分析
    

快速排序不仅是重要的排序算法，其思想也广泛应用于选择算法、分治算法等领域。理解快速排序对于学习算法设计和分析具有重要意义。