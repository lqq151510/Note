# Java算法：选择排序

## 定义

**选择排序**（Selection Sort）是一种简单直观的排序算法。它的工作原理是：首先在未排序序列中找到最小（或最大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（或最大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

### 算法原理

1. 初始状态：整个数组分为已排序区（空）和未排序区（整个数组）
    
2. 在未排序区中找到最小（或最大）元素
    
3. 将其与未排序区的第一个元素交换位置
    
4. 将未排序区的第一个元素归入已排序区
    
5. 重复步骤2-4，直到未排序区为空
    

### 特点

|特性|描述|
|---|---|
|**时间复杂度**​|最好O(n²)，平均O(n²)，最坏O(n²)|
|**空间复杂度**​|O(1)|
|**稳定性**​|不稳定排序算法|
|**原地排序**​|是|
|**交换次数**​|最多n-1次交换|

## 算法可视化

```
初始数组: [64, 25, 12, 22, 11]

第1轮：在[64, 25, 12, 22, 11]中找到最小值11
交换11和64 → [11, 25, 12, 22, 64]

第2轮：在[25, 12, 22, 64]中找到最小值12
交换12和25 → [11, 12, 25, 22, 64]

第3轮：在[25, 22, 64]中找到最小值22
交换22和25 → [11, 12, 22, 25, 64]

第4轮：在[25, 64]中找到最小值25
交换25和25（无变化） → [11, 12, 22, 25, 64]

最终数组: [11, 12, 22, 25, 64]
```

## Java实现示例

### 1. 基础选择排序

```
import java.util.Arrays;

public class SelectionSort {
    
    /**
     * 基础选择排序（升序）
     * @param arr 待排序数组
     */
    public static void selectionSortBasic(int[] arr) {
        int n = arr.length;
        
        // 外层循环，控制排序的轮数
        for (int i = 0; i < n - 1; i++) {
            System.out.println("第 " + (i + 1) + " 轮:");
            System.out.println("  当前数组: " + Arrays.toString(arr));
            
            // 假设当前未排序部分的第一个元素是最小的
            int minIndex = i;
            
            // 在未排序部分中查找最小值的索引
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            
            System.out.println("  找到最小值: arr[" + minIndex + "] = " + arr[minIndex]);
            
            // 如果最小值不在正确位置，则交换
            if (minIndex != i) {
                int temp = arr[i];
                arr[i] = arr[minIndex];
                arr[minIndex] = temp;
                
                System.out.println("  交换 arr[" + i + "] 和 arr[" + minIndex + "]");
                System.out.println("  交换后数组: " + Arrays.toString(arr));
            } else {
                System.out.println("  最小值已在正确位置，无需交换");
            }
            System.out.println();
        }
    }
    
    /**
     * 选择排序（降序）
     */
    public static void selectionSortDescending(int[] arr) {
        int n = arr.length;
        
        for (int i = 0; i < n - 1; i++) {
            int maxIndex = i;  // 假设当前元素是最大的
            
            for (int j = i + 1; j < n; j++) {
                if (arr[j] > arr[maxIndex]) {
                    maxIndex = j;
                }
            }
            
            if (maxIndex != i) {
                int temp = arr[i];
                arr[i] = arr[maxIndex];
                arr[maxIndex] = temp;
            }
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {64, 25, 12, 22, 11};
        
        System.out.println("=== 基础选择排序演示（升序）===");
        System.out.println("原始数组: " + Arrays.toString(arr));
        System.out.println();
        
        int[] arrCopy = arr.clone();
        selectionSortBasic(arrCopy);
        
        System.out.println("排序结果: " + Arrays.toString(arrCopy));
        
        // 测试降序排序
        System.out.println("\n=== 选择排序演示（降序）===");
        int[] arr2 = {5, 3, 8, 1, 2};
        System.out.println("原始数组: " + Arrays.toString(arr2));
        
        selectionSortDescending(arr2);
        System.out.println("排序结果: " + Arrays.toString(arr2));
    }
}
```

### 2. 带统计信息的选择排序

```
import java.util.Arrays;

public class SelectionSortWithStats {
    
    /**
     * 带统计信息的选择排序
     */
    public static class SortStats {
        int comparisons;  // 比较次数
        int swaps;        // 交换次数
        int iterations;   // 迭代轮数
        long time;        // 耗时（纳秒）
        
        @Override
        public String toString() {
            return String.format("比较次数: %d, 交换次数: %d, 迭代轮数: %d, 耗时: %d ns", 
                                comparisons, swaps, iterations, time);
        }
    }
    
    /**
     * 选择排序（带统计）
     */
    public static SortStats selectionSortWithStats(int[] arr) {
        int[] arrCopy = arr.clone();
        int n = arrCopy.length;
        SortStats stats = new SortStats();
        
        long startTime = System.nanoTime();
        
        stats.iterations = n - 1;
        
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            
            // 查找最小值的索引
            for (int j = i + 1; j < n; j++) {
                stats.comparisons++;
                if (arrCopy[j] < arrCopy[minIndex]) {
                    minIndex = j;
                }
            }
            
            // 交换元素
            if (minIndex != i) {
                stats.swaps++;
                int temp = arrCopy[i];
                arrCopy[i] = arrCopy[minIndex];
                arrCopy[minIndex] = temp;
            }
        }
        
        long endTime = System.nanoTime();
        stats.time = endTime - startTime;
        
        return stats;
    }
    
    /**
     * 优化选择排序：同时找到最小值和最大值
     */
    public static SortStats optimizedSelectionSort(int[] arr) {
        int[] arrCopy = arr.clone();
        int n = arrCopy.length;
        SortStats stats = new SortStats();
        
        long startTime = System.nanoTime();
        
        for (int i = 0; i < n / 2; i++) {
            stats.iterations++;
            
            int minIndex = i;
            int maxIndex = i;
            
            // 在未排序部分中查找最小值和最大值
            for (int j = i; j < n - i; j++) {
                stats.comparisons++;
                if (arrCopy[j] < arrCopy[minIndex]) {
                    minIndex = j;
                }
                if (arrCopy[j] > arrCopy[maxIndex]) {
                    maxIndex = j;
                }
            }
            
            // 将最小值放到前面
            if (minIndex != i) {
                stats.swaps++;
                int temp = arrCopy[i];
                arrCopy[i] = arrCopy[minIndex];
                arrCopy[minIndex] = temp;
            }
            
            // 如果最大值的位置被移动了，更新maxIndex
            if (maxIndex == i) {
                maxIndex = minIndex;
            }
            
            // 将最大值放到后面
            int lastIndex = n - 1 - i;
            if (maxIndex != lastIndex) {
                stats.swaps++;
                int temp = arrCopy[lastIndex];
                arrCopy[lastIndex] = arrCopy[maxIndex];
                arrCopy[maxIndex] = temp;
            }
        }
        
        long endTime = System.nanoTime();
        stats.time = endTime - startTime;
        
        return stats;
    }
    
    /**
     * 可视化选择排序过程
     */
    public static void visualizeSelectionSort(int[] arr) {
        int[] arrCopy = arr.clone();
        int n = arrCopy.length;
        
        System.out.println("=== 选择排序可视化 ===");
        System.out.println("原始数组: " + Arrays.toString(arrCopy));
        System.out.println();
        
        for (int i = 0; i < n - 1; i++) {
            System.out.println("第 " + (i + 1) + " 轮:");
            
            // 显示当前数组状态
            System.out.print("  当前: [");
            for (int k = 0; k < n; k++) {
                if (k < i) {
                    System.out.print("(" + arrCopy[k] + ") ");  // 已排序部分
                } else if (k == i) {
                    System.out.print("[" + arrCopy[k] + "] ");  // 当前位置
                } else {
                    System.out.print(arrCopy[k] + " ");  // 未排序部分
                }
            }
            System.out.println("]");
            
            // 查找最小值的索引
            int minIndex = i;
            for (int j = i + 1; j < n; j++) {
                if (arrCopy[j] < arrCopy[minIndex]) {
                    minIndex = j;
                }
            }
            
            System.out.println("  找到最小值: arr[" + minIndex + "] = " + arrCopy[minIndex]);
            
            // 交换
            if (minIndex != i) {
                int temp = arrCopy[i];
                arrCopy[i] = arrCopy[minIndex];
                arrCopy[minIndex] = temp;
                
                System.out.println("  交换 arr[" + i + "] 和 arr[" + minIndex + "]");
                System.out.println("  交换后: " + Arrays.toString(arrCopy));
            } else {
                System.out.println("  最小值已在正确位置");
            }
            System.out.println();
        }
        
        System.out.println("最终排序结果: " + Arrays.toString(arrCopy));
    }
    
    public static void main(String[] args) {
        int[] arr = {64, 25, 12, 22, 11};
        
        // 可视化演示
        visualizeSelectionSort(arr);
        
        System.out.println("\n" + "=".repeat(50) + "\n");
        
        // 测试不同版本的选择排序
        int[] testArray = {29, 10, 14, 37, 13};
        System.out.println("测试数组: " + Arrays.toString(testArray));
        
        System.out.println("\n1. 基础选择排序统计:");
        SortStats basicStats = selectionSortWithStats(testArray);
        System.out.println(basicStats);
        
        System.out.println("\n2. 优化选择排序（同时找最小和最大）统计:");
        SortStats optimizedStats = optimizedSelectionSort(testArray);
        System.out.println(optimizedStats);
        
        // 性能比较
        System.out.println("\n性能比较:");
        System.out.println("比较次数减少: " + (basicStats.comparisons - optimizedStats.comparisons));
        System.out.println("交换次数增加: " + (optimizedStats.swaps - basicStats.swaps));
        System.out.println("时间差异: " + (basicStats.time - optimizedStats.time) + " ns");
    }
}
```

### 3. 泛型选择排序

```
import java.util.Arrays;
import java.util.Comparator;

public class GenericSelectionSort {
    
    /**
     * 泛型选择排序（升序，使用Comparable接口）
     */
    public static <T extends Comparable<T>> void selectionSortGeneric(T[] arr) {
        int n = arr.length;
        
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            
            // 在未排序部分中查找最小元素的索引
            for (int j = i + 1; j < n; j++) {
                if (arr[j].compareTo(arr[minIndex]) < 0) {
                    minIndex = j;
                }
            }
            
            // 交换元素
            if (minIndex != i) {
                T temp = arr[i];
                arr[i] = arr[minIndex];
                arr[minIndex] = temp;
            }
        }
    }
    
    /**
     * 泛型选择排序（使用Comparator比较器）
     */
    public static <T> void selectionSortGeneric(T[] arr, Comparator<T> comparator) {
        int n = arr.length;
        
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            
            for (int j = i + 1; j < n; j++) {
                if (comparator.compare(arr[j], arr[minIndex]) < 0) {
                    minIndex = j;
                }
            }
            
            if (minIndex != i) {
                T temp = arr[i];
                arr[i] = arr[minIndex];
                arr[minIndex] = temp;
            }
        }
    }
    
    /**
     * 学生类，用于演示
     */
    static class Student implements Comparable<Student> {
        String name;
        int score;
        
        Student(String name, int score) {
            this.name = name;
            this.score = score;
        }
        
        @Override
        public int compareTo(Student other) {
            return Integer.compare(this.score, other.score);
        }
        
        @Override
        public String toString() {
            return name + "(" + score + ")";
        }
    }
    
    /**
     * 产品类
     */
    static class Product {
        String name;
        double price;
        int quantity;
        
        Product(String name, double price, int quantity) {
            this.name = name;
            this.price = price;
            this.quantity = quantity;
        }
        
        @Override
        public String toString() {
            return String.format("%s($%.2f, qty:%d)", name, price, quantity);
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== 泛型选择排序演示 ===");
        
        // 测试1: 整数数组
        System.out.println("\n1. 排序整数数组:");
        Integer[] intArray = {5, 2, 8, 1, 9, 3};
        System.out.println("排序前: " + Arrays.toString(intArray));
        
        selectionSortGeneric(intArray);
        System.out.println("排序后: " + Arrays.toString(intArray));
        
        // 测试2: 字符串数组
        System.out.println("\n2. 排序字符串数组:");
        String[] strArray = {"banana", "apple", "orange", "grape", "cherry"};
        System.out.println("排序前: " + Arrays.toString(strArray));
        
        selectionSortGeneric(strArray);
        System.out.println("排序后: " + Arrays.toString(strArray));
        
        // 测试3: 自定义对象数组（使用Comparable接口）
        System.out.println("\n3. 排序学生对象（按分数）:");
        Student[] students = {
            new Student("Alice", 85),
            new Student("Bob", 92),
            new Student("Charlie", 78),
            new Student("David", 90)
        };
        
        System.out.println("排序前: " + Arrays.toString(students));
        selectionSortGeneric(students);
        System.out.println("排序后: " + Arrays.toString(students));
        
        // 测试4: 使用自定义比较器
        System.out.println("\n4. 使用自定义比较器排序产品:");
        Product[] products = {
            new Product("Laptop", 999.99, 10),
            new Product("Phone", 699.99, 25),
            new Product("Tablet", 399.99, 15),
            new Product("Monitor", 299.99, 30)
        };
        
        System.out.println("排序前: " + Arrays.toString(products));
        
        // 按价格排序
        Comparator<Product> priceComparator = Comparator.comparing(p -> p.price);
        selectionSortGeneric(products, priceComparator);
        System.out.println("按价格排序: " + Arrays.toString(products));
        
        // 按数量排序
        Comparator<Product> quantityComparator = Comparator.comparing(p -> p.quantity);
        selectionSortGeneric(products, quantityComparator);
        System.out.println("按数量排序: " + Arrays.toString(products));
        
        // 测试5: 降序排序
        System.out.println("\n5. 降序排序整数数组:");
        Integer[] intArray2 = {5, 2, 8, 1, 9, 3};
        System.out.println("排序前: " + Arrays.toString(intArray2));
        
        selectionSortGeneric(intArray2, Comparator.reverseOrder());
        System.out.println("排序后: " + Arrays.toString(intArray2));
    }
}
```

### 4. 选择排序性能分析

```
import java.util.Arrays;
import java.util.Random;

public class SelectionSortPerformance {
    
    /**
     * 生成随机数组
     */
    public static int[] generateRandomArray(int size, int maxValue) {
        int[] arr = new int[size];
        Random random = new Random();
        
        for (int i = 0; i < size; i++) {
            arr[i] = random.nextInt(maxValue);
        }
        
        return arr;
    }
    
    /**
     * 生成几乎有序的数组
     */
    public static int[] generateNearlySortedArray(int size) {
        int[] arr = new int[size];
        
        for (int i = 0; i < size; i++) {
            arr[i] = i;
        }
        
        // 随机交换几对元素
        Random random = new Random();
        int swaps = size / 10;  // 交换10%的元素
        
        for (int i = 0; i < swaps; i++) {
            int index1 = random.nextInt(size);
            int index2 = random.nextInt(size);
            
            int temp = arr[index1];
            arr[index1] = arr[index2];
            arr[index2] = temp;
        }
        
        return arr;
    }
    
    /**
     * 生成逆序数组
     */
    public static int[] generateReverseArray(int size) {
        int[] arr = new int[size];
        
        for (int i = 0; i < size; i++) {
            arr[i] = size - i;
        }
        
        return arr;
    }
    
    /**
     * 生成相同元素数组
     */
    public static int[] generateSameArray(int size, int value) {
        int[] arr = new int[size];
        Arrays.fill(arr, value);
        return arr;
    }
    
    /**
     * 性能测试
     */
    public static void performanceTest() {
        System.out.println("=== 选择排序性能测试 ===");
        System.out.println("数组大小: 1000");
        
        // 测试不同情况的数组
        String[] testCases = {"随机数组", "几乎有序数组", "完全逆序数组", "相同元素数组"};
        int[][] testArrays = new int[4][1000];
        
        testArrays[0] = generateRandomArray(1000, 10000);
        testArrays[1] = generateNearlySortedArray(1000);
        testArrays[2] = generateReverseArray(1000);
        testArrays[3] = generateSameArray(1000, 5);
        
        System.out.printf("%-20s %-15s %-15s %-15s%n", 
                         "测试用例", "比较次数", "交换次数", "耗时(ms)");
        System.out.println("-".repeat(65));
        
        for (int i = 0; i < 4; i++) {
            int[] arrCopy = testArrays[i].clone();
            
            long startTime = System.nanoTime();
            
            int comparisons = 0;
            int swaps = 0;
            int n = arrCopy.length;
            
            for (int j = 0; j < n - 1; j++) {
                int minIndex = j;
                
                for (int k = j + 1; k < n; k++) {
                    comparisons++;
                    if (arrCopy[k] < arrCopy[minIndex]) {
                        minIndex = k;
                    }
                }
                
                if (minIndex != j) {
                    swaps++;
                    int temp = arrCopy[j];
                    arrCopy[j] = arrCopy[minIndex];
                    arrCopy[minIndex] = temp;
                }
            }
            
            long endTime = System.nanoTime();
            long duration = (endTime - startTime) / 1_000_000;  // 转换为毫秒
            
            System.out.printf("%-20s %-15d %-15d %-15d%n", 
                             testCases[i], comparisons, swaps, duration);
        }
    }
    
    /**
     * 与冒泡排序性能比较
     */
    public static void compareWithBubbleSort() {
        System.out.println("\n=== 选择排序 vs 冒泡排序 ===");
        System.out.println("数组大小: 1000");
        
        int[] randomArray = generateRandomArray(1000, 10000);
        
        // 选择排序
        long startTime = System.nanoTime();
        int[] selectionSorted = selectionSort(randomArray.clone());
        long selectionTime = System.nanoTime() - startTime;
        
        // 冒泡排序
        startTime = System.nanoTime();
        int[] bubbleSorted = bubbleSort(randomArray.clone());
        long bubbleTime = System.nanoTime() - startTime;
        
        // 验证排序结果是否相同
        boolean sameResult = Arrays.equals(selectionSorted, bubbleSorted);
        
        System.out.println("选择排序用时: " + selectionTime / 1_000_000 + " ms");
        System.out.println("冒泡排序用时: " + bubbleTime / 1_000_000 + " ms");
        System.out.println("排序结果相同: " + sameResult);
        System.out.println("性能差异: " + (bubbleTime - selectionTime) / 1_000_000 + " ms");
        
        if (selectionTime < bubbleTime) {
            System.out.println("选择排序更快，快 " + 
                String.format("%.1f", (double)(bubbleTime - selectionTime) / selectionTime * 100) + "%");
        } else {
            System.out.println("冒泡排序更快，快 " + 
                String.format("%.1f", (double)(selectionTime - bubbleTime) / bubbleTime * 100) + "%");
        }
    }
    
    /**
     * 选择排序实现
     */
    public static int[] selectionSort(int[] arr) {
        int[] arrCopy = arr.clone();
        int n = arrCopy.length;
        
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            
            for (int j = i + 1; j < n; j++) {
                if (arrCopy[j] < arrCopy[minIndex]) {
                    minIndex = j;
                }
            }
            
            if (minIndex != i) {
                int temp = arrCopy[i];
                arrCopy[i] = arrCopy[minIndex];
                arrCopy[minIndex] = temp;
            }
        }
        
        return arrCopy;
    }
    
    /**
     * 冒泡排序实现
     */
    public static int[] bubbleSort(int[] arr) {
        int[] arrCopy = arr.clone();
        int n = arrCopy.length;
        boolean swapped;
        
        for (int i = 0; i < n - 1; i++) {
            swapped = false;
            
            for (int j = 0; j < n - 1 - i; j++) {
                if (arrCopy[j] > arrCopy[j + 1]) {
                    int temp = arrCopy[j];
                    arrCopy[j] = arrCopy[j + 1];
                    arrCopy[j + 1] = temp;
                    swapped = true;
                }
            }
            
            if (!swapped) {
                break;
            }
        }
        
        return arrCopy;
    }
    
    /**
     * 不同数组大小的性能测试
     */
    public static void testDifferentSizes() {
        System.out.println("\n=== 不同数组大小的性能测试 ===");
        
        int[] sizes = {100, 500, 1000, 5000, 10000};
        
        System.out.printf("%-10s %-15s %-15s%n", "数组大小", "选择排序(ms)", "冒泡排序(ms)");
        System.out.println("-".repeat(40));
        
        for (int size : sizes) {
            int[] arr = generateRandomArray(size, 10000);
            
            // 选择排序
            long startTime = System.nanoTime();
            selectionSort(arr.clone());
            long selectionTime = (System.nanoTime() - startTime) / 1_000_000;
            
            // 冒泡排序
            startTime = System.nanoTime();
            bubbleSort(arr.clone());
            long bubbleTime = (System.nanoTime() - startTime) / 1_000_000;
            
            System.out.printf("%-10d %-15d %-15d%n", size, selectionTime, bubbleTime);
        }
    }
    
    public static void main(String[] args) {
        // 性能测试
        performanceTest();
        
        // 与冒泡排序比较
        compareWithBubbleSort();
        
        // 不同大小测试
        testDifferentSizes();
    }
}
```

### 5. 选择排序的变体

```
import java.util.Arrays;

public class SelectionSortVariants {
    
    /**
     * 双向选择排序（同时找最小和最大）
     */
    public static void bidirectionalSelectionSort(int[] arr) {
        int n = arr.length;
        int left = 0;
        int right = n - 1;
        
        System.out.println("=== 双向选择排序 ===");
        System.out.println("原始数组: " + Arrays.toString(arr));
        System.out.println();
        
        while (left < right) {
            int minIndex = left;
            int maxIndex = left;
            
            // 在未排序部分中查找最小值和最大值
            for (int i = left; i <= right; i++) {
                if (arr[i] < arr[minIndex]) {
                    minIndex = i;
                }
                if (arr[i] > arr[maxIndex]) {
                    maxIndex = i;
                }
            }
            
            System.out.println("当前范围: [" + left + ", " + right + "]");
            System.out.println("最小值: arr[" + minIndex + "] = " + arr[minIndex]);
            System.out.println("最大值: arr[" + maxIndex + "] = " + arr[maxIndex]);
            
            // 将最小值放到前面
            if (minIndex != left) {
                int temp = arr[left];
                arr[left] = arr[minIndex];
                arr[minIndex] = temp;
                System.out.println("交换最小值: arr[" + left + "] ↔ arr[" + minIndex + "]");
            }
            
            // 如果最大值的位置被移动了，更新maxIndex
            if (maxIndex == left) {
                maxIndex = minIndex;
            }
            
            // 将最大值放到后面
            if (maxIndex != right) {
                int temp = arr[right];
                arr[right] = arr[maxIndex];
                arr[maxIndex] = temp;
                System.out.println("交换最大值: arr[" + right + "] ↔ arr[" + maxIndex + "]");
            }
            
            System.out.println("当前数组: " + Arrays.toString(arr));
            System.out.println();
            
            // 缩小范围
            left++;
            right--;
        }
    }
    
    /**
     * 递归选择排序
     */
    public static void recursiveSelectionSort(int[] arr) {
        recursiveSelectionSort(arr, 0, arr.length - 1);
    }
    
    private static void recursiveSelectionSort(int[] arr, int start, int end) {
        if (start >= end) {
            return;
        }
        
        int minIndex = findMinIndex(arr, start, end);
        
        if (minIndex != start) {
            int temp = arr[start];
            arr[start] = arr[minIndex];
            arr[minIndex] = temp;
        }
        
        recursiveSelectionSort(arr, start + 1, end);
    }
    
    private static int findMinIndex(int[] arr, int start, int end) {
        if (start == end) {
            return start;
        }
        
        int minIndexOfRest = findMinIndex(arr, start + 1, end);
        return (arr[start] < arr[minIndexOfRest]) ? start : minIndexOfRest;
    }
    
    /**
     * 稳定选择排序
     * 通过插入而不是交换来保持稳定性
     */
    public static void stableSelectionSort(int[] arr) {
        int n = arr.length;
        
        System.out.println("=== 稳定选择排序 ===");
        System.out.println("原始数组: " + Arrays.toString(arr));
        System.out.println();
        
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            
            // 找到最小值的索引
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            
            // 将最小值插入到当前位置，而不是交换
            int minValue = arr[minIndex];
            
            // 向右移动元素
            for (int k = minIndex; k > i; k--) {
                arr[k] = arr[k - 1];
            }
            
            arr[i] = minValue;
            
            System.out.println("第 " + (i + 1) + " 轮:");
            System.out.println("  找到最小值: " + minValue);
            System.out.println("  当前数组: " + Arrays.toString(arr));
        }
    }
    
    /**
     * 选择排序优化：减少交换次数
     * 只记录最小值的索引，不进行中间交换
     */
    public static void selectionSortWithMinSwaps(int[] arr) {
        int n = arr.length;
        int swapCount = 0;
        
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            
            // 只有当最小值不在正确位置时才交换
            if (minIndex != i) {
                int temp = arr[i];
                arr[i] = arr[minIndex];
                arr[minIndex] = temp;
                swapCount++;
            }
        }
        
        System.out.println("交换次数: " + swapCount);
    }
    
    public static void main(String[] args) {
        // 测试双向选择排序
        System.out.println("测试1: 双向选择排序");
        int[] arr1 = {64, 25, 12, 22, 11};
        bidirectionalSelectionSort(arr1.clone());
        
        System.out.println("\n" + "=".repeat(50) + "\n");
        
        // 测试递归选择排序
        System.out.println("测试2: 递归选择排序");
        int[] arr2 = {29, 10, 14, 37, 13};
        System.out.println("原始数组: " + Arrays.toString(arr2));
        
        int[] arr2Copy = arr2.clone();
        recursiveSelectionSort(arr2Copy);
        System.out.println("排序后: " + Arrays.toString(arr2Copy));
        
        System.out.println("\n" + "=".repeat(50) + "\n");
        
        // 测试稳定选择排序
        System.out.println("测试3: 稳定选择排序");
        int[] arr3 = {4, 5, 3, 4, 2, 1};  // 有重复元素
        stableSelectionSort(arr3.clone());
        
        System.out.println("\n" + "=".repeat(50) + "\n");
        
        // 测试减少交换的版本
        System.out.println("测试4: 减少交换次数的选择排序");
        int[] arr4 = {5, 1, 4, 2, 8};
        System.out.println("原始数组: " + Arrays.toString(arr4));
        
        int[] arr4Copy = arr4.clone();
        selectionSortWithMinSwaps(arr4Copy);
        System.out.println("排序后: " + Arrays.toString(arr4Copy));
    }
}
```

## 选择排序的应用场景

### 1. 简单数据排序

```
public class SimpleDataSorting {
    public static void main(String[] args) {
        // 小规模数据排序
        int[] scores = {85, 92, 78, 90, 88};
        SelectionSort.selectionSortBasic(scores);
        System.out.println("学生成绩排序: " + Arrays.toString(scores));
        
        // 选择前k个最小/最大元素
        int[] numbers = {7, 10, 4, 3, 20, 15};
        int k = 3;
        int[] result = findKSmallest(numbers, k);
        System.out.println("前" + k + "个最小元素: " + Arrays.toString(result));
    }
    
    /**
     * 使用选择排序思想找到前k个最小元素
     */
    public static int[] findKSmallest(int[] arr, int k) {
        int[] result = new int[k];
        int[] arrCopy = arr.clone();
        
        for (int i = 0; i < k; i++) {
            int minIndex = i;
            
            for (int j = i + 1; j < arrCopy.length; j++) {
                if (arrCopy[j] < arrCopy[minIndex]) {
                    minIndex = j;
                }
            }
            
            result[i] = arrCopy[minIndex];
            
            // 将找到的最小值移到前面
            if (minIndex != i) {
                int temp = arrCopy[i];
                arrCopy[i] = arrCopy[minIndex];
                arrCopy[minIndex] = temp;
            }
        }
        
        return result;
    }
}
```

### 2. 实际应用示例

```
import java.util.Arrays;

public class PracticalExamples {
    
    /**
     * 学生成绩管理系统
     */
    static class StudentManagement {
        static class Student {
            String id;
            String name;
            int score;
            
            Student(String id, String name, int score) {
                this.id = id;
                this.name = name;
                this.score = score;
            }
            
            @Override
            public String toString() {
                return String.format("学号: %s, 姓名: %s, 成绩: %d", id, name, score);
            }
        }
        
        public static void sortStudentsByScore(Student[] students) {
            int n = students.length;
            
            for (int i = 0; i < n - 1; i++) {
                int maxIndex = i;  // 找最高分
                
                for (int j = i + 1; j < n; j++) {
                    if (students[j].score > students[maxIndex].score) {
                        maxIndex = j;
                    }
                }
                
                if (maxIndex != i) {
                    Student temp = students[i];
                    students[i] = students[maxIndex];
                    students[maxIndex] = temp;
                }
            }
        }
    }
    
    /**
     * 商品排序
     */
    static class ProductSorter {
        static class Product {
            String name;
            double price;
            int stock;
            
            Product(String name, double price, int stock) {
                this.name = name;
                this.price = price;
                this.stock = stock;
            }
            
            @Override
            public String toString() {
                return String.format("%-15s 价格: $%-8.2f 库存: %d", name, price, stock);
            }
        }
        
        public static void sortProductsByPrice(Product[] products) {
            int n = products.length;
            
            for (int i = 0; i < n - 1; i++) {
                int minIndex = i;
                
                for (int j = i + 1; j < n; j++) {
                    if (products[j].price < products[minIndex].price) {
                        minIndex = j;
                    }
                }
                
                if (minIndex != i) {
                    Product temp = products[i];
                    products[i] = products[minIndex];
                    products[minIndex] = temp;
                }
            }
        }
        
        public static void sortProductsByStock(Product[] products) {
            int n = products.length;
            
            for (int i = 0; i < n - 1; i++) {
                int maxIndex = i;
                
                for (int j = i + 1; j < n; j++) {
                    if (products[j].stock > products[maxIndex].stock) {
                        maxIndex = j;
                    }
                }
                
                if (maxIndex != i) {
                    Product temp = products[i];
                    products[i] = products[maxIndex];
                    products[maxIndex] = temp;
                }
            }
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== 学生成绩排序 ===");
        StudentManagement.Student[] students = {
            new StudentManagement.Student("S001", "张三", 85),
            new StudentManagement.Student("S002", "李四", 92),
            new StudentManagement.Student("S003", "王五", 78),
            new StudentManagement.Student("S004", "赵六", 90)
        };
        
        System.out.println("排序前:");
        for (StudentManagement.Student s : students) {
            System.out.println("  " + s);
        }
        
        StudentManagement.sortStudentsByScore(students);
        
        System.out.println("\n按成绩降序排序后:");
        for (StudentManagement.Student s : students) {
            System.out.println("  " + s);
        }
        
        System.out.println("\n=== 商品排序 ===");
        ProductSorter.Product[] products = {
            new ProductSorter.Product("笔记本电脑", 999.99, 10),
            new ProductSorter.Product("智能手机", 699.99, 25),
            new ProductSorter.Product("平板电脑", 399.99, 15),
            new ProductSorter.Product("显示器", 299.99, 30)
        };
        
        System.out.println("\n按价格升序排序:");
        ProductSorter.Product[] productsByPrice = products.clone();
        ProductSorter.sortProductsByPrice(productsByPrice);
        for (ProductSorter.Product p : productsByPrice) {
            System.out.println("  " + p);
        }
        
        System.out.println("\n按库存降序排序:");
        ProductSorter.Product[] productsByStock = products.clone();
        ProductSorter.sortProductsByStock(productsByStock);
        for (ProductSorter.Product p : productsByStock) {
            System.out.println("  " + p);
        }
    }
}
```

## 总结

### 选择排序的优缺点

**优点：**

1. **简单直观**：算法思想简单，容易理解和实现
    
2. **原地排序**：只需要O(1)的额外空间
    
3. **交换次数少**：最多进行n-1次交换
    
4. **对数据的有序性不敏感**：无论输入数据如何，比较次数总是相同的
    

**缺点：**

1. **时间复杂度高**：总是O(n²)，效率较低
    
2. **不稳定**：默认实现是不稳定的（但可以通过额外操作实现稳定版本）
    
3. **不适用于大规模数据**：当数据量较大时性能很差
    

### 与冒泡排序的比较

|特性|选择排序|冒泡排序|
|---|---|---|
|**时间复杂度**​|总是O(n²)|最好O(n)，最坏O(n²)|
|**比较次数**​|总是n(n-1)/2|最好n-1，最坏n(n-1)/2|
|**交换次数**​|最多n-1|最多n(n-1)/2|
|**稳定性**​|不稳定|稳定|
|**性能**​|通常比冒泡排序快|通常比选择排序慢|
|**适用场景**​|交换成本高的场景|小规模或几乎有序的数据|

### 使用建议

1. **教学目的**：非常适合用于算法教学
    
2. **小规模数据**：当n ≤ 50时性能尚可接受
    
3. **交换成本高**：当交换操作的成本远高于比较操作时
    
4. **内存有限**：不需要额外内存空间
    
5. **不需要稳定性**：当不需要保持相等元素的相对顺序时
    

### 学习价值

选择排序是理解排序算法的基础，通过学习选择排序，我们可以掌握：

1. 排序算法的基本思想
    
2. 时间和空间复杂度的概念
    
3. 算法稳定性的重要性
    
4. 如何通过优化改进算法性能
    
5. 为学习更复杂的排序算法（如堆排序）打下基础
    

尽管在实际应用中很少使用选择排序，但理解其原理对于计算机科学的学习至关重要。