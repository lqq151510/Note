# Java算法：冒泡排序

## 定义

**冒泡排序**（Bubble Sort）是一种简单的排序算法，它重复地遍历要排序的数列，一次比较两个相邻元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复地进行直到没有再需要交换的元素，也就是说该数列已经排序完成。

### 算法原理

1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个
    
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对
    
3. 在这一点，最后的元素应该会是最大的数
    
4. 针对所有的元素重复以上的步骤，除了最后一个
    
5. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较
    

### 特点

|特性|描述|
|---|---|
|**时间复杂度**​|最好O(n)，平均O(n²)，最坏O(n²)|
|**空间复杂度**​|O(1)|
|**稳定性**​|稳定排序算法|
|**原地排序**​|是|
|**自适应**​|是（优化版本）|

## 算法可视化

```
初始数组: [5, 3, 8, 1, 2]

第一轮遍历：
[5, 3, 8, 1, 2] → 5>3, 交换 → [3, 5, 8, 1, 2]
[3, 5, 8, 1, 2] → 5<8, 不交换 → [3, 5, 8, 1, 2]
[3, 5, 8, 1, 2] → 8>1, 交换 → [3, 5, 1, 8, 2]
[3, 5, 1, 8, 2] → 8>2, 交换 → [3, 5, 1, 2, 8]

第二轮遍历：
[3, 5, 1, 2, 8] → 3<5, 不交换 → [3, 5, 1, 2, 8]
[3, 5, 1, 2, 8] → 5>1, 交换 → [3, 1, 5, 2, 8]
[3, 1, 5, 2, 8] → 5>2, 交换 → [3, 1, 2, 5, 8]

第三轮遍历：
[3, 1, 2, 5, 8] → 3>1, 交换 → [1, 3, 2, 5, 8]
[1, 3, 2, 5, 8] → 3>2, 交换 → [1, 2, 3, 5, 8]

第四轮遍历：
[1, 2, 3, 5, 8] → 已排序，无需交换
```

## Java实现示例

### 1. 基础冒泡排序

```
import java.util.Arrays;

public class BubbleSort {
    
    /**
     * 基础冒泡排序
     * @param arr 待排序数组
     */
    public static void bubbleSortBasic(int[] arr) {
        int n = arr.length;
        
        // 外层循环控制遍历轮数
        for (int i = 0; i < n - 1; i++) {
            System.out.println("第 " + (i + 1) + " 轮:");
            
            // 内层循环进行相邻元素比较
            for (int j = 0; j < n - 1 - i; j++) {
                // 如果前一个元素大于后一个元素，则交换
                if (arr[j] > arr[j + 1]) {
                    // 交换元素
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    
                    System.out.println("  交换 " + arr[j+1] + " 和 " + arr[j] + 
                                     " → " + Arrays.toString(arr));
                } else {
                    System.out.println("  比较 " + arr[j] + " 和 " + arr[j+1] + 
                                     " → 不交换");
                }
            }
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {5, 3, 8, 1, 2};
        
        System.out.println("=== 基础冒泡排序演示 ===");
        System.out.println("原始数组: " + Arrays.toString(arr));
        System.out.println();
        
        int[] arrCopy = arr.clone();
        bubbleSortBasic(arrCopy);
        
        System.out.println("\n排序结果: " + Arrays.toString(arrCopy));
    }
}
```

### 2. 优化版本1：添加提前终止标志

```
import java.util.Arrays;

public class BubbleSortOptimized1 {
    
    /**
     * 优化版冒泡排序：添加提前终止标志
     * 如果某一轮遍历中没有发生交换，说明数组已经有序，可以提前终止
     */
    public static void bubbleSortWithFlag(int[] arr) {
        int n = arr.length;
        boolean swapped;  // 交换标志
        
        for (int i = 0; i < n - 1; i++) {
            swapped = false;
            System.out.println("第 " + (i + 1) + " 轮:");
            
            for (int j = 0; j < n - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    // 交换元素
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true;
                    
                    System.out.println("  交换 " + arr[j+1] + " 和 " + arr[j] + 
                                     " → " + Arrays.toString(arr));
                }
            }
            
            // 如果这一轮没有发生交换，说明数组已经有序
            if (!swapped) {
                System.out.println("  本轮无交换，数组已有序，提前终止");
                break;
            }
        }
    }
    
    public static void main(String[] args) {
        int[] arr1 = {5, 3, 8, 1, 2};
        int[] arr2 = {1, 2, 3, 4, 5};  // 已排序的数组
        
        System.out.println("=== 优化冒泡排序（有提前终止）演示 ===");
        
        System.out.println("\n测试1: 无序数组");
        System.out.println("原始数组: " + Arrays.toString(arr1));
        bubbleSortWithFlag(arr1.clone());
        
        System.out.println("\n测试2: 已排序数组");
        System.out.println("原始数组: " + Arrays.toString(arr2));
        bubbleSortWithFlag(arr2.clone());
    }
}
```

### 3. 优化版本2：记录最后交换位置

```
import java.util.Arrays;

public class BubbleSortOptimized2 {
    
    /**
     * 优化版冒泡排序：记录最后交换位置
     * 记录最后一次交换发生的位置，这个位置之后的元素已经有序
     */
    public static void bubbleSortWithLastSwap(int[] arr) {
        int n = arr.length;
        int lastSwapIndex = n - 1;  // 初始值为最后一个位置
        int currentSwapIndex;
        
        int iteration = 0;
        
        while (lastSwapIndex > 0) {
            iteration++;
            currentSwapIndex = 0;
            System.out.println("第 " + iteration + " 轮遍历:");
            System.out.println("  本轮遍历范围: 索引 0 到 " + lastSwapIndex);
            
            for (int j = 0; j < lastSwapIndex; j++) {
                if (arr[j] > arr[j + 1]) {
                    // 交换元素
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    currentSwapIndex = j;  // 记录最后一次交换的位置
                    
                    System.out.println("    交换 " + arr[j+1] + " 和 " + arr[j] + 
                                     " (索引 " + j + " 和 " + (j+1) + ")");
                }
            }
            
            // 如果currentSwapIndex为0，说明没有发生交换
            if (currentSwapIndex == 0 && arr[0] <= arr[1]) {
                System.out.println("  没有发生交换，数组已有序，提前终止");
                break;
            }
            
            lastSwapIndex = currentSwapIndex;
            System.out.println("  最后交换位置: 索引 " + lastSwapIndex);
            System.out.println("  当前数组状态: " + Arrays.toString(arr));
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {5, 3, 8, 1, 2, 9, 4, 7, 6};
        
        System.out.println("=== 优化冒泡排序（记录最后交换位置）演示 ===");
        System.out.println("原始数组: " + Arrays.toString(arr));
        System.out.println();
        
        bubbleSortWithLastSwap(arr.clone());
        
        System.out.println("\n最终排序结果: " + Arrays.toString(arr));
    }
}
```

### 4. 双向冒泡排序（鸡尾酒排序）

```
import java.util.Arrays;

public class CocktailSort {
    
    /**
     * 鸡尾酒排序（双向冒泡排序）
     * 从左向右和从右向左交替进行冒泡排序
     */
    public static void cocktailSort(int[] arr) {
        int n = arr.length;
        boolean swapped = true;
        int start = 0;
        int end = n - 1;
        int iteration = 0;
        
        while (swapped) {
            iteration++;
            swapped = false;
            
            // 从左向右遍历
            System.out.println("第 " + iteration + " 轮，从左向右:");
            for (int i = start; i < end; i++) {
                if (arr[i] > arr[i + 1]) {
                    int temp = arr[i];
                    arr[i] = arr[i + 1];
                    arr[i + 1] = temp;
                    swapped = true;
                    
                    System.out.println("  交换 " + arr[i] + " 和 " + arr[i+1] + 
                                     " (索引 " + i + " 和 " + (i+1) + ")");
                }
            }
            
            // 如果没有交换发生，说明数组已有序
            if (!swapped) {
                System.out.println("  无交换，数组已有序");
                break;
            }
            
            // 缩小范围，因为最后一个元素已到位
            end--;
            
            // 从右向左遍历
            System.out.println("第 " + iteration + " 轮，从右向左:");
            swapped = false;
            for (int i = end; i > start; i--) {
                if (arr[i] < arr[i - 1]) {
                    int temp = arr[i];
                    arr[i] = arr[i - 1];
                    arr[i - 1] = temp;
                    swapped = true;
                    
                    System.out.println("  交换 " + arr[i] + " 和 " + arr[i-1] + 
                                     " (索引 " + i + " 和 " + (i-1) + ")");
                }
            }
            
            // 缩小范围，因为第一个元素已到位
            start++;
            
            System.out.println("当前数组: " + Arrays.toString(arr));
            System.out.println("下一轮范围: [" + start + ", " + end + "]");
        }
    }
    
    public static void main(String[] args) {
        int[] arr1 = {5, 1, 4, 2, 8, 0, 2};
        int[] arr2 = {2, 3, 4, 5, 1};  // 只有一个元素在错误位置
        
        System.out.println("=== 鸡尾酒排序（双向冒泡）演示 ===");
        
        System.out.println("\n测试1: 普通数组");
        System.out.println("原始数组: " + Arrays.toString(arr1));
        cocktailSort(arr1.clone());
        
        System.out.println("\n测试2: 几乎有序数组");
        System.out.println("原始数组: " + Arrays.toString(arr2));
        cocktailSort(arr2.clone());
    }
}
```

### 5. 完整冒泡排序工具类

```
import java.util.Arrays;
import java.util.Random;

public class BubbleSortUtils {
    
    /**
     * 冒泡排序工具类
     */
    public static class SortResult {
        int[] sortedArray;
        int comparisons;  // 比较次数
        int swaps;        // 交换次数
        int iterations;   // 遍历轮数
        long time;        // 耗时（纳秒）
        
        public SortResult(int[] sortedArray, int comparisons, int swaps, int iterations, long time) {
            this.sortedArray = sortedArray;
            this.comparisons = comparisons;
            this.swaps = swaps;
            this.iterations = iterations;
            this.time = time;
        }
        
        @Override
        public String toString() {
            return String.format("比较次数: %d, 交换次数: %d, 遍历轮数: %d, 耗时: %d ns", 
                                comparisons, swaps, iterations, time);
        }
    }
    
    /**
     * 基础冒泡排序（带统计）
     */
    public static SortResult bubbleSortWithStats(int[] arr) {
        int[] arrCopy = arr.clone();
        int n = arrCopy.length;
        int comparisons = 0;
        int swaps = 0;
        
        long startTime = System.nanoTime();
        
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - 1 - i; j++) {
                comparisons++;
                if (arrCopy[j] > arrCopy[j + 1]) {
                    // 交换
                    int temp = arrCopy[j];
                    arrCopy[j] = arrCopy[j + 1];
                    arrCopy[j + 1] = temp;
                    swaps++;
                }
            }
        }
        
        long endTime = System.nanoTime();
        
        return new SortResult(arrCopy, comparisons, swaps, n-1, endTime - startTime);
    }
    
    /**
     * 优化冒泡排序（带统计）
     */
    public static SortResult optimizedBubbleSortWithStats(int[] arr) {
        int[] arrCopy = arr.clone();
        int n = arrCopy.length;
        int comparisons = 0;
        int swaps = 0;
        int iterations = 0;
        boolean swapped;
        
        long startTime = System.nanoTime();
        
        for (int i = 0; i < n - 1; i++) {
            iterations++;
            swapped = false;
            
            for (int j = 0; j < n - 1 - i; j++) {
                comparisons++;
                if (arrCopy[j] > arrCopy[j + 1]) {
                    // 交换
                    int temp = arrCopy[j];
                    arrCopy[j] = arrCopy[j + 1];
                    arrCopy[j + 1] = temp;
                    swaps++;
                    swapped = true;
                }
            }
            
            // 如果这一轮没有交换，提前终止
            if (!swapped) {
                break;
            }
        }
        
        long endTime = System.nanoTime();
        
        return new SortResult(arrCopy, comparisons, swaps, iterations, endTime - startTime);
    }
    
    /**
     * 生成随机数组
     */
    public static int[] generateRandomArray(int size, int maxValue) {
        int[] arr = new int[size];
        Random random = new Random();
        
        for (int i = 0; i < size; i++) {
            arr[i] = random.nextInt(maxValue);
        }
        
        return arr;
    }
    
    /**
     * 生成几乎有序的数组
     */
    public static int[] generateNearlySortedArray(int size) {
        int[] arr = new int[size];
        
        for (int i = 0; i < size; i++) {
            arr[i] = i;
        }
        
        // 随机交换几对元素
        Random random = new Random();
        int swaps = size / 10;  // 交换10%的元素
        
        for (int i = 0; i < swaps; i++) {
            int index1 = random.nextInt(size);
            int index2 = random.nextInt(size);
            
            int temp = arr[index1];
            arr[index1] = arr[index2];
            arr[index2] = temp;
        }
        
        return arr;
    }
    
    /**
     * 生成逆序数组
     */
    public static int[] generateReverseArray(int size) {
        int[] arr = new int[size];
        
        for (int i = 0; i < size; i++) {
            arr[i] = size - i;
        }
        
        return arr;
    }
    
    /**
     * 性能比较
     */
    public static void performanceComparison() {
        System.out.println("=== 冒泡排序性能比较 ===");
        System.out.println("数组大小: 1000");
        
        // 测试不同情况的数组
        String[] testCases = {"随机数组", "几乎有序数组", "完全逆序数组"};
        int[][][] testArrays = new int[3][2][1000];
        
        for (int i = 0; i < 3; i++) {
            switch (i) {
                case 0:
                    testArrays[i][0] = generateRandomArray(1000, 10000);
                    break;
                case 1:
                    testArrays[i][0] = generateNearlySortedArray(1000);
                    break;
                case 2:
                    testArrays[i][0] = generateReverseArray(1000);
                    break;
            }
            testArrays[i][1] = testArrays[i][0].clone();
        }
        
        System.out.printf("%-20s %-20s %-20s%n", 
                         "测试用例", "基础冒泡排序", "优化冒泡排序");
        System.out.println("-".repeat(60));
        
        for (int i = 0; i < 3; i++) {
            SortResult result1 = bubbleSortWithStats(testArrays[i][0]);
            SortResult result2 = optimizedBubbleSortWithStats(testArrays[i][1]);
            
            System.out.printf("%-20s %-20s %-20s%n", 
                testCases[i],
                String.format("%d ms", result1.time / 1_000_000),
                String.format("%d ms", result2.time / 1_000_000));
        }
        
        // 详细统计
        System.out.println("\n=== 详细统计（随机数组） ===");
        int[] randomArray = generateRandomArray(100, 1000);
        SortResult basicResult = bubbleSortWithStats(randomArray);
        SortResult optimizedResult = optimizedBubbleSortWithStats(randomArray);
        
        System.out.println("基础冒泡排序:");
        System.out.println("  " + basicResult);
        System.out.println("优化冒泡排序:");
        System.out.println("  " + optimizedResult);
        
        // 验证排序结果是否相同
        boolean sameResult = Arrays.equals(basicResult.sortedArray, optimizedResult.sortedArray);
        System.out.println("排序结果是否相同: " + sameResult);
    }
    
    /**
     * 可视化冒泡排序过程
     */
    public static void visualizeBubbleSort(int[] arr) {
        System.out.println("=== 冒泡排序可视化 ===");
        System.out.println("原始数组: " + Arrays.toString(arr));
        System.out.println();
        
        int[] arrCopy = arr.clone();
        int n = arrCopy.length;
        
        for (int i = 0; i < n - 1; i++) {
            System.out.println("第 " + (i + 1) + " 轮:");
            
            // 打印当前数组状态
            for (int k = 0; k < n; k++) {
                if (k < n - i) {
                    System.out.print("[" + arrCopy[k] + "] ");
                } else {
                    System.out.print(" " + arrCopy[k] + "  ");  // 已排序部分
                }
            }
            System.out.println();
            
            // 执行一轮冒泡
            for (int j = 0; j < n - 1 - i; j++) {
                if (arrCopy[j] > arrCopy[j + 1]) {
                    int temp = arrCopy[j];
                    arrCopy[j] = arrCopy[j + 1];
                    arrCopy[j + 1] = temp;
                    
                    // 显示交换
                    System.out.print("  ".repeat(j) + " ^  ^\n");
                    System.out.print("  ".repeat(j) + " |  |\n");
                    System.out.print("  ".repeat(j) + "交换位置 " + j + " 和 " + (j+1) + "\n");
                }
            }
            System.out.println();
        }
        
        System.out.println("最终排序结果: " + Arrays.toString(arrCopy));
    }
    
    public static void main(String[] args) {
        // 性能比较
        performanceComparison();
        
        System.out.println("\n" + "=".repeat(50) + "\n");
        
        // 可视化演示
        int[] smallArray = {5, 3, 8, 1, 2};
        visualizeBubbleSort(smallArray);
        
        System.out.println("\n" + "=".repeat(50) + "\n");
        
        // 测试不同版本的冒泡排序
        int[] testArray = {64, 34, 25, 12, 22, 11, 90};
        System.out.println("测试数组: " + Arrays.toString(testArray));
        
        System.out.println("\n1. 基础冒泡排序:");
        SortResult basic = bubbleSortWithStats(testArray);
        System.out.println("结果: " + Arrays.toString(basic.sortedArray));
        System.out.println("统计: " + basic);
        
        System.out.println("\n2. 优化冒泡排序:");
        SortResult optimized = optimizedBubbleSortWithStats(testArray);
        System.out.println("结果: " + Arrays.toString(optimized.sortedArray));
        System.out.println("统计: " + optimized);
    }
}
```

### 6. 泛型冒泡排序

```
import java.util.Arrays;
import java.util.Comparator;

public class GenericBubbleSort {
    
    /**
     * 泛型冒泡排序（基础版）
     * @param arr 待排序数组
     * @param comparator 比较器
     */
    public static <T> void bubbleSortGeneric(T[] arr, Comparator<T> comparator) {
        int n = arr.length;
        
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - 1 - i; j++) {
                if (comparator.compare(arr[j], arr[j + 1]) > 0) {
                    T temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
    
    /**
     * 泛型冒泡排序（优化版）
     */
    public static <T> void bubbleSortGenericOptimized(T[] arr, Comparator<T> comparator) {
        int n = arr.length;
        boolean swapped;
        
        for (int i = 0; i < n - 1; i++) {
            swapped = false;
            
            for (int j = 0; j < n - 1 - i; j++) {
                if (comparator.compare(arr[j], arr[j + 1]) > 0) {
                    T temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true;
                }
            }
            
            if (!swapped) {
                break;
            }
        }
    }
    
    /**
     * 泛型冒泡排序（用于Comparable对象）
     */
    public static <T extends Comparable<T>> void bubbleSortComparable(T[] arr) {
        int n = arr.length;
        boolean swapped;
        
        for (int i = 0; i < n - 1; i++) {
            swapped = false;
            
            for (int j = 0; j < n - 1 - i; j++) {
                if (arr[j].compareTo(arr[j + 1]) > 0) {
                    T temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true;
                }
            }
            
            if (!swapped) {
                break;
            }
        }
    }
    
    /**
     * 学生类，用于演示
     */
    static class Student implements Comparable<Student> {
        String name;
        int score;
        
        Student(String name, int score) {
            this.name = name;
            this.score = score;
        }
        
        @Override
        public int compareTo(Student other) {
            return Integer.compare(this.score, other.score);
        }
        
        @Override
        public String toString() {
            return name + "(" + score + ")";
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== 泛型冒泡排序演示 ===");
        
        // 测试1: 整数数组
        System.out.println("\n1. 排序整数数组:");
        Integer[] intArray = {5, 2, 8, 1, 9, 3};
        System.out.println("排序前: " + Arrays.toString(intArray));
        
        bubbleSortComparable(intArray);
        System.out.println("排序后: " + Arrays.toString(intArray));
        
        // 测试2: 字符串数组
        System.out.println("\n2. 排序字符串数组:");
        String[] strArray = {"banana", "apple", "orange", "grape", "cherry"};
        System.out.println("排序前: " + Arrays.toString(strArray));
        
        bubbleSortComparable(strArray);
        System.out.println("排序后: " + Arrays.toString(strArray));
        
        // 测试3: 自定义对象数组
        System.out.println("\n3. 排序学生对象（按分数）:");
        Student[] students = {
            new Student("Alice", 85),
            new Student("Bob", 92),
            new Student("Charlie", 78),
            new Student("David", 90)
        };
        
        System.out.println("排序前: " + Arrays.toString(students));
        bubbleSortComparable(students);
        System.out.println("排序后: " + Arrays.toString(students));
        
        // 测试4: 使用自定义比较器
        System.out.println("\n4. 使用自定义比较器排序学生（按姓名）:");
        Student[] students2 = students.clone();
        Comparator<Student> nameComparator = Comparator.comparing(s -> s.name);
        
        System.out.println("排序前: " + Arrays.toString(students2));
        bubbleSortGeneric(students2, nameComparator);
        System.out.println("排序后: " + Arrays.toString(students2));
        
        // 测试5: 降序排序
        System.out.println("\n5. 降序排序整数数组:");
        Integer[] intArray2 = {5, 2, 8, 1, 9, 3};
        System.out.println("排序前: " + Arrays.toString(intArray2));
        
        bubbleSortGeneric(intArray2, Comparator.reverseOrder());
        System.out.println("排序后: " + Arrays.toString(intArray2));
    }
}
```

## 冒泡排序的变体和优化

### 1. 奇偶排序

```
public class OddEvenSort {
    
    /**
     * 奇偶排序：并行排序算法
     * 比较所有奇数索引对，然后比较所有偶数索引对
     */
    public static void oddEvenSort(int[] arr) {
        int n = arr.length;
        boolean sorted = false;
        
        while (!sorted) {
            sorted = true;
            
            // 奇数索引比较 (1,2), (3,4), ...
            for (int i = 1; i < n - 1; i += 2) {
                if (arr[i] > arr[i + 1]) {
                    int temp = arr[i];
                    arr[i] = arr[i + 1];
                    arr[i + 1] = temp;
                    sorted = false;
                }
            }
            
            // 偶数索引比较 (0,1), (2,3), ...
            for (int i = 0; i < n - 1; i += 2) {
                if (arr[i] > arr[i + 1]) {
                    int temp = arr[i];
                    arr[i] = arr[i + 1];
                    arr[i + 1] = temp;
                    sorted = false;
                }
            }
        }
    }
}
```

### 2. 梳排序

```
public class CombSort {
    
    /**
     * 梳排序：冒泡排序的改进版
     * 通过较大的间隔开始比较，逐渐减小间隔
     */
    public static void combSort(int[] arr) {
        int n = arr.length;
        int gap = n;
        boolean swapped = true;
        double shrink = 1.3;  // 收缩因子
        
        while (gap > 1 || swapped) {
            // 计算新的间隔
            gap = (int)(gap / shrink);
            if (gap < 1) {
                gap = 1;
            }
            
            swapped = false;
            
            // 单次梳排序遍历
            for (int i = 0; i + gap < n; i++) {
                if (arr[i] > arr[i + gap]) {
                    int temp = arr[i];
                    arr[i] = arr[i + gap];
                    arr[i + gap] = temp;
                    swapped = true;
                }
            }
        }
    }
}
```

## 应用场景和总结

### 适用场景

1. **教学目的**：简单易懂，适合算法教学
    
2. **小型数据集**：数据量小（n < 100）时性能尚可
    
3. **几乎有序的数据**：优化后的冒泡排序对几乎有序的数据效率较高
    
4. **内存有限的环境**：原地排序，不需要额外空间
    

### 不适用场景

1. **大型数据集**：时间复杂度O(n²)导致性能很差
    
2. **对性能要求高的场景**：相比其他排序算法（快速排序、归并排序等）效率低
    
3. **实时系统**：最坏情况下的性能不可预测
    

### 与其他排序算法的比较

|排序算法|平均时间复杂度|最好情况|最坏情况|空间复杂度|稳定性|
|---|---|---|---|---|---|
|冒泡排序|O(n²)|O(n)|O(n²)|O(1)|稳定|
|选择排序|O(n²)|O(n²)|O(n²)|O(1)|不稳定|
|插入排序|O(n²)|O(n)|O(n²)|O(1)|稳定|
|快速排序|O(n log n)|O(n log n)|O(n²)|O(log n)|不稳定|
|归并排序|O(n log n)|O(n log n)|O(n log n)|O(n)|稳定|
|堆排序|O(n log n)|O(n log n)|O(n log n)|O(1)|不稳定|

### 总结

冒泡排序是最简单直观的排序算法之一，其主要价值在于教学和概念理解。虽然在实际应用中由于其较差的性能而很少被使用，但通过研究其优化版本和变体，我们可以学习到许多重要的算法优化思想，如：

- 提前终止（优化标志）
    
- 减少不必要的比较（记录最后交换位置）
    
- 双向遍历（鸡尾酒排序）
    
- 自适应排序
    

理解冒泡排序不仅有助于掌握基本的排序概念，也为学习更复杂的排序算法奠定了坚实的基础。