# Java算法：归并排序

## 定义

**归并排序**（Merge Sort）是一种基于**分治法**（Divide and Conquer）的高效排序算法。它将数组递归地分成两半，分别对每一半进行排序，然后将两个已排序的部分合并成一个完整的有序数组。

### 算法原理

1. **分**：将待排序的数组从中间分成两个子数组
    
2. **治**：递归地对两个子数组进行归并排序
    
3. **合**：将两个已排序的子数组合并成一个有序数组
    

### 特点

|特性|描述|
|---|---|
|**时间复杂度**​|最好O(n log n)，平均O(n log n)，最坏O(n log n)|
|**空间复杂度**​|O(n)|
|**稳定性**​|稳定排序算法|
|**原地排序**​|否，需要额外空间|
|**递归深度**​|O(log n)|

## 算法可视化

```
初始数组: [38, 27, 43, 3, 9, 82, 10]

分解过程：
[38, 27, 43, 3, 9, 82, 10]
       ↓
[38, 27, 43, 3] 和 [9, 82, 10]
       ↓
[38, 27] 和 [43, 3]  |  [9, 82] 和 [10]
       ↓
[38] 和 [27]  |  [43] 和 [3]  |  [9] 和 [82]  |  [10]

合并过程：
[27, 38]  ← 合并 [38] 和 [27]
[3, 43]   ← 合并 [43] 和 [3]
[3, 27, 38, 43]  ← 合并 [27, 38] 和 [3, 43]

[9, 82]   ← 合并 [9] 和 [82]
[10]      ← 单元素
[9, 10, 82]  ← 合并 [9, 82] 和 [10]

最终结果：
[3, 9, 10, 27, 38, 43, 82]  ← 合并 [3, 27, 38, 43] 和 [9, 10, 82]
```

## Java实现示例

### 1. 递归归并排序（自顶向下）

```
import java.util.Arrays;

public class MergeSortRecursive {
    
    /**
     * 递归归并排序
     */
    public static void mergeSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        
        int[] temp = new int[arr.length];  // 临时数组用于合并
        mergeSort(arr, 0, arr.length - 1, temp);
    }
    
    private static void mergeSort(int[] arr, int left, int right, int[] temp) {
        if (left < right) {
            int mid = left + (right - left) / 2;  // 防止溢出
            
            System.out.println("分解: [" + left + ", " + mid + "] 和 [" + (mid + 1) + ", " + right + "]");
            
            // 递归排序左半部分
            mergeSort(arr, left, mid, temp);
            
            // 递归排序右半部分
            mergeSort(arr, mid + 1, right, temp);
            
            // 合并两个有序子数组
            merge(arr, left, mid, right, temp);
        }
    }
    
    private static void merge(int[] arr, int left, int mid, int right, int[] temp) {
        System.out.println("合并: [" + left + ", " + mid + "] 和 [" + (mid + 1) + ", " + right + "]");
        System.out.println("  左子数组: " + Arrays.toString(Arrays.copyOfRange(arr, left, mid + 1)));
        System.out.println("  右子数组: " + Arrays.toString(Arrays.copyOfRange(arr, mid + 1, right + 1)));
        
        int i = left;      // 左子数组起始索引
        int j = mid + 1;   // 右子数组起始索引
        int k = 0;         // 临时数组起始索引
        
        // 比较左右子数组的元素，将较小的放入临时数组
        while (i <= mid && j <= right) {
            if (arr[i] <= arr[j]) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
            }
        }
        
        // 将左子数组剩余元素复制到临时数组
        while (i <= mid) {
            temp[k++] = arr[i++];
        }
        
        // 将右子数组剩余元素复制到临时数组
        while (j <= right) {
            temp[k++] = arr[j++];
        }
        
        // 将临时数组的元素复制回原数组
        for (i = 0; i < k; i++) {
            arr[left + i] = temp[i];
        }
        
        System.out.println("  合并后: " + Arrays.toString(Arrays.copyOfRange(arr, left, right + 1)));
        System.out.println();
    }
    
    /**
     * 归并排序（简化版本，不打印详细过程）
     */
    public static void mergeSortSimple(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        
        int[] temp = new int[arr.length];
        mergeSortSimple(arr, 0, arr.length - 1, temp);
    }
    
    private static void mergeSortSimple(int[] arr, int left, int right, int[] temp) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            
            mergeSortSimple(arr, left, mid, temp);
            mergeSortSimple(arr, mid + 1, right, temp);
            
            // 如果左子数组的最大值小于等于右子数组的最小值，则不需要合并
            if (arr[mid] <= arr[mid + 1]) {
                return;
            }
            
            merge(arr, left, mid, right, temp);
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {38, 27, 43, 3, 9, 82, 10};
        
        System.out.println("=== 递归归并排序演示 ===");
        System.out.println("原始数组: " + Arrays.toString(arr));
        System.out.println();
        
        int[] arrCopy = arr.clone();
        mergeSort(arrCopy);
        
        System.out.println("排序结果: " + Arrays.toString(arrCopy));
        
        // 测试简化版本
        System.out.println("\n=== 测试简化版本（检查是否已有序） ===");
        int[] arr2 = {1, 2, 3, 4, 5};
        System.out.println("原始数组: " + Arrays.toString(arr2));
        
        int[] arr2Copy = arr2.clone();
        mergeSortSimple(arr2Copy);
        System.out.println("排序后: " + Arrays.toString(arr2Copy));
    }
}
```

### 2. 迭代归并排序（自底向上）

```
import java.util.Arrays;

public class MergeSortIterative {
    
    /**
     * 迭代归并排序
     * 自底向上，从单个元素开始合并
     */
    public static void mergeSortIterative(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        
        int n = arr.length;
        int[] temp = new int[n];
        
        // size表示当前合并的子数组大小：1, 2, 4, 8...
        for (int size = 1; size < n; size *= 2) {
            System.out.println("\n当前合并大小: " + size);
            
            for (int left = 0; left < n; left += 2 * size) {
                int mid = Math.min(left + size - 1, n - 1);
                int right = Math.min(left + 2 * size - 1, n - 1);
                
                if (mid < right) {  // 如果存在右子数组
                    System.out.println("合并 [" + left + ", " + mid + "] 和 [" + (mid + 1) + ", " + right + "]");
                    merge(arr, left, mid, right, temp);
                }
            }
            
            System.out.println("当前数组状态: " + Arrays.toString(arr));
        }
    }
    
    /**
     * 合并两个有序子数组
     */
    private static void merge(int[] arr, int left, int mid, int right, int[] temp) {
        int i = left;
        int j = mid + 1;
        int k = 0;
        
        // 合并到临时数组
        while (i <= mid && j <= right) {
            if (arr[i] <= arr[j]) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
            }
        }
        
        // 复制剩余元素
        while (i <= mid) {
            temp[k++] = arr[i++];
        }
        
        while (j <= right) {
            temp[k++] = arr[j++];
        }
        
        // 从临时数组复制回原数组
        for (i = 0; i < k; i++) {
            arr[left + i] = temp[i];
        }
    }
    
    /**
     * 迭代归并排序（优化版本）
     */
    public static void mergeSortIterativeOptimized(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        
        int n = arr.length;
        int[] src = arr;        // 源数组
        int[] dest = new int[n]; // 目标数组
        int[] temp;              // 临时引用，用于交换
        
        // 外层循环：控制合并的大小
        for (int size = 1; size < n; size *= 2) {
            // 内层循环：合并所有相邻的子数组
            for (int left = 0; left < n; left += 2 * size) {
                int mid = Math.min(left + size - 1, n - 1);
                int right = Math.min(left + 2 * size - 1, n - 1);
                
                // 合并到目标数组
                mergeToDest(src, dest, left, mid, right);
            }
            
            // 交换源数组和目标数组
            temp = src;
            src = dest;
            dest = temp;
        }
        
        // 如果最终结果在临时数组中，复制回原数组
        if (src != arr) {
            System.arraycopy(src, 0, arr, 0, n);
        }
    }
    
    /**
     * 合并到目标数组
     */
    private static void mergeToDest(int[] src, int[] dest, int left, int mid, int right) {
        int i = left;
        int j = mid + 1;
        int k = left;
        
        // 合并两个有序子数组
        while (i <= mid && j <= right) {
            if (src[i] <= src[j]) {
                dest[k++] = src[i++];
            } else {
                dest[k++] = src[j++];
            }
        }
        
        // 复制剩余元素
        while (i <= mid) {
            dest[k++] = src[i++];
        }
        
        while (j <= right) {
            dest[k++] = src[j++];
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {38, 27, 43, 3, 9, 82, 10};
        
        System.out.println("=== 迭代归并排序演示 ===");
        System.out.println("原始数组: " + Arrays.toString(arr));
        
        int[] arrCopy = arr.clone();
        mergeSortIterative(arrCopy);
        
        System.out.println("\n排序结果: " + Arrays.toString(arrCopy));
        
        // 测试优化版本
        System.out.println("\n=== 测试优化版本（避免频繁复制） ===");
        int[] arr2 = {5, 2, 8, 1, 9, 3, 7, 4, 6};
        System.out.println("原始数组: " + Arrays.toString(arr2));
        
        int[] arr2Copy = arr2.clone();
        mergeSortIterativeOptimized(arr2Copy);
        System.out.println("排序后: " + Arrays.toString(arr2Copy));
    }
}
```

### 3. 泛型归并排序

```
import java.util.Arrays;
import java.util.Comparator;

public class GenericMergeSort {
    
    /**
     * 泛型归并排序（使用Comparable接口）
     */
    public static <T extends Comparable<T>> void mergeSort(T[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        
        @SuppressWarnings("unchecked")
        T[] temp = (T[]) new Comparable[arr.length];
        mergeSort(arr, 0, arr.length - 1, temp);
    }
    
    private static <T extends Comparable<T>> void mergeSort(T[] arr, int left, int right, T[] temp) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            
            mergeSort(arr, left, mid, temp);
            mergeSort(arr, mid + 1, right, temp);
            
            // 如果已有序，跳过合并
            if (arr[mid].compareTo(arr[mid + 1]) <= 0) {
                return;
            }
            
            merge(arr, left, mid, right, temp);
        }
    }
    
    private static <T extends Comparable<T>> void merge(T[] arr, int left, int mid, int right, T[] temp) {
        int i = left;
        int j = mid + 1;
        int k = 0;
        
        // 合并两个有序子数组
        while (i <= mid && j <= right) {
            if (arr[i].compareTo(arr[j]) <= 0) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
            }
        }
        
        // 复制剩余元素
        while (i <= mid) {
            temp[k++] = arr[i++];
        }
        
        while (j <= right) {
            temp[k++] = arr[j++];
        }
        
        // 复制回原数组
        for (i = 0; i < k; i++) {
            arr[left + i] = temp[i];
        }
    }
    
    /**
     * 泛型归并排序（使用Comparator比较器）
     */
    public static <T> void mergeSort(T[] arr, Comparator<T> comparator) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        
        @SuppressWarnings("unchecked")
        T[] temp = (T[]) new Object[arr.length];
        mergeSort(arr, 0, arr.length - 1, temp, comparator);
    }
    
    private static <T> void mergeSort(T[] arr, int left, int right, T[] temp, Comparator<T> comparator) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            
            mergeSort(arr, left, mid, temp, comparator);
            mergeSort(arr, mid + 1, right, temp, comparator);
            
            if (comparator.compare(arr[mid], arr[mid + 1]) <= 0) {
                return;
            }
            
            merge(arr, left, mid, right, temp, comparator);
        }
    }
    
    private static <T> void merge(T[] arr, int left, int mid, int right, T[] temp, Comparator<T> comparator) {
        int i = left;
        int j = mid + 1;
        int k = 0;
        
        while (i <= mid && j <= right) {
            if (comparator.compare(arr[i], arr[j]) <= 0) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
            }
        }
        
        while (i <= mid) {
            temp[k++] = arr[i++];
        }
        
        while (j <= right) {
            temp[k++] = arr[j++];
        }
        
        for (i = 0; i < k; i++) {
            arr[left + i] = temp[i];
        }
    }
    
    /**
     * 自然归并排序
     * 利用已存在的有序子序列（run）
     */
    public static <T extends Comparable<T>> void naturalMergeSort(T[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        
        @SuppressWarnings("unchecked")
        T[] temp = (T[]) new Comparable[arr.length];
        
        while (true) {
            int left = 0;
            boolean sorted = true;
            
            while (left < arr.length) {
                // 找到一个有序子序列
                int mid = findRun(arr, left);
                
                if (mid == arr.length - 1) {
                    if (left == 0) {
                        return;  // 整个数组已有序
                    }
                    break;
                }
                
                // 找到第二个有序子序列
                int right = findRun(arr, mid + 1);
                
                // 合并两个有序子序列
                merge(arr, left, mid, right, temp);
                
                left = right + 1;
                sorted = false;
            }
            
            if (sorted) {
                break;
            }
        }
    }
    
    private static <T extends Comparable<T>> int findRun(T[] arr, int start) {
        int i = start;
        while (i < arr.length - 1 && arr[i].compareTo(arr[i + 1]) <= 0) {
            i++;
        }
        return i;
    }
    
    /**
     * 学生类，用于演示
     */
    static class Student implements Comparable<Student> {
        String name;
        int score;
        int age;
        
        Student(String name, int score, int age) {
            this.name = name;
            this.score = score;
            this.age = age;
        }
        
        @Override
        public int compareTo(Student other) {
            return Integer.compare(this.score, other.score);
        }
        
        @Override
        public String toString() {
            return String.format("%s(分数:%d, 年龄:%d)", name, score, age);
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== 泛型归并排序演示 ===");
        
        // 测试1: 整数数组
        System.out.println("\n1. 排序整数数组:");
        Integer[] intArray = {5, 2, 8, 1, 9, 3};
        System.out.println("排序前: " + Arrays.toString(intArray));
        
        mergeSort(intArray);
        System.out.println("排序后: " + Arrays.toString(intArray));
        
        // 测试2: 字符串数组
        System.out.println("\n2. 排序字符串数组:");
        String[] strArray = {"banana", "apple", "orange", "grape", "cherry"};
        System.out.println("排序前: " + Arrays.toString(strArray));
        
        mergeSort(strArray);
        System.out.println("排序后: " + Arrays.toString(strArray));
        
        // 测试3: 自定义对象数组
        System.out.println("\n3. 排序学生对象（按分数）:");
        Student[] students = {
            new Student("Alice", 85, 20),
            new Student("Bob", 92, 19),
            new Student("Charlie", 78, 21),
            new Student("David", 90, 20)
        };
        
        System.out.println("排序前: " + Arrays.toString(students));
        mergeSort(students);
        System.out.println("排序后: " + Arrays.toString(students));
        
        // 测试4: 使用自定义比较器
        System.out.println("\n4. 使用自定义比较器排序学生（按年龄）:");
        Student[] students2 = students.clone();
        Comparator<Student> ageComparator = Comparator.comparing(s -> s.age);
        
        System.out.println("排序前: " + Arrays.toString(students2));
        mergeSort(students2, ageComparator);
        System.out.println("排序后: " + Arrays.toString(students2));
        
        // 测试5: 自然归并排序
        System.out.println("\n5. 自然归并排序:");
        Integer[] intArray2 = {1, 2, 3, 5, 4, 6, 8, 7, 9};  // 部分有序
        System.out.println("排序前: " + Arrays.toString(intArray2));
        
        naturalMergeSort(intArray2);
        System.out.println("排序后: " + Arrays.toString(intArray2));
    }
}
```

### 4. 归并排序优化版本

```
import java.util.Arrays;

public class MergeSortOptimized {
    
    /**
     * 归并排序优化版本
     * 1. 小数组使用插入排序
     * 2. 检查是否已有序
     * 3. 避免每次合并都创建新数组
     */
    private static final int INSERTION_SORT_THRESHOLD = 7;
    
    public static void mergeSortOptimized(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        
        int[] temp = arr.clone();  // 一次性复制整个数组
        mergeSortOptimized(arr, 0, arr.length - 1, temp);
    }
    
    private static void mergeSortOptimized(int[] arr, int left, int right, int[] temp) {
        // 小数组使用插入排序
        if (right - left + 1 <= INSERTION_SORT_THRESHOLD) {
            insertionSort(arr, left, right);
            return;
        }
        
        int mid = left + (right - left) / 2;
        
        // 交替使用原数组和临时数组
        mergeSortOptimized(temp, left, mid, arr);
        mergeSortOptimized(temp, mid + 1, right, arr);
        
        // 如果已有序，直接复制
        if (temp[mid] <= temp[mid + 1]) {
            System.arraycopy(temp, left, arr, left, right - left + 1);
            return;
        }
        
        // 合并到原数组
        merge(arr, left, mid, right, temp);
    }
    
    /**
     * 插入排序
     */
    private static void insertionSort(int[] arr, int left, int right) {
        for (int i = left + 1; i <= right; i++) {
            int key = arr[i];
            int j = i - 1;
            
            while (j >= left && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            
            arr[j + 1] = key;
        }
    }
    
    /**
     * 合并函数
     */
    private static void merge(int[] arr, int left, int mid, int right, int[] temp) {
        int i = left;
        int j = mid + 1;
        
        for (int k = left; k <= right; k++) {
            if (i > mid) {
                arr[k] = temp[j++];
            } else if (j > right) {
                arr[k] = temp[i++];
            } else if (temp[i] <= temp[j]) {
                arr[k] = temp[i++];
            } else {
                arr[k] = temp[j++];
            }
        }
    }
    
    /**
     * 原地归并排序（需要额外O(log n)空间）
     */
    public static void mergeSortInPlace(int[] arr) {
        mergeSortInPlace(arr, 0, arr.length - 1);
    }
    
    private static void mergeSortInPlace(int[] arr, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            
            mergeSortInPlace(arr, left, mid);
            mergeSortInPlace(arr, mid + 1, right);
            
            // 原地合并
            mergeInPlace(arr, left, mid, right);
        }
    }
    
    /**
     * 原地合并（使用循环移位）
     */
    private static void mergeInPlace(int[] arr, int left, int mid, int right) {
        int i = left;
        int j = mid + 1;
        
        while (i <= mid && j <= right) {
            if (arr[i] <= arr[j]) {
                i++;
            } else {
                int value = arr[j];
                int index = j;
                
                // 将arr[j]插入到arr[i]之前
                while (index > i) {
                    arr[index] = arr[index - 1];
                    index--;
                }
                
                arr[i] = value;
                
                i++;
                mid++;
                j++;
            }
        }
    }
    
    /**
     * 三路归并排序
     */
    public static void threeWayMergeSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        
        int[] temp = new int[arr.length];
        threeWayMergeSort(arr, 0, arr.length - 1, temp);
    }
    
    private static void threeWayMergeSort(int[] arr, int left, int right, int[] temp) {
        if (right - left < 1) {
            return;
        }
        
        // 将数组分成三部分
        int mid1 = left + (right - left) / 3;
        int mid2 = left + 2 * (right - left) / 3;
        
        // 递归排序三个子数组
        threeWayMergeSort(arr, left, mid1, temp);
        threeWayMergeSort(arr, mid1 + 1, mid2, temp);
        threeWayMergeSort(arr, mid2 + 1, right, temp);
        
        // 合并三个有序子数组
        threeWayMerge(arr, left, mid1, mid2, right, temp);
    }
    
    private static void threeWayMerge(int[] arr, int left, int mid1, int mid2, int right, int[] temp) {
        int i = left;
        int j = mid1 + 1;
        int k = mid2 + 1;
        int idx = 0;
        
        // 找到三个子数组中的最小值
        while (i <= mid1 && j <= mid2 && k <= right) {
            int minVal = arr[i];
            int minIdx = 1;
            
            if (arr[j] < minVal) {
                minVal = arr[j];
                minIdx = 2;
            }
            if (arr[k] < minVal) {
                minVal = arr[k];
                minIdx = 3;
            }
            
            temp[idx++] = minVal;
            
            if (minIdx == 1) i++;
            else if (minIdx == 2) j++;
            else k++;
        }
        
        // 处理剩余两个子数组
        while (i <= mid1 && j <= mid2) {
            if (arr[i] <= arr[j]) {
                temp[idx++] = arr[i++];
            } else {
                temp[idx++] = arr[j++];
            }
        }
        
        while (i <= mid1 && k <= right) {
            if (arr[i] <= arr[k]) {
                temp[idx++] = arr[i++];
            } else {
                temp[idx++] = arr[k++];
            }
        }
        
        while (j <= mid2 && k <= right) {
            if (arr[j] <= arr[k]) {
                temp[idx++] = arr[j++];
            } else {
                temp[idx++] = arr[k++];
            }
        }
        
        // 处理单个剩余子数组
        while (i <= mid1) temp[idx++] = arr[i++];
        while (j <= mid2) temp[idx++] = arr[j++];
        while (k <= right) temp[idx++] = arr[k++];
        
        // 复制回原数组
        System.arraycopy(temp, 0, arr, left, idx);
    }
    
    public static void main(String[] args) {
        int[] arr = {38, 27, 43, 3, 9, 82, 10, 15, 7, 25};
        
        System.out.println("=== 归并排序优化版本演示 ===");
        System.out.println("原始数组: " + Arrays.toString(arr));
        
        // 测试优化版本
        System.out.println("\n1. 优化版本（小数组用插入排序）:");
        int[] arrCopy1 = arr.clone();
        mergeSortOptimized(arrCopy1);
        System.out.println("排序结果: " + Arrays.toString(arrCopy1));
        
        // 测试原地归并排序
        System.out.println("\n2. 原地归并排序（需要O(log n)额外空间）:");
        int[] arrCopy2 = arr.clone();
        mergeSortInPlace(arrCopy2);
        System.out.println("排序结果: " + Arrays.toString(arrCopy2));
        
        // 测试三路归并排序
        System.out.println("\n3. 三路归并排序:");
        int[] arrCopy3 = arr.clone();
        threeWayMergeSort(arrCopy3);
        System.out.println("排序结果: " + Arrays.toString(arrCopy3));
        
        // 性能比较
        System.out.println("\n=== 性能测试（小数组阈值的影响） ===");
        
        int[][] testArrays = new int[5][1000];
        for (int i = 0; i < 5; i++) {
            testArrays[i] = generateRandomArray(1000, 10000);
        }
        
        System.out.printf("%-15s %-20s %-20s%n", "阈值", "平均时间(ms)", "比较次数");
        System.out.println("-".repeat(55));
        
        int[] thresholds = {7, 15, 30, 50, 100};
        for (int threshold : thresholds) {
            INSERTION_SORT_THRESHOLD = threshold;
            long totalTime = 0;
            
            for (int i = 0; i < 5; i++) {
                int[] testArr = testArrays[i].clone();
                long startTime = System.nanoTime();
                mergeSortOptimized(testArr);
                long endTime = System.nanoTime();
                totalTime += (endTime - startTime) / 1_000_000;
            }
            
            System.out.printf("%-15d %-20d %-20s%n", 
                threshold, totalTime / 5, "N/A");
        }
    }
    
    private static int[] generateRandomArray(int size, int maxValue) {
        int[] arr = new int[size];
        for (int i = 0; i < size; i++) {
            arr[i] = (int)(Math.random() * maxValue);
        }
        return arr;
    }
}
```

### 5. 归并排序性能分析和应用

```
import java.util.Arrays;
import java.util.Random;

public class MergeSortAnalysis {
    
    /**
     * 归并排序统计类
     */
    static class SortStats {
        long comparisons;    // 比较次数
        long arrayAccess;    // 数组访问次数
        long recursiveCalls; // 递归调用次数
        long time;           // 耗时（纳秒）
        
        @Override
        public String toString() {
            return String.format("比较次数: %d, 数组访问: %d, 递归调用: %d, 耗时: %d ns", 
                                comparisons, arrayAccess, recursiveCalls, time);
        }
    }
    
    /**
     * 带统计的归并排序
     */
    public static SortStats mergeSortWithStats(int[] arr) {
        SortStats stats = new SortStats();
        
        if (arr == null || arr.length <= 1) {
            return stats;
        }
        
        int[] temp = new int[arr.length];
        
        long startTime = System.nanoTime();
        mergeSortWithStats(arr, 0, arr.length - 1, temp, stats);
        long endTime = System.nanoTime();
        
        stats.time = endTime - startTime;
        return stats;
    }
    
    private static void mergeSortWithStats(int[] arr, int left, int right, int[] temp, SortStats stats) {
        stats.recursiveCalls++;
        
        if (left < right) {
            int mid = left + (right - left) / 2;
            
            mergeSortWithStats(arr, left, mid, temp, stats);
            mergeSortWithStats(arr, mid + 1, right, temp, stats);
            
            mergeWithStats(arr, left, mid, right, temp, stats);
        }
    }
    
    private static void mergeWithStats(int[] arr, int left, int mid, int right, int[] temp, SortStats stats) {
        int i = left;
        int j = mid + 1;
        int k = 0;
        
        while (i <= mid && j <= right) {
            stats.comparisons++;
            stats.arrayAccess += 2;  // 读取arr[i]和arr[j]
            
            if (arr[i] <= arr[j]) {
                temp[k++] = arr[i++];
                stats.arrayAccess++;  // 写入temp
            } else {
                temp[k++] = arr[j++];
                stats.arrayAccess++;  // 写入temp
            }
        }
        
        while (i <= mid) {
            temp[k++] = arr[i++];
            stats.arrayAccess += 2;  // 读取arr[i]，写入temp
        }
        
        while (j <= right) {
            temp[k++] = arr[j++];
            stats.arrayAccess += 2;  // 读取arr[j]，写入temp
        }
        
        for (i = 0; i < k; i++) {
            arr[left + i] = temp[i];
            stats.arrayAccess += 2;  // 读取temp[i]，写入arr
        }
    }
    
    /**
     * 与其他排序算法比较
     */
    public static void compareWithOtherSorts() {
        System.out.println("=== 归并排序 vs 快速排序 vs 堆排序 ===");
        System.out.println("数组大小: 10000");
        
        int[] arr = generateRandomArray(10000, 100000);
        
        // 归并排序
        long startTime = System.nanoTime();
        int[] mergeSorted = mergeSort(arr.clone());
        long mergeTime = System.nanoTime() - startTime;
        
        // 快速排序
        startTime = System.nanoTime();
        int[] quickSorted = quickSort(arr.clone());
        long quickTime = System.nanoTime() - startTime;
        
        // 堆排序
        startTime = System.nanoTime();
        int[] heapSorted = heapSort(arr.clone());
        long heapTime = System.nanoTime() - startTime;
        
        // 验证结果
        boolean mergeQuickEqual = Arrays.equals(mergeSorted, quickSorted);
        boolean quickHeapEqual = Arrays.equals(quickSorted, heapSorted);
        
        System.out.println("归并排序用时: " + mergeTime / 1_000_000 + " ms");
        System.out.println("快速排序用时: " + quickTime / 1_000_000 + " ms");
        System.out.println("堆排序用时: " + heapTime / 1_000_000 + " ms");
        System.out.println("排序结果一致: " + (mergeQuickEqual && quickHeapEqual));
    }
    
    /**
     * 归并排序实现
     */
    public static int[] mergeSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return arr;
        }
        
        int[] temp = new int[arr.length];
        mergeSort(arr, 0, arr.length - 1, temp);
        return arr;
    }
    
    private static void mergeSort(int[] arr, int left, int right, int[] temp) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            
            mergeSort(arr, left, mid, temp);
            mergeSort(arr, mid + 1, right, temp);
            
            if (arr[mid] <= arr[mid + 1]) {
                return;
            }
            
            merge(arr, left, mid, right, temp);
        }
    }
    
    private static void merge(int[] arr, int left, int mid, int right, int[] temp) {
        int i = left;
        int j = mid + 1;
        int k = 0;
        
        while (i <= mid && j <= right) {
            if (arr[i] <= arr[j]) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
            }
        }
        
        while (i <= mid) temp[k++] = arr[i++];
        while (j <= right) temp[k++] = arr[j++];
        
        for (i = 0; i < k; i++) {
            arr[left + i] = temp[i];
        }
    }
    
    /**
     * 快速排序实现
     */
    public static int[] quickSort(int[] arr) {
        quickSort(arr, 0, arr.length - 1);
        return arr;
    }
    
    private static void quickSort(int[] arr, int left, int right) {
        if (left < right) {
            int pivot = partition(arr, left, right);
            quickSort(arr, left, pivot - 1);
            quickSort(arr, pivot + 1, right);
        }
    }
    
    private static int partition(int[] arr, int left, int right) {
        int pivot = arr[right];
        int i = left - 1;
        
        for (int j = left; j < right; j++) {
            if (arr[j] <= pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        swap(arr, i + 1, right);
        return i + 1;
    }
    
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    /**
     * 堆排序实现
     */
    public static int[] heapSort(int[] arr) {
        int n = arr.length;
        
        // 构建最大堆
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
        
        // 逐个提取元素
        for (int i = n - 1; i > 0; i--) {
            swap(arr, 0, i);
            heapify(arr, i, 0);
        }
        
        return arr;
    }
    
    private static void heapify(int[] arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        if (largest != i) {
            swap(arr, i, largest);
            heapify(arr, n, largest);
        }
    }
    
    /**
     * 归并排序的应用：求逆序对
     */
    public static long countInversions(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return 0;
        }
        
        int[] temp = arr.clone();
        return countInversions(arr, 0, arr.length - 1, temp);
    }
    
    private static long countInversions(int[] arr, int left, int right, int[] temp) {
        if (left >= right) {
            return 0;
        }
        
        int mid = left + (right - left) / 2;
        long inversions = 0;
        
        inversions += countInversions(temp, left, mid, arr);
        inversions += countInversions(temp, mid + 1, right, arr);
        inversions += mergeAndCount(arr, left, mid, right, temp);
        
        return inversions;
    }
    
    private static long mergeAndCount(int[] arr, int left, int mid, int right, int[] temp) {
        int i = left;
        int j = mid + 1;
        int k = left;
        long inversions = 0;
        
        while (i <= mid && j <= right) {
            if (temp[i] <= temp[j]) {
                arr[k++] = temp[i++];
            } else {
                arr[k++] = temp[j++];
                inversions += (mid - i + 1);  // 重要：统计逆序对
            }
        }
        
        while (i <= mid) arr[k++] = temp[i++];
        while (j <= right) arr[k++] = temp[j++];
        
        return inversions;
    }
    
    /**
     * 生成随机数组
     */
    public static int[] generateRandomArray(int size, int maxValue) {
        int[] arr = new int[size];
        Random random = new Random();
        
        for (int i = 0; i < size; i++) {
            arr[i] = random.nextInt(maxValue);
        }
        
        return arr;
    }
    
    public static void main(String[] args) {
        // 统计信息演示
        System.out.println("=== 归并排序统计信息 ===");
        
        int[] testArr = generateRandomArray(100, 1000);
        SortStats stats = mergeSortWithStats(testArr.clone());
        
        System.out.println("数组大小: 100");
        System.out.println(stats);
        System.out.println("排序验证: " + isSorted(testArr));
        
        // 求逆序对
        System.out.println("\n=== 求逆序对数量 ===");
        int[] arr = {2, 4, 1, 3, 5};
        System.out.println("数组: " + Arrays.toString(arr));
        
        long inversions = countInversions(arr.clone());
        System.out.println("逆序对数量: " + inversions);
        System.out.println("排序后: " + Arrays.toString(arr));
        
        // 与快速排序比较
        System.out.println("\n=== 与快速排序比较（随机数组） ===");
        int[] randomArr = generateRandomArray(10000, 100000);
        
        long startTime = System.nanoTime();
        int[] mergeResult = mergeSort(randomArr.clone());
        long mergeTime = System.nanoTime() - startTime;
        
        startTime = System.nanoTime();
        int[] quickResult = quickSort(randomArr.clone());
        long quickTime = System.nanoTime() - startTime;
        
        System.out.println("归并排序用时: " + mergeTime / 1_000_000 + " ms");
        System.out.println("快速排序用时: " + quickTime / 1_000_000 + " ms");
        System.out.println("结果一致: " + Arrays.equals(mergeResult, quickResult));
        
        // 与快速排序比较（已排序数组）
        System.out.println("\n=== 与快速排序比较（已排序数组） ===");
        int[] sortedArr = new int[10000];
        for (int i = 0; i < sortedArr.length; i++) {
            sortedArr[i] = i;
        }
        
        startTime = System.nanoTime();
        mergeSort(sortedArr.clone());
        long mergeTimeSorted = System.nanoTime() - startTime;
        
        startTime = System.nanoTime();
        quickSort(sortedArr.clone());
        long quickTimeSorted = System.nanoTime() - startTime;
        
        System.out.println("归并排序用时: " + mergeTimeSorted / 1_000_000 + " ms");
        System.out.println("快速排序用时: " + quickTimeSorted / 1_000_000 + " ms");
    }
    
    private static boolean isSorted(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] < arr[i - 1]) {
                return false;
            }
        }
        return true;
    }
}
```

## 归并排序的应用场景

### 1. 实际应用示例

```
import java.util.Arrays;

public class MergeSortApplications {
    
    /**
     * 外部排序：处理大文件
     * 模拟将大文件分块排序后合并
     */
    static class ExternalSortSimulation {
        public static void externalSort(int[] data, int blockSize) {
            int n = data.length;
            
            // 1. 分块排序
            for (int i = 0; i < n; i += blockSize) {
                int end = Math.min(i + blockSize, n);
                Arrays.sort(data, i, end);
                System.out.println("排序块 [" + i + ", " + (end-1) + "]: " + 
                    Arrays.toString(Arrays.copyOfRange(data, i, end)));
            }
            
            // 2. 多路归并
            int[] temp = new int[n];
            kWayMerge(data, temp, blockSize);
            
            // 3. 复制回原数组
            System.arraycopy(temp, 0, data, 0, n);
        }
        
        private static void kWayMerge(int[] data, int[] temp, int blockSize) {
            int n = data.length;
            int k = (n + blockSize - 1) / blockSize;  // 块数
            
            // 每块的起始索引
            int[] starts = new int[k];
            int[] ends = new int[k];
            
            for (int i = 0; i < k; i++) {
                starts[i] = i * blockSize;
                ends[i] = Math.min((i + 1) * blockSize, n);
            }
            
            // 多路归并
            for (int idx = 0; idx < n; idx++) {
                int minVal = Integer.MAX_VALUE;
                int minBlock = -1;
                
                // 找到所有块中的最小值
                for (int i = 0; i < k; i++) {
                    if (starts[i] < ends[i] && data[starts[i]] < minVal) {
                        minVal = data[starts[i]];
                        minBlock = i;
                    }
                }
                
                if (minBlock == -1) {
                    break;
                }
                
                temp[idx] = minVal;
                starts[minBlock]++;
            }
        }
    }
    
    /**
     * 链表排序
     */
    static class LinkedListMergeSort {
        static class ListNode {
            int val;
            ListNode next;
            
            ListNode(int val) {
                this.val = val;
                this.next = null;
            }
            
            static ListNode fromArray(int[] arr) {
                if (arr == null || arr.length == 0) {
                    return null;
                }
                
                ListNode head = new ListNode(arr[0]);
                ListNode current = head;
                
                for (int i = 1; i < arr.length; i++) {
                    current.next = new ListNode(arr[i]);
                    current = current.next;
                }
                
                return head;
            }
            
            static int[] toArray(ListNode head) {
                int size = 0;
                ListNode current = head;
                while (current != null) {
                    size++;
                    current = current.next;
                }
                
                int[] arr = new int[size];
                current = head;
                for (int i = 0; i < size; i++) {
                    arr[i] = current.val;
                    current = current.next;
                }
                
                return arr;
            }
        }
        
        public static ListNode sortList(ListNode head) {
            if (head == null || head.next == null) {
                return head;
            }
            
            // 找到中间节点
            ListNode mid = getMiddle(head);
            ListNode nextOfMid = mid.next;
            
            // 分割链表
            mid.next = null;
            
            // 递归排序
            ListNode left = sortList(head);
            ListNode right = sortList(nextOfMid);
            
            // 合并
            return merge(left, right);
        }
        
        private static ListNode getMiddle(ListNode head) {
            if (head == null) {
                return null;
            }
            
            ListNode slow = head;
            ListNode fast = head.next;
            
            while (fast != null && fast.next != null) {
                slow = slow.next;
                fast = fast.next.next;
            }
            
            return slow;
        }
        
        private static ListNode merge(ListNode left, ListNode right) {
            ListNode dummy = new ListNode(0);
            ListNode current = dummy;
            
            while (left != null && right != null) {
                if (left.val <= right.val) {
                    current.next = left;
                    left = left.next;
                } else {
                    current.next = right;
                    right = right.next;
                }
                current = current.next;
            }
            
            if (left != null) {
                current.next = left;
            } else {
                current.next = right;
            }
            
            return dummy.next;
        }
    }
    
    /**
     * 区间合并
     */
    static class IntervalMerge {
        static class Interval {
            int start;
            int end;
            
            Interval(int start, int end) {
                this.start = start;
                this.end = end;
            }
            
            @Override
            public String toString() {
                return "[" + start + ", " + end + "]";
            }
        }
        
        public static Interval[] mergeIntervals(Interval[] intervals) {
            if (intervals == null || intervals.length <= 1) {
                return intervals;
            }
            
            // 按开始时间排序
            Arrays.sort(intervals, (a, b) -> Integer.compare(a.start, b.start));
            
            // 合并重叠区间
            Interval[] result = new Interval[intervals.length];
            int index = 0;
            result[0] = intervals[0];
            
            for (int i = 1; i < intervals.length; i++) {
                Interval current = intervals[i];
                Interval last = result[index];
                
                if (current.start <= last.end) {
                    // 重叠，合并
                    last.end = Math.max(last.end, current.end);
                } else {
                    // 不重叠，添加新区间
                    result[++index] = current;
                }
            }
            
            return Arrays.copyOf(result, index + 1);
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== 外部排序模拟 ===");
        int[] largeData = {38, 27, 43, 3, 9, 82, 10, 15, 7, 25, 50, 12, 33, 18};
        System.out.println("原始数据: " + Arrays.toString(largeData));
        
        int[] dataCopy = largeData.clone();
        ExternalSortSimulation.externalSort(dataCopy, 4);
        System.out.println("外部排序后: " + Arrays.toString(dataCopy));
        
        System.out.println("\n=== 链表归并排序 ===");
        int[] listData = {4, 2, 1, 3, 5};
        System.out.println("原始链表数据: " + Arrays.toString(listData));
        
        LinkedListMergeSort.ListNode list = LinkedListMergeSort.ListNode.fromArray(listData);
        LinkedListMergeSort.ListNode sortedList = LinkedListMergeSort.sortList(list);
        int[] sortedArray = LinkedListMergeSort.ListNode.toArray(sortedList);
        System.out.println("排序后: " + Arrays.toString(sortedArray));
        
        System.out.println("\n=== 区间合并 ===");
        IntervalMerge.Interval[] intervals = {
            new IntervalMerge.Interval(1, 3),
            new IntervalMerge.Interval(2, 6),
            new IntervalMerge.Interval(8, 10),
            new IntervalMerge.Interval(15, 18)
        };
        
        System.out.println("原始区间: " + Arrays.toString(intervals));
        IntervalMerge.Interval[] merged = IntervalMerge.mergeIntervals(intervals);
        System.out.println("合并后区间: " + Arrays.toString(merged));
    }
}
```

## 总结

### 归并排序的优缺点

**优点：**

1. **稳定时间复杂度**：始终为O(n log n)，不受输入数据影响
    
2. **稳定性**：保持相等元素的相对顺序
    
3. **适合外部排序**：可以处理无法全部加载到内存的大数据
    
4. **适合链表排序**：不需要随机访问，适合链表数据结构
    
5. **并行化容易**：天然适合并行计算，可以多线程/多进程处理
    

**缺点：**

1. **额外空间**：需要O(n)的额外空间
    
2. **不是原地排序**：需要复制数据
    
3. **小数组效率不高**：递归开销大，对小数组不如插入排序
    
4. **常数因子较大**：实际运行时间可能比其他O(n log n)算法慢
    

### 与快速排序、堆排序的比较

|特性|归并排序|快速排序|堆排序|
|---|---|---|---|
|**时间复杂度**​|O(n log n)|平均O(n log n)，最坏O(n²)|O(n log n)|
|**空间复杂度**​|O(n)|O(log n)~O(n)|O(1)|
|**稳定性**​|稳定|不稳定|不稳定|
|**原地排序**​|否|是|是|
|**最佳适用场景**​|链表、外部排序、需要稳定性|通用排序、内存排序|内存有限、需要原地排序|
|**递归深度**​|O(log n)|O(log n)~O(n)|O(1) 迭代|

### 使用建议

1. **需要稳定排序**时选择归并排序
    
2. **排序链表**时选择归并排序
    
3. **外部排序**（大文件）时选择归并排序
    
4. **内存充足**且对性能要求稳定时选择归并排序
    
5. **小规模数据**可结合插入排序优化
    
6. **并行计算**时可利用归并排序的天然可分性
    

### 优化技巧

1. **小数组切换**：当子数组小于阈值时使用插入排序
    
2. **检查有序性**：合并前检查是否已有序
    
3. **避免复制**：交替使用原数组和临时数组
    
4. **自然归并**：利用已有有序序列
    
5. **迭代实现**：避免递归开销
    
6. **多路归并**：适用于外部排序
    

### 学习价值

归并排序是理解**分治法**思想的经典案例，它展示了：

1. 如何将大问题分解为小问题
    
2. 如何递归解决问题
    
3. 如何合并子问题的解
    
4. 时间复杂度的分析方法
    
5. 稳定排序的实现方法
    
6. 外部排序的基本原理
    

归并排序不仅是重要的排序算法，其思想也广泛应用于其他领域，如大数据处理、数据库索引、并行计算等。理解归并排序对于学习更高级的算法和数据结构具有重要意义。