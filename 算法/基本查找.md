# Java算法：基本查找

## 定义

基本查找（也称顺序查找或线性查找）是最简单直观的查找算法。其核心思想是**从数据结构的一端开始，按顺序检查每个元素，直到找到目标值或遍历完所有元素**。

### 特点

- **时间复杂度**：O(n)，最坏情况需要检查所有n个元素
    
- **空间复杂度**：O(1)，只需要常数级的额外空间
    
- **优点**：实现简单，对数据结构无特殊要求（无需排序）
    
- **缺点**：效率较低，不适合大规模数据
    

## 基本查找示例

### 1. 数组顺序查找(循环遍历)

```
/**
 * 在整数数组中查找指定元素
 * @param arr 目标数组
 * @param target 要查找的值
 * @return 目标值的索引，未找到返回-1
 */
public static int sequentialSearch(int[] arr, int target) {
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == target) {
            return i;  // 找到目标，返回索引
        }
    }
    return -1;  // 未找到
}
```

### 2. 使用for-each循环的查找(循环遍历)

```
public static int sequentialSearchForEach(int[] arr, int target) {
    int index = 0;
    for (int num : arr) {
        if (num == target) {
            return index;
        }
        index++;
    }
    return -1;
}
```

### 3. 在字符串数组中查找(循环遍历)

```
public static int searchString(String[] arr, String target) {
    for (int i = 0; i < arr.length; i++) {
        if (arr[i].equals(target)) {
            return i;
        }
    }
    return -1;
}
```

### 4. 查找自定义对象

```
class Person {
    String name;
    int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Person person = (Person) obj;
        return age == person.age && name.equals(person.name);
    }
}

public static int searchPerson(Person[] people, Person target) {
    for (int i = 0; i < people.length; i++) {
        if (people[i].equals(target)) {
            return i;
        }
    }
    return -1;
}
```

## 完整示例代码

```
public class BasicSearchExample {
    
    public static void main(String[] args) {
        // 示例1：整数数组查找
        int[] numbers = {5, 3, 8, 1, 9, 2, 7};
        int target = 9;
        
        int result = sequentialSearch(numbers, target);
        System.out.println("查找 " + target + " 的结果: " + 
                          (result != -1 ? "找到，索引为 " + result : "未找到"));
        
        // 示例2：字符串数组查找
        String[] fruits = {"apple", "banana", "orange", "grape"};
        String fruitTarget = "orange";
        
        int fruitResult = searchString(fruits, fruitTarget);
        System.out.println("查找 \"" + fruitTarget + "\" 的结果: " + 
                          (fruitResult != -1 ? "找到，索引为 " + fruitResult : "未找到"));
    }
    
    /**
     * 基本顺序查找算法
     */
    public static int sequentialSearch(int[] arr, int target) {
        // 边界检查
        if (arr == null || arr.length == 0) {
            return -1;
        }
        
        // 顺序遍历查找
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i;
            }
        }
        
        return -1;
    }
    
    /**
     * 查找字符串数组
     */
    public static int searchString(String[] arr, String target) {
        if (arr == null || target == null) {
            return -1;
        }
        
        for (int i = 0; i < arr.length; i++) {
            if (arr[i].equals(target)) {
                return i;
            }
        }
        
        return -1;
    }
}
```

## 查找算法的变体

### 1. 查找最大值/最小值

```
/**
 * 查找数组中的最大值
 */
public static int findMax(int[] arr) {
    if (arr == null || arr.length == 0) {
        throw new IllegalArgumentException("数组不能为空");
    }
    
    int max = arr[0];
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
}

/**
 * 查找数组中的最小值
 */
public static int findMin(int[] arr) {
    if (arr == null || arr.length == 0) {
        throw new IllegalArgumentException("数组不能为空");
    }
    
    int min = arr[0];
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] < min) {
            min = arr[i];
        }
    }
    return min;
}
```

### 2. 查找所有匹配项

```
/**
 * 查找所有匹配项的索引
 */
public static List<Integer> findAllOccurrences(int[] arr, int target) {
    List<Integer> indices = new ArrayList<>();
    
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == target) {
            indices.add(i);
        }
    }
    
    return indices;
}
```

## 性能分析

|情况|比较次数|说明|
|---|---|---|
|最好情况|1|目标在第一个位置|
|最坏情况|n|目标在最后一个位置或不存在|
|平均情况|n/2|目标在任意位置的概率相等|

## 应用场景

基本查找适用于以下情况：

1. **小规模数据集**
    
2. **无序数据集合**
    
3. **只查找一次**的情况
    
4. **实现简单性**比效率更重要时
    

## 扩展：哨兵优化

```
/**
 * 使用哨兵优化的顺序查找
 * 减少循环中的比较次数
 */
public static int sentinelSearch(int[] arr, int target) {
    if (arr == null || arr.length == 0) {
        return -1;
    }
    
    // 将目标值放在数组末尾作为哨兵
    int lastValue = arr[arr.length - 1];
    arr[arr.length - 1] = target;
    
    int i = 0;
    while (arr[i] != target) {
        i++;
    }
    
    // 恢复原数组
    arr[arr.length - 1] = lastValue;
    
    // 判断是否找到
    if (i < arr.length - 1 || arr[arr.length - 1] == target) {
        return i;
    }
    
    return -1;
}
```

## 总结

基本查找是最基础的查找算法，虽然效率不高，但其简单性和通用性使其在以下情况仍有价值：

1. 教学和算法理解
    
2. 小规模数据处理
    
3. 作为更复杂算法的组成部分
    
4. 快速原型开发
    

对于大规模数据或需要频繁查找的场景，建议使用更高效的查找算法，如二分查找、哈希查找等。