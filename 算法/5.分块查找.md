# Java算法：分块查找

## 定义

**分块查找**（Block Search）又称**索引顺序查找**，是一种结合了**顺序查找**和**二分查找**优点的查找算法。它将数据分成若干块，块内无序但块间有序，通过建立索引表来快速定位目标值所在的块。

### 核心思想

1. **分块**：将数据元素划分为若干块，块内元素可以无序
    
2. **块间有序**：每一块的最大（或最小）值构成一个有序的索引表
    
3. **二级查找**：先在索引表中查找目标块，再在块内顺序查找
    

### 特点

|特性|描述|
|---|---|
|**时间复杂度**​|平均O(√n)，最坏O(n)|
|**空间复杂度**​|O(m)，m为块数|
|**优点**​|适合动态数据，插入删除方便|
|**缺点**​|需要额外存储索引表|
|**适用场景**​|数据量大且分布不均匀，需要频繁插入删除|

## 算法原理

### 基本概念

```
原始数据: [2, 6, 5, 12, 9, 8, 13, 15, 17, 20, 25, 23, 30, 28, 33, 31, 36, 39, 40, 35]

分块后（每块5个元素）：
块1: [2, 6, 5, 8, 9]    最大值: 9
块2: [12, 13, 15, 17, 20] 最大值: 20
块3: [25, 23, 30, 28, 31] 最大值: 31
块4: [33, 36, 39, 40, 35] 最大值: 40

索引表：
块号 | 块最大值 | 起始位置
1    | 12      | 0
2    | 20      | 5
3    | 33      | 10
4    | 40      | 15
```

### 查找步骤

1. 在索引表中查找目标值可能所在的块
    
2. 在对应块内进行顺序查找
    
3. 返回结果或未找到
    

## Java实现示例

### 1. 基础分块查找

```
import java.util.*;

public class BlockSearch {
    
    /**
     * 分块查找算法
     * @param arr 原始数组
     * @param blockSize 每块大小
     * @param target 目标值
     * @return 目标值的索引，未找到返回-1
     */
    public static int blockSearch(int[] arr, int blockSize, int target) {
        if (arr == null || arr.length == 0 || blockSize <= 0) {
            return -1;
        }
        
        int n = arr.length;
        int blockCount = (int) Math.ceil((double) n / blockSize);
        
        // 1. 创建索引表
        int[] maxValues = new int[blockCount];
        int[] startIndices = new int[blockCount];
        
        for (int i = 0; i < blockCount; i++) {
            int start = i * blockSize;
            int end = Math.min(start + blockSize, n);
            int max = Integer.MIN_VALUE;
            
            // 找到当前块的最大值
            for (int j = start; j < end; j++) {
                if (arr[j] > max) {
                    max = arr[j];
                }
            }
            
            maxValues[i] = max;
            startIndices[i] = start;
        }
        
        System.out.println("索引表:");
        for (int i = 0; i < blockCount; i++) {
            System.out.println("块" + (i+1) + ": 最大值=" + maxValues[i] + 
                             ", 起始位置=" + startIndices[i]);
        }
        
        // 2. 在索引表中查找目标块
        int blockIndex = -1;
        for (int i = 0; i < blockCount; i++) {
            if (target <= maxValues[i]) {
                blockIndex = i;
                break;
            }
        }
        
        // 如果目标值大于所有块的最大值
        if (blockIndex == -1) {
            return -1;
        }
        
        // 3. 在目标块内顺序查找
        int start = startIndices[blockIndex];
        int end = Math.min(start + blockSize, n);
        
        System.out.println("目标值 " + target + " 可能在块" + (blockIndex+1) + 
                         " [索引" + start + "到" + (end-1) + "]");
        
        for (int i = start; i < end; i++) {
            if (arr[i] == target) {
                return i;
            }
        }
        
        return -1;  // 在块内未找到
    }
    
    public static void main(String[] args) {
        int[] arr = {2, 6, 5, 12, 9, 8, 13, 15, 17, 20, 
                    25, 23, 30, 28, 33, 31, 36, 39, 40, 35};
        int blockSize = 5;
        int target = 28;
        
        System.out.println("原始数组: " + Arrays.toString(arr));
        System.out.println("块大小: " + blockSize);
        System.out.println("查找目标: " + target);
        
        int index = blockSearch(arr, blockSize, target);
        
        if (index != -1) {
            System.out.println("找到目标值，索引: " + index);
        } else {
            System.out.println("未找到目标值");
        }
    }
}
```

### 2. 增强分块查找（带详细信息）

```
import java.util.*;

public class EnhancedBlockSearch {
    
    /**
     * 块信息类
     */
    static class Block {
        int blockId;
        int maxValue;
        int minValue;
        int startIndex;
        int endIndex;
        
        Block(int blockId, int maxValue, int minValue, int startIndex, int endIndex) {
            this.blockId = blockId;
            this.maxValue = maxValue;
            this.minValue = minValue;
            this.startIndex = startIndex;
            this.endIndex = endIndex;
        }
        
        boolean contains(int value) {
            return value >= minValue && value <= maxValue;
        }
        
        @Override
        public String toString() {
            return String.format("块%d: 值范围[%d, %d], 索引[%d, %d]", 
                                blockId, minValue, maxValue, startIndex, endIndex-1);
        }
    }
    
    /**
     * 分块查找结果类
     */
    static class SearchResult {
        boolean found;
        int index;
        int blockId;
        int comparisons;
        String message;
        
        SearchResult(boolean found, int index, int blockId, int comparisons, String message) {
            this.found = found;
            this.index = index;
            this.blockId = blockId;
            this.comparisons = comparisons;
            this.message = message;
        }
        
        @Override
        public String toString() {
            return String.format("找到: %b, 索引: %d, 块: %d, 比较次数: %d\n消息: %s",
                                found, index, blockId, comparisons, message);
        }
    }
    
    /**
     * 增强的分块查找算法
     */
    public static SearchResult enhancedBlockSearch(int[] arr, int blockSize, int target) {
        int comparisons = 0;
        
        if (arr == null || arr.length == 0) {
            return new SearchResult(false, -1, -1, comparisons, "数组为空");
        }
        
        if (blockSize <= 0) {
            return new SearchResult(false, -1, -1, comparisons, "块大小必须大于0");
        }
        
        int n = arr.length;
        int blockCount = (int) Math.ceil((double) n / blockSize);
        
        System.out.println("=== 分块查找开始 ===");
        System.out.println("数组长度: " + n);
        System.out.println("块大小: " + blockSize);
        System.out.println("块数量: " + blockCount);
        System.out.println("目标值: " + target);
        System.out.println();
        
        // 1. 创建块信息
        List<Block> blocks = new ArrayList<>();
        
        for (int i = 0; i < blockCount; i++) {
            int start = i * blockSize;
            int end = Math.min(start + blockSize, n);
            int max = Integer.MIN_VALUE;
            int min = Integer.MAX_VALUE;
            
            for (int j = start; j < end; j++) {
                if (arr[j] > max) max = arr[j];
                if (arr[j] < min) min = arr[j];
            }
            
            blocks.add(new Block(i+1, max, min, start, end));
        }
        
        // 输出块信息
        System.out.println("生成的块信息:");
        for (Block block : blocks) {
            System.out.println(block);
        }
        System.out.println();
        
        // 2. 在索引中查找目标块
        System.out.println("步骤1: 查找目标块");
        Block targetBlock = null;
        
        for (Block block : blocks) {
            comparisons++;
            System.out.println("检查" + block + " 是否包含 " + target);
            
            if (block.contains(target)) {
                targetBlock = block;
                System.out.println("√ 目标值可能在" + block);
                break;
            }
        }
        
        if (targetBlock == null) {
            String msg = "目标值 " + target + " 不在任何块中";
            System.out.println(msg);
            return new SearchResult(false, -1, -1, comparisons, msg);
        }
        
        // 3. 在目标块内顺序查找
        System.out.println("\n步骤2: 在块内查找");
        System.out.println("在块" + targetBlock.blockId + "内顺序查找");
        
        for (int i = targetBlock.startIndex; i < targetBlock.endIndex; i++) {
            comparisons++;
            System.out.println("比较 arr[" + i + "] = " + arr[i] + " 和 " + target);
            
            if (arr[i] == target) {
                String msg = "在块" + targetBlock.blockId + "中找到目标值";
                System.out.println("√ " + msg);
                return new SearchResult(true, i, targetBlock.blockId, comparisons, msg);
            }
        }
        
        String msg = "在块" + targetBlock.blockId + "中未找到目标值";
        System.out.println(msg);
        return new SearchResult(false, -1, targetBlock.blockId, comparisons, msg);
    }
    
    public static void main(String[] args) {
        int[] arr = {3, 8, 2, 10, 6, 15, 12, 18, 20, 14, 
                    25, 22, 30, 28, 35, 33, 40, 38, 45, 42};
        
        int target = 28;
        int blockSize = 4;
        
        System.out.println("原始数组: " + Arrays.toString(arr));
        System.out.println();
        
        SearchResult result = enhancedBlockSearch(arr, blockSize, target);
        System.out.println("\n=== 查找结果 ===");
        System.out.println(result);
        
        // 测试多个查找
        System.out.println("\n=== 多目标测试 ===");
        int[] targets = {3, 15, 28, 50, 10};
        for (int t : targets) {
            System.out.println("\n查找目标: " + t);
            SearchResult r = enhancedBlockSearch(arr, blockSize, t);
            System.out.println("结果: " + (r.found ? "找到，索引" + r.index : "未找到"));
        }
    }
}
```

### 3. 动态分块查找（自适应块大小）

```
import java.util.*;

public class DynamicBlockSearch {
    
    /**
     * 动态块结构
     */
    static class DynamicBlock {
        List<Integer> elements = new ArrayList<>();
        int maxValue = Integer.MIN_VALUE;
        int minValue = Integer.MAX_VALUE;
        
        void add(int value) {
            elements.add(value);
            if (value > maxValue) maxValue = value;
            if (value < minValue) minValue = value;
        }
        
        boolean contains(int value) {
            return value >= minValue && value <= maxValue;
        }
        
        int size() {
            return elements.size();
        }
        
        int get(int index) {
            return elements.get(index);
        }
        
        @Override
        public String toString() {
            return String.format("块: 元素数=%d, 范围[%d, %d], 内容=%s", 
                                elements.size(), minValue, maxValue, elements);
        }
    }
    
    /**
     * 动态分块查找
     * 根据数据分布自动分块
     */
    public static int dynamicBlockSearch(int[] arr, int target) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        
        // 1. 对数组排序并分块
        int[] sortedArr = arr.clone();
        Arrays.sort(sortedArr);
        
        System.out.println("排序后数组: " + Arrays.toString(sortedArr));
        
        // 自动计算块大小（使用平方根作为参考）
        int blockSize = (int) Math.sqrt(sortedArr.length);
        if (blockSize < 1) blockSize = 1;
        
        int blockCount = (int) Math.ceil((double) sortedArr.length / blockSize);
        
        // 2. 创建动态块
        List<DynamicBlock> blocks = new ArrayList<>();
        
        for (int i = 0; i < blockCount; i++) {
            blocks.add(new DynamicBlock());
        }
        
        // 3. 分配元素到块
        for (int i = 0; i < sortedArr.length; i++) {
            int blockIndex = i / blockSize;
            blocks.get(blockIndex).add(sortedArr[i]);
        }
        
        // 输出块信息
        System.out.println("\n自动分块结果 (块大小≈√n=" + blockSize + "):");
        for (int i = 0; i < blocks.size(); i++) {
            System.out.println("块" + (i+1) + ": " + blocks.get(i));
        }
        
        // 4. 查找目标块
        DynamicBlock targetBlock = null;
        int targetBlockIndex = -1;
        
        for (int i = 0; i < blocks.size(); i++) {
            DynamicBlock block = blocks.get(i);
            if (block.contains(target)) {
                targetBlock = block;
                targetBlockIndex = i;
                break;
            }
        }
        
        if (targetBlock == null) {
            System.out.println("\n目标值 " + target + " 不在任何块中");
            return -1;
        }
        
        System.out.println("\n目标值 " + target + " 可能在块" + (targetBlockIndex+1));
        
        // 5. 在块内顺序查找
        for (int i = 0; i < targetBlock.size(); i++) {
            if (targetBlock.get(i) == target) {
                // 需要在原始数组中查找索引
                for (int j = 0; j < arr.length; j++) {
                    if (arr[j] == target) {
                        return j;
                    }
                }
            }
        }
        
        return -1;
    }
    
    /**
     * 优化分块：根据数据分布自适应分块
     */
    public static int adaptiveBlockSearch(int[] arr, int target) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        
        // 分析数据分布
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;
        
        for (int num : arr) {
            if (num < min) min = num;
            if (num > max) max = num;
        }
        
        int range = max - min + 1;
        int blockCount = (int) Math.sqrt(arr.length);
        if (blockCount < 1) blockCount = 1;
        
        int blockRange = (int) Math.ceil((double) range / blockCount);
        
        System.out.println("数据范围: [" + min + ", " + max + "]");
        System.out.println("数据跨度: " + range);
        System.out.println("分块数: " + blockCount);
        System.out.println("每块值跨度: " + blockRange);
        
        // 创建块索引
        Map<Integer, List<Integer>> blockMap = new HashMap<>();
        for (int i = 0; i < blockCount; i++) {
            blockMap.put(i, new ArrayList<>());
        }
        
        // 分配元素到块
        for (int i = 0; i < arr.length; i++) {
            int value = arr[i];
            int blockIndex = (value - min) / blockRange;
            if (blockIndex >= blockCount) blockIndex = blockCount - 1;
            
            blockMap.get(blockIndex).add(i);  // 存储原始索引
        }
        
        // 输出块信息
        System.out.println("\n自适应分块结果:");
        for (int i = 0; i < blockCount; i++) {
            List<Integer> indices = blockMap.get(i);
            if (!indices.isEmpty()) {
                List<Integer> values = new ArrayList<>();
                for (int idx : indices) {
                    values.add(arr[idx]);
                }
                int blockMin = values.stream().min(Integer::compare).orElse(0);
                int blockMax = values.stream().max(Integer::compare).orElse(0);
                System.out.printf("块%d: 值范围[%d, %d], 元素数=%d, 元素=%s%n", 
                                 i+1, blockMin, blockMax, values.size(), values);
            }
        }
        
        // 查找目标块
        int targetBlockIndex = (target - min) / blockRange;
        if (targetBlockIndex >= blockCount) targetBlockIndex = blockCount - 1;
        
        System.out.println("\n目标值 " + target + " 可能在块" + (targetBlockIndex+1));
        
        // 在目标块内查找
        List<Integer> targetIndices = blockMap.get(targetBlockIndex);
        if (targetIndices != null) {
            for (int index : targetIndices) {
                if (arr[index] == target) {
                    return index;
                }
            }
        }
        
        return -1;
    }
    
    public static void main(String[] args) {
        int[] arr = {15, 8, 3, 25, 12, 30, 5, 20, 10, 28, 
                    18, 7, 22, 14, 35, 2, 40, 1, 33, 6};
        
        System.out.println("原始数组: " + Arrays.toString(arr));
        System.out.println("数组长度: " + arr.length);
        
        int target = 28;
        System.out.println("\n=== 方法1: 动态分块查找 ===");
        int index1 = dynamicBlockSearch(arr, target);
        System.out.println("结果: " + (index1 != -1 ? "找到，索引" + index1 : "未找到"));
        
        System.out.println("\n=== 方法2: 自适应分块查找 ===");
        int index2 = adaptiveBlockSearch(arr, target);
        System.out.println("结果: " + (index2 != -1 ? "找到，索引" + index2 : "未找到"));
    }
}
```

### 4. 完整分块查找系统

```
import java.util.*;

public class BlockSearchSystem {
    
    /**
     * 块索引条目
     */
    static class BlockIndexEntry {
        int blockId;
        int maxValue;
        int minValue;
        int startIndex;
        int endIndex;
        
        BlockIndexEntry(int blockId, int maxValue, int minValue, int startIndex, int endIndex) {
            this.blockId = blockId;
            this.maxValue = maxValue;
            this.minValue = minValue;
            this.startIndex = startIndex;
            this.endIndex = endIndex;
        }
        
        boolean contains(int value) {
            return value >= minValue && value <= maxValue;
        }
        
        @Override
        public String toString() {
            return String.format("块%-2d: 索引[%3d-%-3d] 值范围[%3d, %3d]", 
                                blockId, startIndex, endIndex-1, minValue, maxValue);
        }
    }
    
    /**
     * 分块查找器
     */
    static class BlockSearcher {
        private int[] data;
        private int blockSize;
        private List<BlockIndexEntry> indexTable;
        
        public BlockSearcher(int[] data, int blockSize) {
            this.data = data;
            this.blockSize = blockSize;
            this.indexTable = buildIndex();
        }
        
        /**
         * 构建索引表
         */
        private List<BlockIndexEntry> buildIndex() {
            List<BlockIndexEntry> index = new ArrayList<>();
            int n = data.length;
            int blockCount = (int) Math.ceil((double) n / blockSize);
            
            for (int i = 0; i < blockCount; i++) {
                int start = i * blockSize;
                int end = Math.min(start + blockSize, n);
                int max = Integer.MIN_VALUE;
                int min = Integer.MAX_VALUE;
                
                for (int j = start; j < end; j++) {
                    int value = data[j];
                    if (value > max) max = value;
                    if (value < min) min = value;
                }
                
                index.add(new BlockIndexEntry(i+1, max, min, start, end));
            }
            
            return index;
        }
        
        /**
         * 查找目标值
         */
        public SearchResult search(int target) {
            int comparisons = 0;
            String process = "开始查找 " + target + "\n";
            
            // 1. 在索引表中查找目标块
            BlockIndexEntry targetBlock = null;
            process += "在索引表中查找目标块:\n";
            
            for (BlockIndexEntry entry : indexTable) {
                comparisons++;
                process += String.format("  比较: 目标值%d, 块%d范围[%d, %d] ", 
                                       target, entry.blockId, entry.minValue, entry.maxValue);
                
                if (entry.contains(target)) {
                    targetBlock = entry;
                    process += "→ 匹配\n";
                    break;
                } else {
                    process += "→ 不匹配\n";
                }
            }
            
            if (targetBlock == null) {
                process += "目标值不在任何块中\n";
                return new SearchResult(false, -1, -1, comparisons, process);
            }
            
            process += String.format("目标值可能在块%d [索引%d-%d]\n", 
                                   targetBlock.blockId, targetBlock.startIndex, targetBlock.endIndex-1);
            
            // 2. 在块内顺序查找
            process += "在块内顺序查找:\n";
            for (int i = targetBlock.startIndex; i < targetBlock.endIndex; i++) {
                comparisons++;
                process += String.format("  比较: data[%d]=%d, 目标值=%d ", i, data[i], target);
                
                if (data[i] == target) {
                    process += "→ 找到!\n";
                    return new SearchResult(true, i, targetBlock.blockId, comparisons, process);
                } else {
                    process += "→ 不匹配\n";
                }
            }
            
            process += "在块内未找到目标值\n";
            return new SearchResult(false, -1, targetBlock.blockId, comparisons, process);
        }
        
        /**
         * 插入新元素
         */
        public boolean insert(int value) {
            // 找到应该插入的块
            for (BlockIndexEntry entry : indexTable) {
                if (value <= entry.maxValue) {
                    // 扩展数组
                    int[] newData = new int[data.length + 1];
                    System.arraycopy(data, 0, newData, 0, entry.startIndex);
                    newData[entry.startIndex] = value;
                    System.arraycopy(data, entry.startIndex, newData, entry.startIndex + 1, 
                                   data.length - entry.startIndex);
                    
                    data = newData;
                    
                    // 更新索引
                    indexTable = buildIndex();
                    return true;
                }
            }
            
            // 插入到最后
            int[] newData = new int[data.length + 1];
            System.arraycopy(data, 0, newData, 0, data.length);
            newData[data.length] = value;
            data = newData;
            
            indexTable = buildIndex();
            return true;
        }
        
        /**
         * 删除元素
         */
        public boolean delete(int value) {
            SearchResult result = search(value);
            if (!result.found) {
                return false;
            }
            
            // 删除元素
            int[] newData = new int[data.length - 1];
            System.arraycopy(data, 0, newData, 0, result.index);
            System.arraycopy(data, result.index + 1, newData, result.index, 
                           data.length - result.index - 1);
            
            data = newData;
            
            // 更新索引
            indexTable = buildIndex();
            return true;
        }
        
        /**
         * 显示索引表
         */
        public void displayIndexTable() {
            System.out.println("=== 索引表 ===");
            System.out.println("块大小: " + blockSize);
            System.out.println("总元素数: " + data.length);
            System.out.println("块数量: " + indexTable.size());
            System.out.println();
            
            for (BlockIndexEntry entry : indexTable) {
                System.out.println(entry);
                
                // 显示块内元素
                System.out.print("  元素: ");
                for (int i = entry.startIndex; i < entry.endIndex; i++) {
                    System.out.print(data[i] + " ");
                }
                System.out.println();
            }
        }
        
        /**
         * 显示数据
         */
        public void displayData() {
            System.out.println("数据 (" + data.length + " 个元素):");
            for (int i = 0; i < data.length; i++) {
                System.out.printf("%4d", data[i]);
                if ((i + 1) % 10 == 0) {
                    System.out.println();
                }
            }
            System.out.println();
        }
    }
    
    /**
     * 查找结果
     */
    static class SearchResult {
        boolean found;
        int index;
        int blockId;
        int comparisons;
        String process;
        
        SearchResult(boolean found, int index, int blockId, int comparisons, String process) {
            this.found = found;
            this.index = index;
            this.blockId = blockId;
            this.comparisons = comparisons;
            this.process = process;
        }
        
        @Override
        public String toString() {
            return String.format("找到: %s\n索引: %d\n块: %d\n比较次数: %d\n\n查找过程:\n%s",
                                found ? "是" : "否", index, blockId, comparisons, process);
        }
    }
    
    public static void main(String[] args) {
        int[] data = {9, 22, 5, 18, 13, 30, 8, 25, 16, 11,
                     28, 3, 20, 7, 24, 15, 32, 1, 26, 19};
        
        System.out.println("=== 分块查找系统演示 ===");
        
        // 创建分块查找器
        BlockSearcher searcher = new BlockSearcher(data, 5);
        
        // 显示初始状态
        searcher.displayData();
        searcher.displayIndexTable();
        
        // 测试查找
        System.out.println("\n=== 测试查找 ===");
        int[] testValues = {13, 20, 35, 1, 24};
        
        for (int value : testValues) {
            System.out.println("\n查找值: " + value);
            SearchResult result = searcher.search(value);
            System.out.println("结果: " + (result.found ? "找到，索引" + result.index : "未找到"));
            System.out.println("比较次数: " + result.comparisons);
        }
        
        // 测试插入
        System.out.println("\n=== 测试插入 ===");
        System.out.println("插入值: 14");
        searcher.insert(14);
        searcher.displayData();
        searcher.displayIndexTable();
        
        // 测试删除
        System.out.println("\n=== 测试删除 ===");
        System.out.println("删除值: 20");
        searcher.delete(20);
        searcher.displayData();
        searcher.displayIndexTable();
        
        // 再次查找测试
        System.out.println("\n=== 再次查找测试 ===");
        SearchResult result = searcher.search(14);
        System.out.println("查找值: 14");
        System.out.println("结果: " + (result.found ? "找到，索引" + result.index : "未找到"));
    }
}
```

## 算法性能分析

### 时间复杂度分析

1. **构建索引**：O(n)，需要遍历所有元素
    
2. **索引查找**：O(m)，m为块数
    
3. **块内查找**：O(k)，k为块大小
    
4. **总时间复杂度**：O(m + k) ≈ O(√n)（当m≈k≈√n时）
    

### 与其它查找算法的比较

|算法|平均时间复杂度|优点|缺点|适用场景|
|---|---|---|---|---|
|**顺序查找**​|O(n)|实现简单|效率低|小型无序数据|
|**二分查找**​|O(log n)|效率高|需要有序数组|静态有序数据|
|**分块查找**​|O(√n)|动态数据友好|需要额外空间|动态数据，频繁插入删除|
|**哈希查找**​|O(1)|查找最快|冲突处理，空间消耗|快速查找，不关心顺序|

### 最优块大小选择

理论上，当块数m和每块元素数k相等时，即m = k = √n时，查找效率最高。

## 实际应用场景

### 1. 数据库索引

```
// 模拟数据库记录的分块查找
class DatabaseRecord {
    int id;
    String name;
    int age;
    
    DatabaseRecord(int id, String name, int age) {
        this.id = id;
        this.name = name;
        this.age = age;
    }
}

class DatabaseBlockSearch {
    // 按ID范围分块
    Map<Integer, List<DatabaseRecord>> blocks = new TreeMap<>();
    
    void addRecord(DatabaseRecord record) {
        int blockId = record.id / 100;  // 每100个ID一个块
        blocks.computeIfAbsent(blockId, k -> new ArrayList<>()).add(record);
    }
    
    DatabaseRecord findById(int id) {
        int blockId = id / 100;
        List<DatabaseRecord> block = blocks.get(blockId);
        
        if (block != null) {
            for (DatabaseRecord record : block) {
                if (record.id == id) {
                    return record;
                }
            }
        }
        return null;
    }
}
```

### 2. 文件系统目录结构

```
// 模拟文件系统的分块查找
class FileSystemBlockSearch {
    // 按文件名首字母分块
    Map<Character, List<String>> fileIndex = new TreeMap<>();
    
    void addFile(String filename) {
        char firstChar = Character.toUpperCase(filename.charAt(0));
        fileIndex.computeIfAbsent(firstChar, k -> new ArrayList<>()).add(filename);
    }
    
    boolean findFile(String filename) {
        char firstChar = Character.toUpperCase(filename.charAt(0));
        List<String> block = fileIndex.get(firstChar);
        
        if (block != null) {
            return block.contains(filename);
        }
        return false;
    }
}
```

## 总结

分块查找是一种在特定场景下非常有效的查找算法，具有以下特点：

### 优点

1. **适合动态数据**：插入和删除操作比二分查找更高效
    
2. **块内无序**：不需要完全有序的数据
    
3. **实现简单**：逻辑清晰，易于实现
    
4. **内存效率**：可以处理磁盘等外部存储的大型数据集
    

### 缺点

1. **需要额外空间**：存储索引表
    
2. **效率不稳定**：最坏情况下可能退化为顺序查找
    
3. **块大小选择敏感**：性能受块大小影响较大
    

### 使用建议

1. 当数据量较大且需要频繁插入删除时，考虑使用分块查找
    
2. 对于静态数据，二分查找通常更优
    
3. 对于完全动态的数据，考虑使用平衡二叉搜索树或跳表
    
4. 在实际应用中，可以根据数据分布动态调整块大小
    

分块查找是算法设计中的一种重要思想，体现了"分而治之"的策略，在实际系统设计中有广泛的应用价值。