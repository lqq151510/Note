# Java算法：哈希查找

## 定义

**哈希查找**（Hash Search）是一种通过哈希函数（Hash Function）将键（Key）映射到表中位置来存储和查找数据的算法。它利用哈希表（Hash Table）数据结构，使得在理想情况下，查找、插入、删除操作的平均时间复杂度可以达到O(1)。

### 核心概念

- **哈希函数**：将任意长度的输入（键）映射为固定长度的输出（哈希值）
    
- **哈希表**：存储键值对的数据结构
    
- **冲突**：不同的键映射到同一个哈希地址的情况
    
- **负载因子**：表中已存储元素数量与表大小的比值
    

### 时间复杂度

|操作|平均情况|最坏情况|
|---|---|---|
|查找|O(1)|O(n)|
|插入|O(1)|O(n)|
|删除|O(1)|O(n)|

## 哈希冲突解决方法

### 1. 链地址法（Separate Chaining）

每个哈希桶存储一个链表，冲突的元素添加到链表中。

### 2. 开放定址法（Open Addressing）

- **线性探测**：发生冲突时，顺序查找下一个空桶
    
- **二次探测**：使用二次函数计算下一个探测位置
    
- **双重哈希**：使用第二个哈希函数计算步长
    

## Java实现示例

### 1. 链地址法实现哈希表

```
import java.util.LinkedList;

public class HashTableChaining<K, V> {
    
    // 哈希表节点
    static class HashNode<K, V> {
        K key;
        V value;
        
        HashNode(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }
    
    private LinkedList<HashNode<K, V>>[] buckets;
    private int numBuckets;  // 桶的数量
    private int size;  // 元素数量
    private final double LOAD_FACTOR_THRESHOLD = 0.7;  // 负载因子阈值
    
    public HashTableChaining() {
        this(10);  // 默认初始容量
    }
    
    @SuppressWarnings("unchecked")
    public HashTableChaining(int capacity) {
        this.numBuckets = capacity;
        this.size = 0;
        this.buckets = new LinkedList[numBuckets];
        
        for (int i = 0; i < numBuckets; i++) {
            buckets[i] = new LinkedList<>();
        }
    }
    
    /**
     * 哈希函数
     */
    private int hash(K key) {
        int hashCode = key.hashCode();
        return Math.abs(hashCode) % numBuckets;
    }
    
    /**
     * 获取键对应的值
     */
    public V get(K key) {
        int bucketIndex = hash(key);
        LinkedList<HashNode<K, V>> bucket = buckets[bucketIndex];
        
        for (HashNode<K, V> node : bucket) {
            if (node.key.equals(key)) {
                return node.value;
            }
        }
        
        return null;  // 未找到
    }
    
    /**
     * 插入键值对
     */
    public void put(K key, V value) {
        int bucketIndex = hash(key);
        LinkedList<HashNode<K, V>> bucket = buckets[bucketIndex];
        
        // 检查键是否已存在
        for (HashNode<K, V> node : bucket) {
            if (node.key.equals(key)) {
                node.value = value;  // 更新值
                return;
            }
        }
        
        // 添加新节点
        bucket.add(new HashNode<>(key, value));
        size++;
        
        // 检查负载因子，如果超过阈值则扩容
        if ((1.0 * size) / numBuckets >= LOAD_FACTOR_THRESHOLD) {
            resize();
        }
    }
    
    /**
     * 删除键
     */
    public V remove(K key) {
        int bucketIndex = hash(key);
        LinkedList<HashNode<K, V>> bucket = buckets[bucketIndex];
        
        for (HashNode<K, V> node : bucket) {
            if (node.key.equals(key)) {
                V value = node.value;
                bucket.remove(node);
                size--;
                return value;
            }
        }
        
        return null;  // 未找到
    }
    
    /**
     * 扩容哈希表
     */
    @SuppressWarnings("unchecked")
    private void resize() {
        int oldCapacity = numBuckets;
        numBuckets = oldCapacity * 2;
        
        LinkedList<HashNode<K, V>>[] newBuckets = new LinkedList[numBuckets];
        
        for (int i = 0; i < numBuckets; i++) {
            newBuckets[i] = new LinkedList<>();
        }
        
        // 重新哈希所有元素
        for (LinkedList<HashNode<K, V>> bucket : buckets) {
            for (HashNode<K, V> node : bucket) {
                int newIndex = Math.abs(node.key.hashCode()) % numBuckets;
                newBuckets[newIndex].add(node);
            }
        }
        
        buckets = newBuckets;
    }
    
    /**
     * 获取大小
     */
    public int size() {
        return size;
    }
    
    /**
     * 是否为空
     */
    public boolean isEmpty() {
        return size == 0;
    }
    
    /**
     * 获取负载因子
     */
    public double getLoadFactor() {
        return (double) size / numBuckets;
    }
    
    /**
     * 显示哈希表内容
     */
    public void display() {
        System.out.println("=== 哈希表详情 ===");
        System.out.println("容量: " + numBuckets);
        System.out.println("大小: " + size);
        System.out.println("负载因子: " + String.format("%.2f", getLoadFactor()));
        
        System.out.println("\n哈希表内容:");
        for (int i = 0; i < numBuckets; i++) {
            System.out.print("桶 " + i + ": ");
            if (buckets[i].isEmpty()) {
                System.out.println("空");
            } else {
                for (HashNode<K, V> node : buckets[i]) {
                    System.out.print("[" + node.key + "=" + node.value + "] ");
                }
                System.out.println("(链长: " + buckets[i].size() + ")");
            }
        }
    }
    
    /**
     * 获取统计信息
     */
    public void getStatistics() {
        int emptyBuckets = 0;
        int maxChainLength = 0;
        int totalChainLength = 0;
        int collisions = 0;
        
        for (LinkedList<HashNode<K, V>> bucket : buckets) {
            if (bucket.isEmpty()) {
                emptyBuckets++;
            } else {
                int chainLength = bucket.size();
                if (chainLength > maxChainLength) {
                    maxChainLength = chainLength;
                }
                totalChainLength += chainLength;
                if (chainLength > 1) {
                    collisions += (chainLength - 1);
                }
            }
        }
        
        double avgChainLength = (double) totalChainLength / (numBuckets - emptyBuckets);
        
        System.out.println("=== 哈希表统计 ===");
        System.out.println("总桶数: " + numBuckets);
        System.out.println("空桶数: " + emptyBuckets + " (" + 
                          String.format("%.1f", (double) emptyBuckets / numBuckets * 100) + "%)");
        System.out.println("最大链长: " + maxChainLength);
        System.out.println("平均链长: " + String.format("%.2f", avgChainLength));
        System.out.println("总冲突数: " + collisions);
        System.out.println("负载因子: " + String.format("%.2f", getLoadFactor()));
    }
    
    public static void main(String[] args) {
        HashTableChaining<String, Integer> map = new HashTableChaining<>(5);
        
        // 插入测试
        System.out.println("=== 插入测试 ===");
        String[] names = {"Alice", "Bob", "Charlie", "David", "Eve", "Frank", "Grace", "Henry"};
        int[] scores = {85, 92, 78, 90, 88, 95, 82, 87};
        
        for (int i = 0; i < names.length; i++) {
            map.put(names[i], scores[i]);
            System.out.println("插入 " + names[i] + "=" + scores[i]);
        }
        
        map.display();
        map.getStatistics();
        
        // 查找测试
        System.out.println("\n=== 查找测试 ===");
        String[] searchKeys = {"Alice", "Bob", "Charlie", "George"};
        for (String key : searchKeys) {
            Integer value = map.get(key);
            if (value != null) {
                System.out.println(key + " 的分数: " + value);
            } else {
                System.out.println(key + " 不存在");
            }
        }
        
        // 更新测试
        System.out.println("\n=== 更新测试 ===");
        map.put("Alice", 99);
        System.out.println("更新后Alice的分数: " + map.get("Alice"));
        
        // 删除测试
        System.out.println("\n=== 删除测试 ===");
        System.out.println("删除Charlie: " + map.remove("Charlie"));
        map.display();
        
        // 性能测试
        System.out.println("\n=== 性能测试 ===");
        HashTableChaining<Integer, String> largeMap = new HashTableChaining<>(100);
        
        long startTime = System.currentTimeMillis();
        for (int i = 0; i < 10000; i++) {
            largeMap.put(i, "Value" + i);
        }
        long insertTime = System.currentTimeMillis() - startTime;
        
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 1000; i++) {
            largeMap.get((int)(Math.random() * 10000));
        }
        long searchTime = System.currentTimeMillis() - startTime;
        
        System.out.println("插入 10000 个元素用时: " + insertTime + "ms");
        System.out.println("1000 次随机查找用时: " + searchTime + "ms");
        largeMap.getStatistics();
    }
}
```

### 2. 开放定址法（线性探测）实现

```
public class HashTableLinearProbing<K, V> {
    
    // 哈希表条目
    static class HashEntry<K, V> {
        K key;
        V value;
        boolean isDeleted;  // 标记是否被删除
        
        HashEntry(K key, V value) {
            this.key = key;
            this.value = value;
            this.isDeleted = false;
        }
    }
    
    private HashEntry<K, V>[] table;
    private int capacity;
    private int size;
    private final double LOAD_FACTOR_THRESHOLD = 0.7;
    private final HashEntry<K, V> DELETED = new HashEntry<>(null, null);  // 删除标记
    
    @SuppressWarnings("unchecked")
    public HashTableLinearProbing(int capacity) {
        this.capacity = capacity;
        this.size = 0;
        this.table = new HashEntry[capacity];
    }
    
    public HashTableLinearProbing() {
        this(10);
    }
    
    /**
     * 哈希函数
     */
    private int hash(K key) {
        return Math.abs(key.hashCode()) % capacity;
    }
    
    /**
     * 二次哈希（用于双重哈希）
     */
    private int hash2(K key) {
        // 使用另一个哈希函数，确保不为0
        return 1 + (Math.abs(key.hashCode()) % (capacity - 1));
    }
    
    /**
     * 查找键的索引
     */
    private int findIndex(K key, boolean forInsert) {
        int index = hash(key);
        int startIndex = index;
        int step = 1;  // 线性探测步长
        
        // 使用双重哈希时的步长
        // int step = hash2(key);
        
        while (table[index] != null) {
            if (!table[index].isDeleted && table[index].key.equals(key)) {
                return index;  // 找到键
            }
            
            // 线性探测
            index = (index + step) % capacity;
            
            // 二次探测
            // index = (startIndex + step * step) % capacity;
            // step++;
            
            // 如果回到起点且不是插入操作
            if (!forInsert && index == startIndex) {
                break;
            }
        }
        
        return forInsert ? index : -1;  // 插入时返回位置，查找时返回-1表示未找到
    }
    
    /**
     * 获取值
     */
    public V get(K key) {
        int index = findIndex(key, false);
        if (index != -1) {
            return table[index].value;
        }
        return null;
    }
    
    /**
     * 插入键值对
     */
    public void put(K key, V value) {
        // 检查负载因子
        if ((double) size / capacity >= LOAD_FACTOR_THRESHOLD) {
            resize();
        }
        
        int index = findIndex(key, true);
        
        if (table[index] == null || table[index].isDeleted) {
            // 新插入
            table[index] = new HashEntry<>(key, value);
            size++;
        } else {
            // 更新已存在的键
            table[index].value = value;
        }
    }
    
    /**
     * 删除键
     */
    public V remove(K key) {
        int index = findIndex(key, false);
        if (index != -1) {
            V value = table[index].value;
            table[index].isDeleted = true;  // 标记为删除
            size--;
            return value;
        }
        return null;
    }
    
    /**
     * 扩容哈希表
     */
    @SuppressWarnings("unchecked")
    private void resize() {
        int newCapacity = capacity * 2;
        HashEntry<K, V>[] newTable = new HashEntry[newCapacity];
        
        int oldCapacity = capacity;
        capacity = newCapacity;
        
        // 重新插入所有有效元素
        for (int i = 0; i < oldCapacity; i++) {
            HashEntry<K, V> entry = table[i];
            if (entry != null && !entry.isDeleted) {
                int newIndex = findIndex(entry.key, true);
                newTable[newIndex] = entry;
            }
        }
        
        table = newTable;
    }
    
    /**
     * 获取大小
     */
    public int size() {
        return size;
    }
    
    /**
     * 获取负载因子
     */
    public double getLoadFactor() {
        return (double) size / capacity;
    }
    
    /**
     * 显示哈希表
     */
    public void display() {
        System.out.println("=== 开放定址法哈希表 ===");
        System.out.println("容量: " + capacity);
        System.out.println("大小: " + size);
        System.out.println("负载因子: " + String.format("%.2f", getLoadFactor()));
        
        System.out.println("\n哈希表内容:");
        for (int i = 0; i < capacity; i++) {
            if (table[i] != null && !table[i].isDeleted) {
                System.out.println("索引 " + i + ": [" + table[i].key + "=" + table[i].value + "]");
            } else if (table[i] != null) {
                System.out.println("索引 " + i + ": [已删除]");
            } else {
                System.out.println("索引 " + i + ": [空]");
            }
        }
    }
    
    /**
     * 获取统计信息
     */
    public void getStatistics() {
        int clusters = 0;
        int maxClusterLength = 0;
        int currentClusterLength = 0;
        int probes = 0;
        
        for (int i = 0; i < capacity; i++) {
            if (table[i] != null && !table[i].isDeleted) {
                currentClusterLength++;
                probes += currentClusterLength;  // 计算探测次数
            } else {
                if (currentClusterLength > 0) {
                    clusters++;
                    if (currentClusterLength > maxClusterLength) {
                        maxClusterLength = currentClusterLength;
                    }
                    currentClusterLength = 0;
                }
            }
        }
        
        // 处理最后的簇
        if (currentClusterLength > 0) {
            clusters++;
            if (currentClusterLength > maxClusterLength) {
                maxClusterLength = currentClusterLength;
            }
        }
        
        double avgProbes = size > 0 ? (double) probes / size : 0;
        
        System.out.println("=== 统计信息 ===");
        System.out.println("簇数量: " + clusters);
        System.out.println("最大簇长度: " + maxClusterLength);
        System.out.println("平均查找长度: " + String.format("%.2f", avgProbes));
    }
    
    public static void main(String[] args) {
        HashTableLinearProbing<String, Integer> map = new HashTableLinearProbing<>(5);
        
        // 插入测试
        map.put("Alice", 85);
        map.put("Bob", 92);
        map.put("Charlie", 78);
        map.put("David", 90);
        
        map.display();
        map.getStatistics();
        
        // 查找测试
        System.out.println("\n=== 查找测试 ===");
        System.out.println("Alice: " + map.get("Alice"));
        System.out.println("Bob: " + map.get("Bob"));
        
        // 删除测试
        System.out.println("\n=== 删除Bob后 ===");
        map.remove("Bob");
        map.display();
        
        // 冲突测试
        System.out.println("\n=== 插入更多元素测试冲突 ===");
        map.put("Eve", 88);
        map.put("Frank", 95);
        map.put("Grace", 82);
        map.display();
        map.getStatistics();
        
        // 查找被删除的元素
        System.out.println("\n查找被删除的Bob: " + map.get("Bob"));
        
        // 插入到被删除的位置
        System.out.println("插入新元素到Bob的位置:");
        map.put("Helen", 91);
        map.display();
    }
}
```

### 3. 哈希函数示例

```
import java.util.Arrays;

public class HashFunctionsExample {
    
    /**
     * 多种字符串哈希函数实现
     */
    public static class StringHashFunctions {
        
        // 1. 简单求和哈希
        public static int simpleSumHash(String key, int tableSize) {
            int hash = 0;
            for (int i = 0; i < key.length(); i++) {
                hash += key.charAt(i);
            }
            return Math.abs(hash) % tableSize;
        }
        
        // 2. 多项式哈希（Horner方法）
        public static int polynomialHash(String key, int tableSize) {
            int hash = 0;
            int prime = 31;  // 常用质数
            
            for (int i = 0; i < key.length(); i++) {
                hash = (prime * hash + key.charAt(i)) % tableSize;
            }
            
            return Math.abs(hash) % tableSize;
        }
        
        // 3. DJB2哈希（Dan Bernstein）
        public static int djb2Hash(String key, int tableSize) {
            int hash = 5381;
            
            for (int i = 0; i < key.length(); i++) {
                hash = ((hash << 5) + hash) + key.charAt(i);  // hash * 33 + c
            }
            
            return Math.abs(hash) % tableSize;
        }
        
        // 4. 旋转哈希
        public static int rotateHash(String key, int tableSize) {
            int hash = 0;
            
            for (int i = 0; i < key.length(); i++) {
                hash = (hash << 4) ^ (hash >> 28) ^ key.charAt(i);
            }
            
            return Math.abs(hash) % tableSize;
        }
        
        // 5. Java默认哈希函数
        public static int javaDefaultHash(String key, int tableSize) {
            return Math.abs(key.hashCode()) % tableSize;
        }
    }
    
    /**
     * 测试哈希函数的分布
     */
    public static void testHashDistribution(String[] keys, int tableSize) {
        System.out.println("=== 哈希函数分布测试 ===");
        System.out.println("键数量: " + keys.length);
        System.out.println("表大小: " + tableSize);
        
        String[] hashFunctions = {"简单求和", "多项式", "DJB2", "旋转", "Java默认"};
        
        for (String funcName : hashFunctions) {
            int[] distribution = new int[tableSize];
            
            for (String key : keys) {
                int hash = 0;
                
                switch (funcName) {
                    case "简单求和":
                        hash = StringHashFunctions.simpleSumHash(key, tableSize);
                        break;
                    case "多项式":
                        hash = StringHashFunctions.polynomialHash(key, tableSize);
                        break;
                    case "DJB2":
                        hash = StringHashFunctions.djb2Hash(key, tableSize);
                        break;
                    case "旋转":
                        hash = StringHashFunctions.rotateHash(key, tableSize);
                        break;
                    case "Java默认":
                        hash = StringHashFunctions.javaDefaultHash(key, tableSize);
                        break;
                }
                
                distribution[hash]++;
            }
            
            // 计算统计信息
            int max = 0, min = Integer.MAX_VALUE, emptySlots = 0;
            double sum = 0;
            double variance = 0;
            
            for (int count : distribution) {
                if (count > max) max = count;
                if (count < min) min = count;
                if (count == 0) emptySlots++;
                sum += count;
            }
            
            double avg = sum / tableSize;
            
            for (int count : distribution) {
                variance += Math.pow(count - avg, 2);
            }
            variance /= tableSize;
            double stdDev = Math.sqrt(variance);
            
            System.out.println("\n" + funcName + "哈希函数:");
            System.out.println("  最大冲突: " + max);
            System.out.println("  最小冲突: " + min);
            System.out.println("  平均冲突: " + String.format("%.2f", avg));
            System.out.println("  标准差: " + String.format("%.2f", stdDev));
            System.out.println("  空槽率: " + 
                String.format("%.1f", (emptySlots * 100.0 / tableSize)) + "%");
            
            // 显示分布直方图
            if (tableSize <= 20) {
                System.out.print("  分布: ");
                for (int count : distribution) {
                    System.out.print(count + " ");
                }
                System.out.println();
            }
        }
    }
    
    /**
     * 测试整数哈希函数
     */
    public static class IntegerHashFunctions {
        
        // 1. 除法哈希法
        public static int divisionHash(int key, int tableSize) {
            return Math.abs(key) % tableSize;
        }
        
        // 2. 乘法哈希法
        public static int multiplicationHash(int key, int tableSize) {
            double A = 0.6180339887;  // 黄金分割
            double fractional = (key * A) % 1;
            return (int)(tableSize * fractional);
        }
        
        // 3. 折叠哈希法
        public static int foldingHash(int key, int tableSize, int partSize) {
            int sum = 0;
            int mask = (1 << partSize) - 1;
            
            while (key > 0) {
                sum += key & mask;
                key >>= partSize;
            }
            
            return Math.abs(sum) % tableSize;
        }
        
        // 4. 平方取中法
        public static int midSquareHash(int key, int tableSize) {
            long square = (long)key * key;
            String str = Long.toString(square);
            int len = str.length();
            
            // 取中间几位
            int start = len / 4;
            int end = start + 4;
            if (end > len) end = len;
            
            int hash = 0;
            for (int i = start; i < end; i++) {
                hash = hash * 10 + (str.charAt(i) - '0');
            }
            
            return Math.abs(hash) % tableSize;
        }
    }
    
    /**
     * 演示哈希碰撞
     */
    public static void demonstrateCollisions() {
        System.out.println("=== 哈希碰撞演示 ===");
        
        String[] testWords = {"hello", "world", "hash", "table", "collision", 
                             "algorithm", "data", "structure", "java", "python"};
        int tableSize = 10;
        
        System.out.println("测试单词: " + Arrays.toString(testWords));
        System.out.println("表大小: " + tableSize);
        
        System.out.println("\nJava默认哈希:");
        for (String word : testWords) {
            int hash = StringHashFunctions.javaDefaultHash(word, tableSize);
            System.out.println("  " + word + " -> " + hash);
        }
        
        // 寻找碰撞
        System.out.println("\n寻找哈希碰撞:");
        String[] words = {"Aa", "BB"};
        for (String w1 : words) {
            for (String w2 : words) {
                int h1 = StringHashFunctions.javaDefaultHash(w1, 100);
                int h2 = StringHashFunctions.javaDefaultHash(w2, 100);
                if (!w1.equals(w2) && h1 == h2) {
                    System.out.println("碰撞: " + w1 + " (" + h1 + ") 和 " + w2 + " (" + h2 + ")");
                }
            }
        }
    }
    
    public static void main(String[] args) {
        // 生成测试数据
        int keyCount = 1000;
        int tableSize = 100;
        
        String[] keys = new String[keyCount];
        for (int i = 0; i < keyCount; i++) {
            keys[i] = "key_" + i + "_" + System.nanoTime();
        }
        
        testHashDistribution(keys, tableSize);
        
        // 测试整数哈希
        System.out.println("\n=== 整数哈希函数测试 ===");
        int[] numbers = {12345, 67890, 11111, 22222, 33333, 44444, 55555};
        for (int num : numbers) {
            System.out.println("\n数字: " + num);
            System.out.println("  除法哈希: " + IntegerHashFunctions.divisionHash(num, tableSize));
            System.out.println("  乘法哈希: " + IntegerHashFunctions.multiplicationHash(num, tableSize));
            System.out.println("  折叠哈希: " + IntegerHashFunctions.foldingHash(num, tableSize, 4));
            System.out.println("  平方取中: " + IntegerHashFunctions.midSquareHash(num, tableSize));
        }
        
        demonstrateCollisions();
    }
}
```

### 4. 完美哈希和布隆过滤器

```
import java.util.BitSet;

public class PerfectHashAndBloomFilter {
    
    /**
     * 布隆过滤器
     */
    static class BloomFilter {
        private BitSet bitSet;
        private int size;
        private int[] seeds;  // 多个哈希函数的种子
        
        public BloomFilter(int size, int hashFunctions) {
            this.size = size;
            this.bitSet = new BitSet(size);
            this.seeds = new int[hashFunctions];
            
            // 初始化种子
            for (int i = 0; i < hashFunctions; i++) {
                seeds[i] = (int)(Math.random() * 1000) + 1;
            }
        }
        
        /**
         * 计算哈希值
         */
        private int hash(String value, int seed) {
            int result = 0;
            for (int i = 0; i < value.length(); i++) {
                result = seed * result + value.charAt(i);
            }
            return Math.abs(result) % size;
        }
        
        /**
         * 添加元素
         */
        public void add(String value) {
            for (int seed : seeds) {
                int index = hash(value, seed);
                bitSet.set(index, true);
            }
        }
        
        /**
         * 检查元素是否存在（可能有误判）
         */
        public boolean mightContain(String value) {
            for (int seed : seeds) {
                int index = hash(value, seed);
                if (!bitSet.get(index)) {
                    return false;
                }
            }
            return true;
        }
        
        /**
         * 获取误判率估计
         */
        public double estimateFalsePositiveRate(int totalElements) {
            double p = Math.pow(1 - Math.exp(-seeds.length * (double) totalElements / size), seeds.length);
            return p;
        }
        
        /**
         * 显示统计信息
         */
        public void displayStats() {
            int setBits = bitSet.cardinality();
            double loadFactor = (double) setBits / size;
            
            System.out.println("布隆过滤器统计:");
            System.out.println("  大小: " + size);
            System.out.println("  哈希函数数量: " + seeds.length);
            System.out.println("  设置位数: " + setBits);
            System.out.println("  负载因子: " + String.format("%.2f", loadFactor));
        }
    }
    
    /**
     * 完美哈希（简单实现）
     */
    static class PerfectHash {
        private String[] table;
        private int size;
        
        public PerfectHash(int size) {
            this.size = size;
            this.table = new String[size];
        }
        
        /**
         * 构建完美哈希（这里只是简单演示）
         * 实际完美哈希需要复杂构造过程
         */
        public boolean build(String[] keys) {
            // 简单的完美哈希：假设没有冲突
            for (String key : keys) {
                int hash = Math.abs(key.hashCode()) % size;
                if (table[hash] != null) {
                    return false;  // 有冲突，不是完美哈希
                }
                table[hash] = key;
            }
            return true;
        }
        
        /**
         * 查找
         */
        public boolean contains(String key) {
            int hash = Math.abs(key.hashCode()) % size;
            return key.equals(table[hash]);
        }
    }
    
    /**
     * 一致性哈希
     */
    static class ConsistentHash {
        private TreeMap<Integer, String> circle = new TreeMap<>();
        private int numberOfReplicas = 100;  // 虚拟节点数
        
        public void addNode(String node) {
            for (int i = 0; i < numberOfReplicas; i++) {
                String virtualNode = node + "#" + i;
                int hash = virtualNode.hashCode();
                circle.put(hash, node);
            }
        }
        
        public void removeNode(String node) {
            for (int i = 0; i < numberOfReplicas; i++) {
                String virtualNode = node + "#" + i;
                int hash = virtualNode.hashCode();
                circle.remove(hash);
            }
        }
        
        public String getNode(String key) {
            if (circle.isEmpty()) {
                return null;
            }
            
            int hash = key.hashCode();
            if (!circle.containsKey(hash)) {
                // 返回大于等于该哈希值的第一个节点
                SortedMap<Integer, String> tailMap = circle.tailMap(hash);
                hash = tailMap.isEmpty() ? circle.firstKey() : tailMap.firstKey();
            }
            return circle.get(hash);
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== 布隆过滤器演示 ===");
        
        BloomFilter bloomFilter = new BloomFilter(1000, 3);
        
        // 添加元素
        String[] words = {"apple", "banana", "orange", "grape", "melon"};
        for (String word : words) {
            bloomFilter.add(word);
        }
        
        bloomFilter.displayStats();
        
        // 测试存在性
        System.out.println("\n存在性测试:");
        for (String word : words) {
            System.out.println(word + ": " + bloomFilter.mightContain(word));
        }
        
        // 测试不存在的元素
        System.out.println("\n不存在的元素测试:");
        String[] testWords = {"peach", "berry", "kiwi", "mango"};
        for (String word : testWords) {
            System.out.println(word + ": " + bloomFilter.mightContain(word));
        }
        
        // 误判率估计
        System.out.println("\n估计误判率: " + 
            String.format("%.6f", bloomFilter.estimateFalsePositiveRate(words.length)));
        
        System.out.println("\n=== 一致性哈希演示 ===");
        ConsistentHash consistentHash = new ConsistentHash();
        
        // 添加节点
        consistentHash.addNode("Node1");
        consistentHash.addNode("Node2");
        consistentHash.addNode("Node3");
        
        // 测试键的路由
        String[] keys = {"key1", "key2", "key3", "key4", "key5"};
        for (String key : keys) {
            String node = consistentHash.getNode(key);
            System.out.println(key + " -> " + node);
        }
        
        // 移除节点
        System.out.println("\n移除Node2后:");
        consistentHash.removeNode("Node2");
        for (String key : keys) {
            String node = consistentHash.getNode(key);
            System.out.println(key + " -> " + node);
        }
    }
}
```

## 使用Java内置的HashMap

```
import java.util.*;

public class JavaHashMapExample {
    
    public static void main(String[] args) {
        System.out.println("=== Java HashMap 示例 ===");
        
        // 1. 创建HashMap
        HashMap<String, Integer> scores = new HashMap<>();
        
        // 2. 添加元素
        scores.put("Alice", 95);
        scores.put("Bob", 88);
        scores.put("Charlie", 92);
        scores.put("David", 78);
        scores.put("Eve", 85);
        
        // 3. 访问元素
        System.out.println("Alice的分数: " + scores.get("Alice"));
        System.out.println("不存在的键: " + scores.get("Frank"));
        
        // 4. 检查键是否存在
        System.out.println("是否存在Charlie: " + scores.containsKey("Charlie"));
        System.out.println("是否存在Frank: " + scores.containsKey("Frank"));
        
        // 5. 遍历HashMap
        System.out.println("\n所有学生分数:");
        for (Map.Entry<String, Integer> entry : scores.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        // 6. 只遍历键
        System.out.println("\n所有学生:");
        for (String name : scores.keySet()) {
            System.out.println(name);
        }
        
        // 7. 只遍历值
        System.out.println("\n所有分数:");
        for (int score : scores.values()) {
            System.out.println(score);
        }
        
        // 8. 删除元素
        System.out.println("\n删除David: " + scores.remove("David"));
        System.out.println("删除后是否存在David: " + scores.containsKey("David"));
        
        // 9. 大小和空检查
        System.out.println("映射大小: " + scores.size());
        System.out.println("映射是否为空: " + scores.isEmpty());
        
        // 10. 特殊方法
        System.out.println("\n特殊方法演示:");
        
        // getOrDefault - 如果键不存在返回默认值
        System.out.println("George的分数: " + scores.getOrDefault("George", 0));
        
        // putIfAbsent - 只有键不存在时才放入
        scores.putIfAbsent("Alice", 100);  // 不会更新，因为Alice已存在
        System.out.println("putIfAbsent后Alice的分数: " + scores.get("Alice"));
        
        scores.putIfAbsent("Frank", 90);  // 会添加
        System.out.println("添加Frank后Frank的分数: " + scores.get("Frank"));
        
        // compute - 计算新值
        scores.compute("Alice", (key, value) -> value + 5);  // 加5分
        System.out.println("compute后Alice的分数: " + scores.get("Alice"));
        
        // merge - 合并值
        scores.merge("Bob", 10, (oldValue, newValue) -> oldValue + newValue);
        System.out.println("merge后Bob的分数: " + scores.get("Bob"));
        
        // computeIfAbsent - 如果键不存在则计算
        scores.computeIfAbsent("Helen", key -> 80);
        System.out.println("computeIfAbsent后Helen的分数: " + scores.get("Helen"));
        
        // 11. 性能测试
        System.out.println("\n=== 性能测试 ===");
        
        HashMap<Integer, String> largeMap = new HashMap<>();
        int size = 100000;
        
        // 插入性能
        long startTime = System.currentTimeMillis();
        for (int i = 0; i < size; i++) {
            largeMap.put(i, "Value" + i);
        }
        long insertTime = System.currentTimeMillis() - startTime;
        
        // 查找性能
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 10000; i++) {
            largeMap.get((int)(Math.random() * size));
        }
        long searchTime = System.currentTimeMillis() - startTime;
        
        System.out.println("插入 " + size + " 个元素用时: " + insertTime + "ms");
        System.out.println("10000 次随机查找用时: " + searchTime + "ms");
        System.out.println("映射大小: " + largeMap.size());
        
        // 12. 负载因子和初始容量
        System.out.println("\n=== 负载因子和初始容量 ===");
        
        // 指定初始容量和负载因子
        HashMap<String, Integer> customMap = new HashMap<>(16, 0.75f);
        customMap.put("A", 1);
        customMap.put("B", 2);
        customMap.put("C", 3);
        
        System.out.println("自定义HashMap: " + customMap);
        
        // 13. 线程安全版本
        System.out.println("\n=== 线程安全的HashMap ===");
        Map<String, Integer> synchronizedMap = Collections.synchronizedMap(new HashMap<>());
        synchronizedMap.put("One", 1);
        synchronizedMap.put("Two", 2);
        
        System.out.println("同步映射: " + synchronizedMap);
        
        // 14. ConcurrentHashMap
        System.out.println("\n=== ConcurrentHashMap ===");
        ConcurrentHashMap<String, Integer> concurrentMap = new ConcurrentHashMap<>();
        concurrentMap.put("One", 1);
        concurrentMap.put("Two", 2);
        
        System.out.println("ConcurrentHashMap: " + concurrentMap);
        
        // 15. LinkedHashMap（保持插入顺序）
        System.out.println("\n=== LinkedHashMap（保持插入顺序）===");
        LinkedHashMap<String, Integer> linkedMap = new LinkedHashMap<>();
        linkedMap.put("Z", 26);
        linkedMap.put("A", 1);
        linkedMap.put("M", 13);
        
        System.out.println("LinkedHashMap顺序: " + linkedMap);
        
        // 16. TreeMap（按键排序）
        System.out.println("\n=== TreeMap（按键排序）===");
        TreeMap<String, Integer> treeMap = new TreeMap<>();
        treeMap.put("Z", 26);
        treeMap.put("A", 1);
        treeMap.put("M", 13);
        
        System.out.println("TreeMap顺序: " + treeMap);
        
        // 17. IdentityHashMap（使用==比较键）
        System.out.println("\n=== IdentityHashMap（使用==比较键）===");
        IdentityHashMap<String, Integer> identityMap = new IdentityHashMap<>();
        String s1 = new String("key");
        String s2 = new String("key");
        
        identityMap.put(s1, 1);
        identityMap.put(s2, 2);
        
        System.out.println("s1 == s2: " + (s1 == s2));
        System.out.println("s1.equals(s2): " + s1.equals(s2));
        System.out.println("IdentityHashMap大小: " + identityMap.size());  // 2
        System.out.println("IdentityHashMap内容: " + identityMap);
        
        // 18. WeakHashMap（弱引用键）
        System.out.println("\n=== WeakHashMap（弱引用键）===");
        WeakHashMap<String, Integer> weakMap = new WeakHashMap<>();
        String weakKey = new String("weakKey");
        weakMap.put(weakKey, 100);
        
        System.out.println("GC前WeakHashMap大小: " + weakMap.size());
        weakKey = null;  // 移除强引用
        System.gc();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("GC后WeakHashMap大小: " + weakMap.size());
    }
}
```

## 哈希查找的应用场景

### 1. 缓存实现

```
import java.util.*;

public class LRUCache<K, V> {
    
    static class Node<K, V> {
        K key;
        V value;
        Node<K, V> prev;
        Node<K, V> next;
        
        Node(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }
    
    private final int capacity;
    private final Map<K, Node<K, V>> cache;
    private final Node<K, V> head;
    private final Node<K, V> tail;
    
    public LRUCache(int
```