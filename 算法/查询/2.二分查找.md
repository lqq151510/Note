# Java算法：二分查找

## 定义

二分查找（Binary Search），也称折半查找，是一种在**有序数组**中查找特定元素的高效算法。它的基本思想是**每次将查找区间缩小一半**，直到找到目标元素或区间为空。

### 核心特性

- **时间复杂度**：O(log n)
    
- **空间复杂度**：
    
    - 迭代实现：O(1)
        
    - 递归实现：O(log n)（递归调用栈）
        
    
- **前提条件**：数组必须是有序的（通常为升序排列）
    
- **优点**：查找效率高，适合大规模数据
    
- **缺点**：要求数据有序，不适合频繁插入删除的场景
    

## 算法原理

### 基本步骤

1. 确定查找范围的左右边界（初始为0和n-1）
    
2. 计算中间位置：mid = (left + right) / 2
    
3. 比较中间元素与目标值：
    
    - 如果相等，返回中间索引
        
    - 如果中间元素大于目标值，在左半部分继续查找
        
    - 如果中间元素小于目标值，在右半部分继续查找
        
    
4. 重复步骤2-3，直到找到目标或查找范围为空
    

## 二分查找示例

### 1. 基本二分查找（迭代实现）

```
/**
 * 基本的二分查找算法（迭代实现）
 * 在升序数组中查找目标值
 * @param arr 有序数组
 * @param target 目标值
 * @return 目标值的索引，未找到返回-1
 */
public static int binarySearchIterative(int[] arr, int target) {
    // 边界检查
    if (arr == null || arr.length == 0) {
        return -1;
    }
    
    int left = 0;
    int right = arr.length - 1;
    
    while (left <= right) {
        // 计算中间位置，防止整数溢出
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;  // 找到目标
        } else if (arr[mid] < target) {
            left = mid + 1;  // 在右半部分查找
        } else {
            right = mid - 1;  // 在左半部分查找
        }
    }
    
    return -1;  // 未找到
}
```

### 2. 二分查找（递归实现）

```
/**
 * 二分查找（递归实现）
 */
public static int binarySearchRecursive(int[] arr, int target) {
    if (arr == null || arr.length == 0) {
        return -1;
    }
    return binarySearchRecursive(arr, target, 0, arr.length - 1);
}

private static int binarySearchRecursive(int[] arr, int target, int left, int right) {
    // 递归终止条件
    if (left > right) {
        return -1;
    }
    
    int mid = left + (right - left) / 2;
    
    if (arr[mid] == target) {
        return mid;
    } else if (arr[mid] < target) {
        return binarySearchRecursive(arr, target, mid + 1, right);
    } else {
        return binarySearchRecursive(arr, target, left, mid - 1);
    }
}
```

### 3. 查找第一个等于目标值的位置

```
/**
 * 查找第一个等于目标值的位置
 * 适用于有重复元素的数组
 */
public static int findFirstPosition(int[] arr, int target) {
    if (arr == null || arr.length == 0) {
        return -1;
    }
    
    int left = 0;
    int right = arr.length - 1;
    int result = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            result = mid;  // 记录位置
            right = mid - 1;  // 继续在左半部分查找
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return result;
}
```

### 4. 查找最后一个等于目标值的位置

```
/**
 * 查找最后一个等于目标值的位置
 */
public static int findLastPosition(int[] arr, int target) {
    if (arr == null || arr.length == 0) {
        return -1;
    }
    
    int left = 0;
    int right = arr.length - 1;
    int result = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            result = mid;  // 记录位置
            left = mid + 1;  // 继续在右半部分查找
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return result;
}
```

### 5. 查找第一个大于等于目标值的位置

```
/**
 * 查找第一个大于等于目标值的位置
 * 如果目标值存在，返回第一个等于目标值的位置
 * 如果目标值不存在，返回第一个大于目标值的位置
 */
public static int findFirstGreaterOrEqual(int[] arr, int target) {
    if (arr == null || arr.length == 0) {
        return -1;
    }
    
    int left = 0;
    int right = arr.length - 1;
    int result = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] >= target) {
            result = mid;  // 记录位置
            right = mid - 1;  // 继续在左半部分查找
        } else {
            left = mid + 1;
        }
    }
    
    return result;
}
```

## 完整示例

```
import java.util.Arrays;
import java.util.Scanner;

public class BinarySearchExample {
    
    public static void main(String[] args) {
        // 创建有序数组
        int[] sortedArray = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20};
        System.out.println("有序数组: " + Arrays.toString(sortedArray));
        
        // 测试基本二分查找
        testBasicBinarySearch(sortedArray);
        
        // 测试有重复元素的数组
        testWithDuplicates();
        
        // 测试边界值
        testEdgeCases();
    }
    
    /**
     * 测试基本二分查找
     */
    private static void testBasicBinarySearch(int[] arr) {
        System.out.println("\n=== 基本二分查找测试 ===");
        
        int[] targets = {8, 14, 5, 20, 1};
        
        for (int target : targets) {
            int index = binarySearchIterative(arr, target);
            if (index != -1) {
                System.out.println("找到 " + target + " 在索引 " + index + " 处");
            } else {
                System.out.println(target + " 不在数组中");
            }
        }
    }
    
    /**
     * 测试有重复元素的数组
     */
    private static void testWithDuplicates() {
        System.out.println("\n=== 有重复元素的数组测试 ===");
        
        int[] arrWithDuplicates = {1, 2, 3, 3, 3, 4, 5, 6, 7};
        System.out.println("数组: " + Arrays.toString(arrWithDuplicates));
        
        int target = 3;
        int firstIndex = findFirstPosition(arrWithDuplicates, target);
        int lastIndex = findLastPosition(arrWithDuplicates, target);
        
        System.out.println("目标值 " + target + ":");
        System.out.println("  第一次出现的位置: " + firstIndex);
        System.out.println("  最后一次出现的位置: " + lastIndex);
        System.out.println("  总共出现次数: " + (firstIndex != -1 ? (lastIndex - firstIndex + 1) : 0));
    }
    
    /**
     * 测试边界情况
     */
    private static void testEdgeCases() {
        System.out.println("\n=== 边界情况测试 ===");
        
        // 空数组
        int[] emptyArray = {};
        System.out.println("空数组查找 5: " + binarySearchIterative(emptyArray, 5));
        
        // 单元素数组
        int[] singleArray = {10};
        System.out.println("单元素数组 [10] 查找 10: " + binarySearchIterative(singleArray, 10));
        System.out.println("单元素数组 [10] 查找 5: " + binarySearchIterative(singleArray, 5));
        
        // 查找不存在的元素
        int[] array = {1, 3, 5, 7, 9};
        int target = 6;
        int index = findFirstGreaterOrEqual(array, target);
        System.out.println("在数组 " + Arrays.toString(array) + " 中");
        System.out.println("第一个大于等于 " + target + " 的位置: " + index);
        if (index != -1) {
            System.out.println("该位置的值为: " + array[index]);
        }
    }
    
    // 二分查找方法实现（同上，此处省略完整代码）
    public static int binarySearchIterative(int[] arr, int target) {
        if (arr == null || arr.length == 0) return -1;
        
        int left = 0, right = arr.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == target) return mid;
            else if (arr[mid] < target) left = mid + 1;
            else right = mid - 1;
        }
        return -1;
    }
    
    public static int findFirstPosition(int[] arr, int target) {
        if (arr == null || arr.length == 0) return -1;
        
        int left = 0, right = arr.length - 1, result = -1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == target) {
                result = mid;
                right = mid - 1;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return result;
    }
    
    public static int findLastPosition(int[] arr, int target) {
        if (arr == null || arr.length == 0) return -1;
        
        int left = 0, right = arr.length - 1, result = -1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == target) {
                result = mid;
                left = mid + 1;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return result;
    }
    
    public static int findFirstGreaterOrEqual(int[] arr, int target) {
        if (arr == null || arr.length == 0) return -1;
        
        int left = 0, right = arr.length - 1, result = -1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] >= target) {
                result = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return result;
    }
}
```

## 二分查找的变体

### 1. 查找峰值元素

```
/**
 * 查找峰值元素
 * 峰值元素是指其值大于左右相邻值的元素
 * 假设 arr[-1] = arr[n] = -∞
 */
public static int findPeakElement(int[] arr) {
    if (arr == null || arr.length == 0) {
        return -1;
    }
    
    int left = 0;
    int right = arr.length - 1;
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] < arr[mid + 1]) {
            // 峰值在右侧
            left = mid + 1;
        } else {
            // 峰值在左侧或mid就是峰值
            right = mid;
        }
    }
    
    return left;
}
```

### 2. 在旋转有序数组中查找

```
/**
 * 在旋转有序数组中查找目标值
 * 旋转有序数组示例：[4,5,6,7,0,1,2]
 */
public static int searchInRotatedSortedArray(int[] arr, int target) {
    if (arr == null || arr.length == 0) {
        return -1;
    }
    
    int left = 0;
    int right = arr.length - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;
        }
        
        // 判断左半部分是否有序
        if (arr[left] <= arr[mid]) {
            // 左半部分有序
            if (target >= arr[left] && target < arr[mid]) {
                // 目标在有序的左侧
                right = mid - 1;
            } else {
                // 目标在右侧
                left = mid + 1;
            }
        } else {
            // 右半部分有序
            if (target > arr[mid] && target <= arr[right]) {
                // 目标在有序的右侧
                left = mid + 1;
            } else {
                // 目标在左侧
                right = mid - 1;
            }
        }
    }
    
    return -1;
}
```

### 3. 查找目标值的插入位置

```
/**
 * 查找目标值应该插入的位置
 * 返回目标值应该插入的索引，以保持数组有序
 */
public static int searchInsertPosition(int[] arr, int target) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    
    int left = 0;
    int right = arr.length - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    // 当循环结束时，left指向第一个大于target的元素位置
    // right指向最后一个小于target的元素位置
    return left;
}
```

## 性能分析和比较

### 时间复杂度分析

|情况|时间复杂度|说明|
|---|---|---|
|最好情况|O(1)|目标值正好是中间元素|
|平均情况|O(log n)|每次查找范围减半|
|最坏情况|O(log n)|目标值不存在或位于边界|

### 与顺序查找的比较

```
public class SearchComparison {
    
    public static void main(String[] args) {
        int size = 1000000;
        int[] sortedArray = generateSortedArray(size);
        int target = sortedArray[size / 2];  // 目标在中间
        
        // 二分查找性能
        long startTime = System.nanoTime();
        int binaryResult = binarySearchIterative(sortedArray, target);
        long binaryTime = System.nanoTime() - startTime;
        
        // 顺序查找性能
        startTime = System.nanoTime();
        int sequentialResult = sequentialSearch(sortedArray, target);
        long sequentialTime = System.nanoTime() - startTime;
        
        System.out.println("=== 查找算法性能比较 ===");
        System.out.println("数组大小: " + size);
        System.out.println("目标值位置: " + binaryResult);
        System.out.println("结果是否一致: " + (binaryResult == sequentialResult));
        System.out.println("二分查找耗时: " + binaryTime + " 纳秒");
        System.out.println("顺序查找耗时: " + sequentialTime + " 纳秒");
        System.out.println("性能提升倍数: " + String.format("%.1f", (double)sequentialTime / binaryTime));
    }
    
    private static int[] generateSortedArray(int size) {
        int[] arr = new int[size];
        for (int i = 0; i < size; i++) {
            arr[i] = i * 2;  // 生成有序数组
        }
        return arr;
    }
    
    public static int binarySearchIterative(int[] arr, int target) {
        int left = 0, right = arr.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == target) return mid;
            else if (arr[mid] < target) left = mid + 1;
            else right = mid - 1;
        }
        return -1;
    }
    
    public static int sequentialSearch(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) return i;
        }
        return -1;
    }
}
```

## 常见问题与注意事项

### 1. 整数溢出问题

```
// 错误写法：可能溢出
int mid = (left + right) / 2;

// 正确写法：避免溢出
int mid = left + (right - left) / 2;
```

### 2. 边界条件处理

```
public class BinarySearchBoundary {
    
    /**
     * 处理边界条件的完整二分查找
     */
    public static int safeBinarySearch(int[] arr, int target) {
        // 1. 空数组检查
        if (arr == null) {
            throw new IllegalArgumentException("数组不能为null");
        }
        
        // 2. 空数组检查
        if (arr.length == 0) {
            return -1;
        }
        
        // 3. 检查数组是否有序
        if (!isSorted(arr)) {
            throw new IllegalArgumentException("数组必须是有序的");
        }
        
        // 4. 检查目标值是否在数组范围内（可选优化）
        if (target < arr[0] || target > arr[arr.length - 1]) {
            return -1;
        }
        
        // 5. 执行二分查找
        int left = 0;
        int right = arr.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return -1;
    }
    
    /**
     * 检查数组是否有序
     */
    private static boolean isSorted(int[] arr) {
        for (int i = 0; i < arr.length - 1; i++) {
            if (arr[i] > arr[i + 1]) {
                return false;
            }
        }
        return true;
    }
}
```

### 3. 递归深度限制

```
/**
 * 带有深度限制的递归二分查找
 * 防止栈溢出
 */
public static int binarySearchRecursiveWithDepthLimit(int[] arr, int target) {
    if (arr == null || arr.length == 0) {
        return -1;
    }
    return binarySearchRecursiveWithDepthLimit(arr, target, 0, arr.length - 1, 0);
}

private static int binarySearchRecursiveWithDepthLimit(int[] arr, int target, 
                                                       int left, int right, int depth) {
    // 限制递归深度
    if (depth > 1000) {
        throw new StackOverflowError("递归深度过大，考虑使用迭代实现");
    }
    
    if (left > right) {
        return -1;
    }
    
    int mid = left + (right - left) / 2;
    
    if (arr[mid] == target) {
        return mid;
    } else if (arr[mid] < target) {
        return binarySearchRecursiveWithDepthLimit(arr, target, mid + 1, right, depth + 1);
    } else {
        return binarySearchRecursiveWithDepthLimit(arr, target, left, mid - 1, depth + 1);
    }
}
```

## 实际应用示例

### 1. 在字典中查找单词

```
import java.util.Arrays;

public class DictionarySearch {
    
    public static void main(String[] args) {
        String[] dictionary = {
            "apple", "banana", "cherry", "date", "elderberry",
            "fig", "grape", "honeydew", "kiwi", "lemon"
        };
        
        // 字典必须是有序的
        Arrays.sort(dictionary);
        System.out.println("字典: " + Arrays.toString(dictionary));
        
        String target = "grape";
        int index = binarySearchString(dictionary, target);
        
        if (index != -1) {
            System.out.println("找到单词 \"" + target + "\" 在位置 " + index);
        } else {
            System.out.println("单词 \"" + target + "\" 不在字典中");
        }
    }
    
    /**
     * 在字符串数组中二分查找
     */
    public static int binarySearchString(String[] arr, String target) {
        if (arr == null || target == null) {
            return -1;
        }
        
        int left = 0;
        int right = arr.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            int comparison = arr[mid].compareTo(target);
            
            if (comparison == 0) {
                return mid;
            } else if (comparison < 0) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return -1;
    }
}
```

### 2. 猜数字游戏

```
import java.util.Random;
import java.util.Scanner;

public class GuessNumberGame {
    
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Random random = new Random();
        
        int min = 1;
        int max = 100;
        int target = random.nextInt(max - min + 1) + min;
        int attempts = 0;
        
        System.out.println("猜数字游戏开始！");
        System.out.println("我已经想好了一个 " + min + " 到 " + max + " 之间的数字。");
        
        // 使用二分查找策略
        while (true) {
            System.out.print("请输入你猜的数字: ");
            int guess = scanner.nextInt();
            attempts++;
            
            if (guess == target) {
                System.out.println("恭喜你！猜对了！");
                System.out.println("你用了 " + attempts + " 次猜中。");
                break;
            } else if (guess < target) {
                System.out.println("太小了，再大一点！");
            } else {
                System.out.println("太大了，再小一点！");
            }
            
            // 演示二分查找策略
            if (attempts == 1) {
                System.out.println("提示：用二分查找策略，每次猜中间值最快找到答案！");
            }
        }
        
        scanner.close();
    }
    
    /**
     * 二分查找策略猜数字
     */
    public static int binarySearchGuess(int min, int max, int target) {
        int left = min;
        int right = max;
        int attempts = 0;
        
        while (left <= right) {
            attempts++;
            int mid = left + (right - left) / 2;
            
            System.out.println("第 " + attempts + " 次猜: " + mid);
            
            if (mid == target) {
                System.out.println("找到了！数字是 " + target);
                System.out.println("总共用了 " + attempts + " 次");
                return attempts;
            } else if (mid < target) {
                System.out.println("太小了");
                left = mid + 1;
            } else {
                System.out.println("太大了");
                right = mid - 1;
            }
        }
        
        return -1;
    }
}
```

## 总结

### 二分查找的核心要点

1. **数据必须有序**：二分查找的前提条件
    
2. **每次减半**：查找范围每次减少一半
    
3. **对数时间复杂度**：O(log n) 的高效性能
    
4. **边界处理**：注意循环条件和中间值计算
    

### 选择二分查找的情况

1. 数据量较大且查找频繁
    
2. 数据基本不变或很少修改
    
3. 数据已排序或可以预先排序
    
4. 需要高效的查找性能
    

### 避免使用二分查找的情况

1. 数据量很小（直接使用顺序查找更简单）
    
2. 数据经常插入删除（需要频繁重新排序）
    
3. 数据无法排序
    
4. 内存限制严格（递归实现可能导致栈溢出）
    

### 实际应用场景

- 数据库索引
    
- 字典、电话簿查找
    
- 游戏中的AI决策
    
- 科学计算中的方程求解
    
- 操作系统中的文件查找
    

二分查找是计算机科学中最经典、最重要的算法之一，理解其原理和实现方式对提高编程能力和算法思维非常重要。