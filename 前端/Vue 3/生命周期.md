# Vue 3 生命周期详解

Vue 3 的生命周期钩子允许你在组件不同阶段执行自定义代码。下面这个表格汇总了完整的生命周期流程和对应的钩子函数：

| 生命周期阶段      | Options API 钩子  | Composition API 钩子   | 执行时机与用途                         |
| ----------- | --------------- | -------------------- | ------------------------------- |
| **初始化阶段**​  | `beforeCreate`  | 无（在 `setup()`中直接写代码） | 实例初始化后，数据观测/事件配置前               |
|             | `created`       | 无（在 `setup()`中直接写代码） | 实例创建完成，可访问 `data`、`methods`     |
| **挂载阶段**​   | `beforeMount`   | `onBeforeMount`      | 模板编译后，首次渲染前                     |
| ==**最常用**== | ==`mounted`==   | `onMounted`          | 实例挂载到 DOM 后，可访问 DOM             |
| **更新阶段**​   | `beforeUpdate`  | `onBeforeUpdate`     | 数据变化，DOM 重新渲染前                  |
|             | `updated`       | `onUpdated`          | 数据变化，DOM 重新渲染后                  |
| **卸载阶段**​   | `beforeUnmount` | `onBeforeUnmount`    | 实例卸载前（Vue 2 中是 `beforeDestroy`） |
|             | `unmounted`     | `onUnmounted`        | 实例卸载后（Vue 2 中是 `destroyed`）     |
| **错误处理**​   | `errorCaptured` | `onErrorCaptured`    | 捕获后代组件错误                        |
| **调试钩子**​   | -               | `onRenderTracked`    | 调试：跟踪虚拟 DOM 重新渲染时（仅开发模式）        |
|             | -               | `onRenderTriggered`  | 调试：虚拟 DOM 重新渲染被触发时（仅开发模式）       |
| **激活钩子**​   | `activated`     | `onActivated`        | `<keep-alive>`缓存的组件激活时          |
|             | `deactivated`   | `onDeactivated`      | `<keep-alive>`缓存的组件停用时          |

## 生命周期完整流程图

```
flowchart TD
    A[创建实例] --> B[beforeCreate]
    B --> C[初始化响应式数据<br>注入依赖]
    C --> D[created]
    D --> E{有template选项?}
    E -- 是 --> F[编译template为render函数]
    E -- 否 --> G[编译el的outerHTML为render函数]
    F --> H[beforeMount]
    G --> H
    H --> I[创建虚拟DOM并挂载到真实DOM]
    I --> J[mounted]
    
    J --> K{数据更新?}
    K -- 是 --> L[beforeUpdate]
    L --> M[生成新虚拟DOM<br>与旧虚拟DOM对比]
    M --> N[将差异更新到真实DOM]
    N --> O[updated]
    O --> K
    
    K -- 否, 卸载组件? --> P[beforeUnmount]
    P --> Q[卸载组件实例<br>清理事件监听器/子组件等]
    Q --> R[unmounted]
    
    R --> S[组件销毁]
```

## 详细解释与示例

### 1. Options API 使用方式

```
export default {
  data() {
    return { count: 0 }
  },
  
  // 1. 初始化阶段
  beforeCreate() {
    console.log('beforeCreate: 实例刚创建，data 和 methods 不可用')
    // console.log(this.count) // undefined
  },
  created() {
    console.log('created: 实例创建完成，可访问 data 和 methods')
    console.log(this.count) // 0
    // 适合发送初始化请求
  },
  
  // 2. 挂载阶段
  beforeMount() {
    console.log('beforeMount: 模板编译完成，但尚未挂载到 DOM')
    // console.log(document.getElementById('app')) // null
  },
  mounted() {
    console.log('mounted: 实例已挂载到 DOM，可访问 DOM 元素')
    console.log(document.getElementById('app')) // DOM 元素
    // 适合操作 DOM、初始化第三方库
  },
  
  // 3. 更新阶段
  beforeUpdate() {
    console.log('beforeUpdate: 数据即将更新，DOM 尚未重新渲染')
    // 可获取更新前的 DOM 状态
  },
  updated() {
    console.log('updated: 数据已更新，DOM 已重新渲染')
    // 避免在此处修改数据，可能导致无限循环
  },
  
  // 4. 卸载阶段
  beforeUnmount() {
    console.log('beforeUnmount: 实例即将卸载')
    // 清理定时器、取消事件监听、取消网络请求
    clearInterval(this.timer)
  },
  unmounted() {
    console.log('unmounted: 实例已卸载')
  },
  
  // 5. 错误处理
  errorCaptured(err, instance, info) {
    console.log('errorCaptured: 捕获到后代组件错误', err)
    // 可返回 false 阻止错误继续向上传播
  },
  
  // 6. KeepAlive 组件相关
  activated() {
    console.log('activated: 被 keep-alive 缓存的组件激活')
  },
  deactivated() {
    console.log('deactivated: 被 keep-alive 缓存的组件停用')
  }
}
```

### 2. Composition API 使用方式（推荐）

Vue 3 的 Composition API 提供了更灵活的生命周期管理方式：

```
<script setup>
import { 
  onBeforeMount, 
  onMounted, 
  onBeforeUpdate, 
  onUpdated, 
  onBeforeUnmount, 
  onUnmounted,
  onErrorCaptured,
  onActivated,
  onDeactivated,
  ref
} from 'vue'

const count = ref(0)
const timer = ref(null)

// 初始化阶段：在 setup 中直接编写代码
console.log('setup 执行，相当于 created 阶段')
console.log('count:', count.value) // 可访问响应式数据

// 挂载阶段
onBeforeMount(() => {
  console.log('onBeforeMount: 组件挂载前')
})

onMounted(() => {
  console.log('onMounted: 组件已挂载，可访问 DOM')
  console.log(document.getElementById('app'))
  
  // 示例：设置定时器
  timer.value = setInterval(() => {
    count.value++
  }, 1000)
})

// 更新阶段
onBeforeUpdate(() => {
  console.log('onBeforeUpdate: 数据更新前，当前值:', count.value)
})

onUpdated(() => {
  console.log('onUpdated: 数据更新后，当前值:', count.value)
  // 注意：避免在此修改响应式数据
})

// 卸载阶段
onBeforeUnmount(() => {
  console.log('onBeforeUnmount: 组件卸载前')
  clearInterval(timer.value) // 清理定时器
})

onUnmounted(() => {
  console.log('onUnmounted: 组件已卸载')
})

// 错误处理
onErrorCaptured((err, instance, info) => {
  console.log('onErrorCaptured: 捕获错误', err.message)
  return false // 阻止错误继续向上传播
})

// KeepAlive 相关
onActivated(() => {
  console.log('onActivated: 组件激活')
})

onDeactivated(() => {
  console.log('onDeactivated: 组件停用')
})

// 调试钩子（仅开发模式）
import { onRenderTracked, onRenderTriggered } from 'vue'

onRenderTracked((event) => {
  console.log('onRenderTracked: 跟踪到依赖', event)
})

onRenderTriggered((event) => {
  console.log('onRenderTriggered: 重新渲染被触发', event)
})
</script>

<template>
  <div>
    <h1>Count: {{ count }}</h1>
    <button @click="count++">增加</button>
  </div>
</template>
```

## 生命周期最佳实践

### 1. 各阶段适合做什么

|生命周期|常见用途|
|---|---|
|**created / setup**​|1. 发起异步数据请求  <br>2. 初始化非响应式数据  <br>3. 访问父组件传递的 props|
|**mounted**​|1. 操作 DOM 元素  <br>2. 初始化需要 DOM 的第三方库（如图表库）  <br>3. 添加事件监听器（但记得在 beforeUnmount 中移除）|
|**updated**​|1. 在 DOM 更新后执行操作（谨慎使用）  <br>2. 依赖 DOM 状态的第三方库更新|
|**beforeUnmount**​|1. 清理定时器  <br>2. 取消事件监听器  <br>3. 取消未完成的网络请求  <br>4. 清理全局状态或副作用|
|**errorCaptured**​|1. 捕获和处理子组件错误  <br>2. 向错误监控服务报告错误|

### 2. 常见陷阱与解决方案

```
// ❌ 错误示例：在 updated 中修改数据导致无限循环
onUpdated(() => {
  if (someCondition) {
    count.value++ // 可能触发无限更新
  }
})

// ✅ 正确做法：使用计算属性或侦听器
const doubleCount = computed(() => count.value * 2)

// 或使用 watch
watch(count, (newVal) => {
  if (newVal > 10) {
    // 执行操作
  }
})
```

### 3. 异步操作与生命周期

```
import { onMounted, ref } from 'vue'

const data = ref(null)
const loading = ref(false)
const error = ref(null)

onMounted(async () => {
  try {
    loading.value = true
    const response = await fetch('/api/data')
    data.value = await response.json()
  } catch (err) {
    error.value = err.message
  } finally {
    loading.value = false
  }
})
```

## Options API vs Composition API 生命周期对比

|场景|Options API|Composition API|推荐|
|---|---|---|---|
|**基本用法**​|作为组件选项的方法|从 'vue' 导入的函数|Composition API 更灵活|
|**代码组织**​|生命周期代码分散|相关逻辑可集中在一起|Composition API 更优|
|**复用性**​|通过 mixins 复用，但有命名冲突风险|通过自定义组合函数复用|Composition API 更优|
|**TypeScript 支持**​|一般|优秀|Composition API 更优|

## 实际应用场景示例

### 场景1：组件初始化时获取数据

```
<script setup>
import { onMounted, ref } from 'vue'
import { fetchUserData } from './api'

const user = ref(null)
const loading = ref(true)

onMounted(async () => {
  try {
    user.value = await fetchUserData()
  } catch (error) {
    console.error('获取用户数据失败:', error)
  } finally {
    loading.value = false
  }
})
</script>
```

### 场景2：监听窗口大小变化

```
<script setup>
import { onMounted, onBeforeUnmount, ref } from 'vue'

const windowWidth = ref(window.innerWidth)

const handleResize = () => {
  windowWidth.value = window.innerWidth
}

onMounted(() => {
  window.addEventListener('resize', handleResize)
})

onBeforeUnmount(() => {
  // 重要：清理事件监听
  window.removeEventListener('resize', handleResize)
})
</script>
```

### 场景3：与第三方库集成

```
<script setup>
import { onMounted, onBeforeUnmount, ref } from 'vue'
import Chart from 'chart.js/auto'

const chartRef = ref(null)
let chartInstance = null

onMounted(() => {
  const ctx = chartRef.value.getContext('2d')
  chartInstance = new Chart(ctx, {
    type: 'line',
    data: { /* 图表数据 */ },
    options: { /* 图表选项 */ }
  })
})

onBeforeUnmount(() => {
  // 清理图表实例，避免内存泄漏
  if (chartInstance) {
    chartInstance.destroy()
    chartInstance = null
  }
})
</script>
```

## 总结要点

1. **Vue 3 生命周期变化**：`beforeDestroy`→ `beforeUnmount`，`destroyed`→ `unmounted`
    
2. **Composition API 优势**：逻辑关注点集中，更好的代码组织和复用
    
3. **清理工作**：在 `beforeUnmount`/`onBeforeUnmount`中清理定时器、事件监听、异步操作
    
4. **避免陷阱**：不在 `updated`中修改响应式数据，避免无限循环
    
5. **调试工具**：`onRenderTracked`和 `onRenderTriggered`可用于性能优化和调试
    

理解 Vue 3 的生命周期有助于在正确的时机执行代码，避免常见错误，并编写更高效、可维护的组件。