在Maven项目中，测试的核心是使用像JUnit这样的测试框架，而**断言**是这些测试中用于验证代码行为是否符合预期的关键工具。简单来说，断言就是测试中的“裁判”，它将实际结果与预期结果进行比对，从而决定测试是通过还是失败。

下面这个表格汇总了JUnit 5提供的主要断言类型及其用途，可以帮助你快速了解。

|断言类别|关键方法示例|核心用途简介|
|---|---|---|
|**简单断言**​|`assertEquals`, `assertTrue`, `assertNull`|验证单个值或条件的真假。|
|**数组/集合断言**​|`assertArrayEquals`|验证两个数组或集合的内容是否完全相等。|
|**组合断言**​|`assertAll`|将多个断言归为一组，确保所有断言都被执行。|
|**异常断言**​|`assertThrows`|验证特定的代码块是否抛出了预期的异常。|
|**超时断言**​|`assertTimeout`|验证代码的执行时间是否在指定的时间限制内。|
|**快速失败**​|`fail`|直接使测试失败，通常用于特定分支条件（如不应进入的`if`语句）。|

### 💡 核心断言方法详解

让我们通过一些代码示例来具体了解这些断言的使用方法。以下示例基于一个简单的 `Calculator`类。

```
import static org.junit.jupiter.api.Assertions.*; // 静态导入是关键

class CalculatorTest {
    private final Calculator calculator = new Calculator();

    @Test
    void testAddition() {
        // 简单断言：验证 2 + 3 是否等于 5
        int result = calculator.add(2, 3);
        assertEquals(5, result, "加法计算错误"); // 第三个参数是断言失败时显示的消息。
    }

    @Test
    void testIsPositive() {
        // 使用 assertTrue 验证结果为正数
        int result = calculator.add(5, 10);
        assertTrue(result > 0, "结果应为正数");
    }

    @Test
    void testArraySorting() {
        // 数组断言：验证排序后的数组与预期一致
        int[] input = {3, 1, 2};
        int[] expected = {1, 2, 3};
        assertArrayEquals(expected, calculator.sort(input), "数组排序结果不符");
    }

    @Test
    void testDivideByZero() {
        // 异常断言：验证除以零时会抛出 ArithmeticException
        Exception exception = assertThrows(
            ArithmeticException.class,
            () -> calculator.divide(10, 0), // 使用Lambda表达式
            "预期除以零会抛出异常"
        );
        // 还可以进一步检查异常信息
        assertEquals("/ by zero", exception.getMessage());
    }

    @Test
    void testComplexOperation() {
        // 组合断言：所有断言都会执行，即使中间有失败也会继续
        int result = calculator.add(2, 3);
        assertAll("验证计算的多个属性",
            () -> assertEquals(5, result),
            () -> assertTrue(result > 0),
            () -> assertNotNull(result) // 验证结果不为null
        );
    }
}
```

### 🛠️ 进阶用法与最佳实践

掌握了基础用法后，了解一些进阶技巧和规范能让你的测试更加稳健和高效。

- **使用流式断言库**：对于复杂的对象、集合或字符串，可以借助像 **AssertJ**​ 这样的第三方库。它提供了一套**流式API**，让断言代码更易读、更易写。
    
    ```
    import static org.assertj.core.api.Assertions.assertThat;
    @Test
    void testWithAssertJ() {
        String name = "Alice";
        List<String> list = Arrays.asList("a", "b", "c");
        // AssertJ 的链式调用更自然
        assertThat(name).isEqualTo("Alice").startsWith("A").hasSize(5);
        assertThat(list).hasSize(3).contains("a").doesNotContain("z");
    }
    ```
    
- **遵循测试最佳实践**
    
    - **单一职责**：每个测试方法只验证一个明确的行为或场景。
        
    - **可读性至上**：为测试方法和方法内部的断言添加清晰的失败消息（如上例中的 `"加法计算错误"`）。
        
    - **测试隔离**：确保测试之间没有依赖，每个测试都应有独立的初始状态。
        
    

### ⚠️ 常见错误排查

刚开始编写测试时，可能会遇到以下问题：

- **异常断言写法错误**：在 JUnit 5 中，不能再使用 JUnit 4 的 `@Test(expected = ...)`方式。**必须使用 `assertThrows`方法**。
    
- **断言失败导致后续代码不执行**：一旦某个断言失败，同一次测试方法内的后续代码将不会被执行。这也是使用 `assertAll`来汇总多个相关检查的好处之一。
    

希望这份详细的说明能帮助你更好地在 Maven 测试中使用断言。如果你对某个特定场景的测试有更具体的问题，我很乐意继续探讨。