# Java继承详解

## 一、继承的基本概念

### 1. 什么是继承？

**继承**是面向对象三大特性之一，允许一个类（子类）继承另一个类（父类）的属性和方法。

```
// 父类（基类、超类）
class Animal {
    String name;
    int age;
    
    public void eat() {
        System.out.println(name + "正在吃东西");
    }
    
    public void sleep() {
        System.out.println(name + "正在睡觉");
    }
}

// 子类（派生类）
class Dog extends Animal {  // 使用extends关键字继承
    String breed;  // 子类特有的属性
    
    public void bark() {
        System.out.println(name + "在汪汪叫");
    }
}

// 子类
class Cat extends Animal {
    String color;
    
    public void meow() {
        System.out.println(name + "在喵喵叫");
    }
}

// 使用继承
public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.name = "旺财";  // 继承自Animal
        dog.age = 3;        // 继承自Animal
        dog.breed = "金毛";  // Dog特有
        dog.eat();          // 继承的方法 → "旺财正在吃东西"
        dog.bark();         // Dog的方法 → "旺财在汪汪叫"
        
        Cat cat = new Cat();
        cat.name = "小花";
        cat.color = "白色";
        cat.sleep();        // 继承的方法 → "小花正在睡觉"
        cat.meow();         // Cat的方法 → "小花在喵喵叫"
    }
}
```

---

## 二、继承的特点

### 1. 继承层次

```
// 多层继承
class Animal {
    String name;
    
    public void breathe() {
        System.out.println("呼吸");
    }
}

class Mammal extends Animal {  // 哺乳动物
    boolean hasFur = true;
    
    public void feedMilk() {
        System.out.println("哺乳");
    }
}

class Dog extends Mammal {  // 狗
    String breed;
    
    public void bark() {
        System.out.println("汪汪叫");
    }
}

class GuideDog extends Dog {  // 导盲犬
    boolean isTrained = true;
    
    public void guide() {
        System.out.println("引导盲人");
    }
}

// 使用
GuideDog guideDog = new GuideDog();
guideDog.name = "Lucky";     // 继承自Animal
guideDog.hasFur = true;      // 继承自Mammal
guideDog.breed = "拉布拉多";  // 继承自Dog
guideDog.isTrained = true;   // 自己的属性
guideDog.breathe();          // Animal的方法
guideDog.feedMilk();         // Mammal的方法
guideDog.bark();             // Dog的方法
guideDog.guide();            // 自己的方法
```

### 2. 单继承限制

```
// Java只支持单继承
class A {
    void methodA() {}
}

class B {
    void methodB() {}
}

// 错误的：不能多继承
// class C extends A, B {  // 编译错误
// }

// 正确的：单继承
class C extends A {
    void methodC() {}
}

// 但可以通过接口实现多继承
interface InterfaceA {
    void methodA();
}

interface InterfaceB {
    void methodB();
}

class D implements InterfaceA, InterfaceB {  // 多接口实现
    public void methodA() {}
    public void methodB() {}
}
```

### 3. 继承链

```
// Object是所有类的父类
class MyClass {
    // 隐式继承Object类
}

// 等价于
class MyClass extends Object {
    // Object类的方法都可以使用
}

// 验证
MyClass obj = new MyClass();
System.out.println(obj.toString());    // 继承自Object
System.out.println(obj.hashCode());    // 继承自Object
System.out.println(obj.getClass());    // 继承自Object
```

---

## 三、子类能继承的内容

### 1. 能继承的成员

```
class Parent {
    // 1. 公共属性
    public String publicField = "公共属性";
    
    // 2. 受保护属性
    protected String protectedField = "受保护属性";
    
    // 3. 默认访问权限属性（同包可访问）
    String defaultField = "默认属性";
    
    // 4. 私有属性 - ==不能直接继承==
    private String privateField = "私有属性";
    
    // 5. 静态属性
    public static String staticField = "静态属性";
    
    // 6. 常量
    public static final String CONSTANT = "常量";
    
    // 方法同样适用上述规则
    public void publicMethod() {
        System.out.println("公共方法");
    }
    
    protected void protectedMethod() {
        System.out.println("受保护方法");
    }
    
    void defaultMethod() {
        System.out.println("默认方法");
    }
    
    private void privateMethod() {
        System.out.println("私有方法");
    }
    
    public static void staticMethod() {
        System.out.println("静态方法");
    }
}

class Child extends Parent {
    public void testInheritance() {
        // 可以访问
        System.out.println(publicField);      // ✓
        System.out.println(protectedField);   // ✓
        System.out.println(defaultField);     // ✓ (同包时)
        // System.out.println(privateField);  // ✗ 不能访问私有属性
        
        publicMethod();      // ✓
        protectedMethod();   // ✓
        defaultMethod();     // ✓ (同包时)
        // privateMethod();  // ✗ 不能调用私有方法
        
        // 静态成员
        System.out.println(Parent.staticField);  // ✓
        System.out.println(CONSTANT);            // ✓
        Parent.staticMethod();                   // ✓
    }
}
```

### 2. 继承表格总结

|访问修饰符|同一个类|同一个包|子类（不同包）|其他类|能否继承|
|---|---|---|---|---|---|
|public|✓|✓|✓|✓|✓|
|protected|✓|✓|✓|✗|✓|
|默认|✓|✓|✗|✗|同包时✓|
|private|✓|✗|✗|✗|✗|

---

## 四、构造方法的继承

### 1. 构造方法调用规则

```
class Person {
    private String name;
    private int age;
    
    // 父类构造方法
    public Person() {
        System.out.println("Person无参构造方法");
    }
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
        System.out.println("Person有参构造方法: " + name + ", " + age);
    }
}

class Student extends Person {
    private String school;
    
    // 子类构造方法必须调用父类构造方法
    public Student() {
        // 隐式调用 super();
        System.out.println("Student无参构造方法");
    }
    
    public Student(String name, int age, String school) {
        super(name, age);  // 必须第一行
        this.school = school;
        System.out.println("Student有参构造方法: " + school);
    }
}

// 测试
public class Main {
    public static void main(String[] args) {
        System.out.println("创建Student对象:");
        Student stu1 = new Student();
        // 输出:
        // Person无参构造方法
        // Student无参构造方法
        
        System.out.println("\n创建有参Student对象:");
        Student stu2 = new Student("张三", 20, "清华大学");
        // 输出:
        // Person有参构造方法: 张三, 20
        // Student有参构造方法: 清华大学
    }
}
```

### 2. 构造方法调用顺序

```
class Grandparent {
    public Grandparent() {
        System.out.println("Grandparent构造方法");
    }
}

class Parent extends Grandparent {
    public Parent() {
        System.out.println("Parent构造方法");
    }
}

class Child extends Parent {
    public Child() {
        System.out.println("Child构造方法");
    }
}

// 测试
public class Main {
    public static void main(String[] args) {
        Child child = new Child();
        // 输出:
        // Grandparent构造方法
        // Parent构造方法
        // Child构造方法
        
        // 构造方法调用链: Object → Grandparent → Parent → Child
    }
}
```

---

## 五、方法重写（Override）

### 1. 基本重写

```
class Animal {
    public void makeSound() {
        System.out.println("动物发出声音");
    }
    
    public void eat() {
        System.out.println("动物吃东西");
    }
    
    // 不能重写的方法
    public final void finalMethod() {
        System.out.println("final方法，不能重写");
    }
    
    public static void staticMethod() {
        System.out.println("静态方法");
    }
    
    private void privateMethod() {
        System.out.println("私有方法");
    }
}

class Dog extends Animal {
    // 重写父类方法
    @Override
    public void makeSound() {
        System.out.println("狗汪汪叫");
    }
    
    // 使用super调用父类方法
    @Override
    public void eat() {
        super.eat();  // 先调用父类的eat
        System.out.println("狗吃骨头");
    }
    
    // 不能重写final方法
    // @Override
    // public void finalMethod() { }  // 编译错误
    
    // 这是隐藏，不是重写
    public static void staticMethod() {
        System.out.println("Dog的静态方法");
    }
    
    // 这不是重写，只是同名方法
    private void privateMethod() {
        System.out.println("Dog的私有方法");
    }
}

// 测试
public class Main {
    public static void main(String[] args) {
        Animal animal = new Dog();  // 多态
        animal.makeSound();  // "狗汪汪叫" - 运行时绑定
        animal.eat();        // 先"动物吃东西"，再"狗吃骨头"
        animal.finalMethod(); // "final方法，不能重写"
        
        // 静态方法
        Animal.staticMethod();  // "静态方法" - 编译时绑定
        Dog.staticMethod();     // "Dog的静态方法"
    }
}
```

### 2. 重写规则

```
class Parent {
    // 访问权限
    protected void method1() {
        System.out.println("父类method1");
    }
    
    // 返回值类型
    public Object method2() {
        return new Object();
    }
    
    // 抛出异常
    public void method3() throws IOException {
        throw new IOException();
    }
}

class Child extends Parent {
    // ✓ 可以扩大访问权限
    @Override
    public void method1() {
        System.out.println("子类method1");
    }
    
    // ✓ 可以缩小返回值类型（协变返回类型）
    @Override
    public String method2() {
        return "Hello";
    }
    
    // ✓ 可以不抛出异常
    @Override
    public void method3() {
        // 不抛出异常
    }
    
    // ✗ 不能缩小访问权限
    // @Override
    // void method1() { }  // 编译错误
    
    // ✗ 不能扩大异常范围
    // @Override
    // public void method3() throws Exception { }  // 编译错误
}
```

---

## 六、super关键字

### 1. super的用法

```
class Vehicle {
    String brand = "通用品牌";
    int maxSpeed = 120;
    
    public Vehicle() {
        System.out.println("Vehicle构造方法");
    }
    
    public Vehicle(String brand) {
        this.brand = brand;
    }
    
    public void start() {
        System.out.println("车辆启动");
    }
    
    public void displayInfo() {
        System.out.println("品牌: " + brand + ", 最高速度: " + maxSpeed);
    }
}

class Car extends Vehicle {
    String brand = "汽车品牌";  // 隐藏父类brand
    int maxSpeed = 180;         // 隐藏父类maxSpeed
    String model = "Model X";
    
    public Car() {
        // 1. 调用父类构造方法
        super();  // 调用Vehicle()
        System.out.println("Car构造方法");
    }
    
    public Car(String brand, String model) {
        // 调用父类有参构造
        super(brand);
        this.model = model;
    }
    
    @Override
    public void start() {
        // 2. 调用父类方法
        super.start();
        System.out.println("汽车启动，检查安全系统");
    }
    
    public void displayCarInfo() {
        // 3. 访问父类属性
        System.out.println("父类品牌: " + super.brand);
        System.out.println("子类品牌: " + this.brand);
        System.out.println("父类速度: " + super.maxSpeed);
        System.out.println("子类速度: " + this.maxSpeed);
        
        // 调用父类方法
        super.displayInfo();
    }
}

// 测试
public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.start();
        car.displayCarInfo();
    }
}
```

### 2. super在多层继承中的使用

```
class A {
    int value = 10;
    
    public void show() {
        System.out.println("A: " + value);
    }
}

class B extends A {
    int value = 20;
    
    @Override
    public void show() {
        System.out.println("B: " + value);
        System.out.println("A.value: " + super.value);
    }
}

class C extends B {
    int value = 30;
    
    @Override
    public void show() {
        System.out.println("C: " + value);
        System.out.println("B.value: " + super.value);
        
        // 不能跳过B直接访问A
        // System.out.println(super.super.value);  // 编译错误
        
        // 但可以通过调用父类方法间接访问
        super.show();  // 调用B的show方法
    }
}
```

---

## 七、final关键字与继承

### 1. final类

```
// final类不能被继承
final class FinalClass {
    public void method() {
        System.out.println("FinalClass method");
    }
}

// 编译错误：不能继承final类
// class SubClass extends FinalClass { }

// 常用final类：String, Integer, System等
String str = "Hello";  // String是final类
```

### 2. final方法

```
class Parent {
    // final方法不能被子类重写
    public final void cannotOverride() {
        System.out.println("这个方法不能重写");
    }
    
    public void canOverride() {
        System.out.println("这个方法可以重写");
    }
}

class Child extends Parent {
    // ✓ 可以重写非final方法
    @Override
    public void canOverride() {
        System.out.println("重写了父类方法");
    }
    
    // ✗ 不能重写final方法
    // @Override
    // public void cannotOverride() { }  // 编译错误
}
```

### 3. final变量

```
class Constants {
    // 常量
    public static final double PI = 3.14159;
    public static final int MAX_VALUE = 100;
    
    public void test() {
        final int localFinal = 10;  // 局部final变量
        // localFinal = 20;  // 编译错误，不能修改
        
        final StringBuilder sb = new StringBuilder("Hello");
        sb.append(" World");  // ✓ 可以修改对象内容
        // sb = new StringBuilder();  // ✗ 不能重新赋值
    }
}
```

---

## 八、抽象类和继承

### 1. 抽象类继承

```
// 抽象类
abstract class Animal {
    protected String name;
    
    public Animal(String name) {
        this.name = name;
    }
    
    // 抽象方法 - ==必须被子类实现==
    public abstract void makeSound();
    
    // 具体方法
    public void sleep() {
        System.out.println(name + "正在睡觉");
    }
}

// 具体子类
class Dog extends Animal {
    public Dog(String name) {
        super(name);
    }
    
    // 必须实现抽象方法
    @Override
    public void makeSound() {
        System.out.println(name + "汪汪叫");
    }
    
    // 可以添加自己的方法
    public void fetch() {
        System.out.println(name + "在接飞盘");
    }
}

// 抽象子类
abstract class Bird extends Animal {
    public Bird(String name) {
        super(name);
    }
    
    // 可以不实现抽象方法
    public abstract void fly();
}

// 具体子类的子类
class Sparrow extends Bird {
    public Sparrow(String name) {
        super(name);
    }
    
    // 必须实现所有抽象方法
    @Override
    public void makeSound() {
        System.out.println(name + "叽叽喳喳");
    }
    
    @Override
    public void fly() {
        System.out.println(name + "在飞翔");
    }
}
```

---

## 九、继承的实用案例

### 案例1：员工管理系统

```
// 基类：员工
class Employee {
    protected String name;
    protected int id;
    protected double baseSalary;
    
    public Employee(String name, int id, double baseSalary) {
        this.name = name;
        this.id = id;
        this.baseSalary = baseSalary;
    }
    
    // 计算工资（需要在子类中重写）
    public double calculateSalary() {
        return baseSalary;
    }
    
    public void displayInfo() {
        System.out.println("员工ID: " + id);
        System.out.println("姓名: " + name);
        System.out.println("基本工资: " + baseSalary);
    }
}

// 子类1：普通员工
class RegularEmployee extends Employee {
    private int overtimeHours;  // 加班小时
    
    public RegularEmployee(String name, int id, double baseSalary, int overtimeHours) {
        super(name, id, baseSalary);
        this.overtimeHours = overtimeHours;
    }
    
    @Override
    public double calculateSalary() {
        // 基本工资 + 加班费（每小时50）
        return baseSalary + overtimeHours * 50;
    }
    
    @Override
    public void displayInfo() {
        super.displayInfo();
        System.out.println("加班小时: " + overtimeHours);
        System.out.println("实发工资: " + calculateSalary());
    }
}

// 子类2：经理
class Manager extends Employee {
    private double bonus;  // 奖金
    
    public Manager(String name, int id, double baseSalary, double bonus) {
        super(name, id, baseSalary);
        this.bonus = bonus;
    }
    
    @Override
    public double calculateSalary() {
        // 基本工资 + 奖金
        return baseSalary + bonus;
    }
    
    @Override
    public void displayInfo() {
        super.displayInfo();
        System.out.println("奖金: " + bonus);
        System.out.println("实发工资: " + calculateSalary());
    }
    
    // 经理特有方法
    public void holdMeeting() {
        System.out.println(name + "正在主持会议");
    }
}

// 子类3：销售
class SalesPerson extends Employee {
    private double salesAmount;  // 销售额
    private double commissionRate;  // 提成比例
    
    public SalesPerson(String name, int id, double baseSalary, 
                      double salesAmount, double commissionRate) {
        super(name, id, baseSalary);
        this.salesAmount = salesAmount;
        this.commissionRate = commissionRate;
    }
    
    @Override
    public double calculateSalary() {
        // 基本工资 + 销售额 * 提成比例
        return baseSalary + salesAmount * commissionRate;
    }
    
    @Override
    public void displayInfo() {
        super.displayInfo();
        System.out.println("销售额: " + salesAmount);
        System.out.println("提成比例: " + commissionRate);
        System.out.println("实发工资: " + calculateSalary());
    }
}

// 测试
public class EmployeeSystem {
    public static void main(String[] args) {
        Employee[] employees = {
            new RegularEmployee("张三", 1001, 5000, 20),
            new Manager("李四", 1002, 8000, 3000),
            new SalesPerson("王五", 1003, 4000, 100000, 0.1)
        };
        
        for (Employee emp : employees) {
            System.out.println("--- 员工信息 ---");
            emp.displayInfo();
            System.out.println();
        }
    }
}
```

### 案例2：图形系统

```
// 抽象基类：图形
abstract class Shape {
    protected String color;
    
    public Shape(String color) {
        this.color = color;
    }
    
    // 抽象方法
    public abstract double getArea();
    public abstract double getPerimeter();
    
    // 具体方法
    public void display() {
        System.out.println("图形颜色: " + color);
        System.out.println("面积: " + getArea());
        System.out.println("周长: " + getPerimeter());
    }
}

// 子类1：圆形
class Circle extends Shape {
    private double radius;
    
    public Circle(String color, double radius) {
        super(color);
        this.radius = radius;
    }
    
    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }
    
    @Override
    public double getPerimeter() {
        return 2 * Math.PI * radius;
    }
    
    // 特有方法
    public double getDiameter() {
        return 2 * radius;
    }
}

// 子类2：矩形
class Rectangle extends Shape {
    private double width;
    private double height;
    
    public Rectangle(String color, double width, double height) {
        super(color);
        this.width = width;
        this.height = height;
    }
    
    @Override
    public double getArea() {
        return width * height;
    }
    
    @Override
    public double getPerimeter() {
        return 2 * (width + height);
    }
    
    // 特有方法
    public boolean isSquare() {
        return width == height;
    }
}

// 子类3：三角形
class Triangle extends Shape {
    private double sideA;
    private double sideB;
    private double sideC;
    
    public Triangle(String color, double a, double b, double c) {
        super(color);
        this.sideA = a;
        this.sideB = b;
        this.sideC = c;
    }
    
    @Override
    public double getArea() {
        // 海伦公式
        double s = (sideA + sideB + sideC) / 2;
        return Math.sqrt(s * (s - sideA) * (s - sideB) * (s - sideC));
    }
    
    @Override
    public double getPerimeter() {
        return sideA + sideB + sideC;
    }
    
    // 判断三角形类型
    public String getType() {
        if (sideA == sideB && sideB == sideC) {
            return "等边三角形";
        } else if (sideA == sideB || sideA == sideC || sideB == sideC) {
            return "等腰三角形";
        } else {
            return "不等边三角形";
        }
    }
}
```

---

## 十、继承的注意事项和最佳实践

### 1. 继承的陷阱

```
// 陷阱1：构造方法调用不当
class Parent {
    public Parent() {
        doSomething();  // 在构造方法中调用可重写的方法
    }
    
    public void doSomething() {
        System.out.println("Parent doSomething");
    }
}

class Child extends Parent {
    private String data = "Child Data";
    
    public Child() {
        super();
        data = "Initialized";
    }
    
    @Override
    public void doSomething() {
        System.out.println("Child doSomething: " + data);
        // data可能为null，因为父类构造方法先执行
    }
}

// 测试
Child child = new Child();
// 输出: Child doSomething: null
// 问题：在子类完全初始化前调用了子类的方法
```

### 2. 组合优于继承

```
// 不好的设计：使用继承
class Stack extends ArrayList<Object> {
    public void push(Object item) {
        add(item);
    }
    
    public Object pop() {
        if (isEmpty()) return null;
        return remove(size() - 1);
    }
    // 问题：暴露了ArrayList的所有方法
}

// 好的设计：使用组合
class BetterStack {
    private ArrayList<Object> list = new ArrayList<>();
    
    public void push(Object item) {
        list.add(item);
    }
    
    public Object pop() {
        if (list.isEmpty()) return null;
        return list.remove(list.size() - 1);
    }
    
    public boolean isEmpty() {
        return list.isEmpty();
    }
    // 只暴露必要的方法
}
```

### 3. 最佳实践

```
// 1. 使用@Override注解
class Base {
    public void method() { }
}

class Derived extends Base {
    @Override  // 编译器会检查是否正确重写
    public void method() { }
}

// 2. 遵循Liskov替换原则
// 子类应该能够替换父类

// 3. 使用protected而不是public用于继承
class BaseClass {
    protected void doInternalWork() {
        // 子类可以访问，外部不能访问
    }
}

// 4. 考虑使用final防止继承
// 如果不希望被继承，声明为final
final class UtilityClass {
    private UtilityClass() { }  // 私有构造方法
    public static void utilityMethod() { }
}
```

---

## 十一、继承相关面试题

### 1. 继承与组合的区别？

```
// 继承：is-a关系
class Car extends Vehicle {  // 汽车是一种交通工具
    // ...
}

// 组合：has-a关系
class Engine { /* 引擎类 */ }

class Car {
    private Engine engine;  // 汽车有一个引擎
    // ...
}
```

### 2. 什么时候用继承？

- 存在明确的 is-a 关系
    
- 需要多态特性
    
- 父类的功能确实需要复用
    
- 子类需要扩展或修改父类行为
    

### 3. 继承的优缺点？

**优点：**

- 代码复用
    
- 易于维护
    
- 支持多态
    

**缺点：**

- 破坏封装性
    
- 增加耦合度
    
- 可能违反Liskov替换原则
    

---

## 十二、练习题

### 练习1：银行账户系统

```
// 创建银行账户基类，包含账号、余额、存款、取款方法
// 创建子类：储蓄账户（有年利率）、信用卡账户（有信用额度）
// 创建子类：VIP账户（有专属服务）

abstract class BankAccount {
    // TODO: 实现
}
```

### 练习2：动物王国

```
// 创建动物基类，包含移动、进食、发出声音方法
// 创建哺乳动物、鸟类、鱼类子类
// 创建具体动物：狗、猫、鸟、鱼

class Animal {
    // TODO: 实现
}
```

### 练习3：交通工具系统

```
// 创建交通工具基类
// 创建子类：汽车（有品牌、型号）、飞机（有飞行高度）、船（有排水量）
// 实现各自的移动方式

abstract class Vehicle {
    public abstract void move();
}
```

---

## 总结

### 继承核心要点：

1. **extends关键字**：用于继承
    
2. **访问权限**：public、protected可继承，private不能
    
3. **super关键字**：访问父类成员
    
4. **方法重写**：使用@Override，遵循规则
    
5. **构造方法**：子类必须调用父类构造
    
6. **单继承**：Java只支持单继承
    
7. **final**：防止继承或重写
    
8. **抽象类**：包含抽象方法的类
    

### 继承使用建议：

- 优先考虑组合
    
- 继承关系应该是永久的
    
- 子类应该是父类的特化
    
- 避免在构造方法中调用可重写的方法
    
- 使用protected控制继承访问