# Java接口和抽象类详解

## 一、接口（Interface）

### 1. 接口的基本概念

接口是一种**完全抽象**的类型，用于定义一组**规范**或**契约**。

```
// 定义接口
interface USB {
    // 常量（默认 public static final）
    String VERSION = "3.0";
    
    // 抽象方法（默认 public abstract）
    void connect();
    void transferData();
    void disconnect();
}

// 实现接口
class Mouse implements USB {
    @Override
    public void connect() {
        System.out.println("鼠标已连接");
    }
    
    @Override
    public void transferData() {
        System.out.println("传输鼠标移动数据");
    }
    
    @Override
    public void disconnect() {
        System.out.println("鼠标已断开");
    }
}

class Keyboard implements USB {
    @Override
    public void connect() {
        System.out.println("键盘已连接");
    }
    
    @Override
    public void transferData() {
        System.out.println("传输键盘输入数据");
    }
    
    @Override
    public void disconnect() {
        System.out.println("键盘已断开");
    }
}

// 使用接口
public class InterfaceDemo {
    public static void main(String[] args) {
        USB mouse = new Mouse();
        USB keyboard = new Keyboard();
        
        testDevice(mouse);
        testDevice(keyboard);
        
        // 访问接口常量
        System.out.println("USB版本: " + USB.VERSION);
    }
    
    public static void testDevice(USB device) {
        device.connect();
        device.transferData();
        device.disconnect();
        System.out.println("---");
    }
}
```

### 2. 接口的新特性（Java 8+）

#### 2.1 默认方法

```
interface Vehicle {
    // 抽象方法
    void start();
    void stop();
    
    // 默认方法（Java 8+）
    default void honk() {
        System.out.println("车辆鸣笛");
    }
    
    // 另一个默认方法
    default void checkFuel() {
        System.out.println("检查燃油");
    }
    
    // 静态方法（Java 8+）
    static void showInfo() {
        System.out.println("这是一个交通工具接口");
    }
}

class Car implements Vehicle {
    @Override
    public void start() {
        System.out.println("汽车启动");
    }
    
    @Override
    public void stop() {
        System.out.println("汽车停止");
    }
    
    // 可以重写默认方法
    @Override
    public void honk() {
        System.out.println("汽车喇叭: 滴滴！");
    }
}

class Bike implements Vehicle {
    @Override
    public void start() {
        System.out.println("自行车开始骑行");
    }
    
    @Override
    public void stop() {
        System.out.println("自行车停止");
    }
    
    // 不重写honk()，使用默认实现
}

// 使用
public class DefaultMethodDemo {
    public static void main(String[] args) {
        Car car = new Car();
        car.start();
        car.honk();      // 重写的实现
        car.checkFuel(); // 默认实现
        car.stop();
        
        System.out.println("---");
        
        Bike bike = new Bike();
        bike.start();
        bike.honk();     // 默认实现
        bike.stop();
        
        // 调用静态方法
        Vehicle.showInfo();
    }
}
```

#### 2.2 私有方法（Java 9+）

```
interface Database {
    // 抽象方法
    void connect(String url, String user, String password);
    void executeQuery(String sql);
    void close();
    
    // 默认方法
    default void connectWithDefault() {
        // 调用私有方法准备连接参数
        String url = getDefaultUrl();
        String user = getDefaultUser();
        String password = getDefaultPassword();
        
        // 调用私有方法验证参数
        validateConnectionParams(url, user, password);
        
        connect(url, user, password);
    }
    
    // 私有方法 - 工具方法
    private String getDefaultUrl() {
        return "jdbc:mysql://localhost:3306/mydb";
    }
    
    private String getDefaultUser() {
        return "root";
    }
    
    private String getDefaultPassword() {
        return "password";
    }
    
    // 私有静态方法
    private static void validateConnectionParams(String url, String user, String password) {
        if (url == null || url.isEmpty()) {
            throw new IllegalArgumentException("URL不能为空");
        }
        if (user == null || user.isEmpty()) {
            throw new IllegalArgumentException("用户名不能为空");
        }
    }
    
    // 静态方法
    static void printDriverInfo() {
        System.out.println("MySQL Connector/J 8.0");
    }
}
```

### 3. 多接口实现

```
// 接口1
interface Flyable {
    void fly();
    
    default void takeOff() {
        System.out.println("准备起飞");
    }
}

// 接口2
interface Swimmable {
    void swim();
    
    default void dive() {
        System.out.println("潜入水中");
    }
}

// 接口3
interface Runnable {
    void run();
    
    default void walk() {
        System.out.println("行走");
    }
}

// 接口继承接口
interface Amphibious extends Swimmable, Runnable {
    void liveBoth();
}

// 类实现多个接口
class Duck implements Flyable, Swimmable, Runnable {
    @Override
    public void fly() {
        System.out.println("鸭子在低空飞行");
    }
    
    @Override
    public void swim() {
        System.out.println("鸭子在游泳");
    }
    
    @Override
    public void run() {
        System.out.println("鸭子在跑");
    }
    
    // 如果多个接口有同名默认方法，必须重写
    @Override
    public void walk() {
        // 明确指定使用哪个接口的默认方法
        Runnable.super.walk();
        System.out.println("鸭子走路摇摆");
    }
}

// 实现继承的接口
class Frog implements Amphibious {
    @Override
    public void swim() {
        System.out.println("青蛙游泳");
    }
    
    @Override
    public void run() {
        System.out.println("青蛙跳跃");
    }
    
    @Override
    public void liveBoth() {
        System.out.println("青蛙是两栖动物");
    }
}

// 使用
public class MultipleInterfaceDemo {
    public static void main(String[] args) {
        Duck duck = new Duck();
        duck.fly();
        duck.swim();
        duck.run();
        duck.takeOff();
        duck.dive();
        duck.walk();
        
        System.out.println("---");
        
        Frog frog = new Frog();
        frog.swim();
        frog.run();
        frog.liveBoth();
        frog.dive();
        frog.walk();
        
        // 多态
        testAnimal(duck);
        testAnimal(frog);
    }
    
    public static void testAnimal(Object animal) {
        if (animal instanceof Flyable) {
            ((Flyable) animal).fly();
        }
        if (animal instanceof Swimmable) {
            ((Swimmable) animal).swim();
        }
        if (animal instanceof Runnable) {
            ((Runnable) animal).run();
        }
    }
}
```

### 4. 函数式接口（Java 8+）

```
// 函数式接口：只有一个抽象方法的接口
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);
    
    // 可以有默认方法
    default void printResult(int result) {
        System.out.println("结果: " + result);
    }
    
    // 可以有静态方法
    static Calculator getDefault() {
        return (a, b) -> a + b;
    }
    
    // 可以有Object类的方法
    @Override
    boolean equals(Object obj);
}

// 使用Lambda表达式实现
public class FunctionalInterfaceDemo {
    public static void main(String[] args) {
        // 传统实现
        Calculator adder = new Calculator() {
            @Override
            public int calculate(int a, int b) {
                return a + b;
            }
        };
        
        // Lambda表达式
        Calculator adderLambda = (a, b) -> a + b;
        Calculator multiplier = (a, b) -> a * b;
        Calculator subtractor = (a, b) -> a - b;
        Calculator divider = (a, b) -> a / b;
        
        // 使用
        System.out.println("10 + 5 = " + adderLambda.calculate(10, 5));
        System.out.println("10 * 5 = " + multiplier.calculate(10, 5));
        
        // 作为方法参数
        int result = operate(10, 5, adderLambda);
        System.out.println("操作结果: " + result);
        
        result = operate(10, 5, (a, b) -> a * a + b * b);
        System.out.println("a² + b² = " + result);
        
        // 使用内置函数式接口
        java.util.function.Predicate<String> isEmpty = s -> s == null || s.isEmpty();
        java.util.function.Function<String, Integer> length = String::length;
        java.util.function.Consumer<String> printer = System.out::println;
        
        System.out.println("字符串是否为空: " + isEmpty.test(""));
        System.out.println("字符串长度: " + length.apply("Hello"));
        printer.accept("Hello World");
    }
    
    public static int operate(int a, int b, Calculator calculator) {
        return calculator.calculate(a, b);
    }
}
```

---

## 二、抽象类（Abstract Class）

### 1. 抽象类的基本概念

抽象类是**部分抽象**的类，可以包含抽象方法和具体方法。

```
// 抽象类
abstract class Animal {
    // 实例变量
    protected String name;
    protected int age;
    
    // 构造方法
    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // 抽象方法 - 子类必须实现
    public abstract void makeSound();
    public abstract void move();
    
    // 具体方法 - 子类可以继承
    public void eat() {
        System.out.println(name + "正在吃东西");
    }
    
    public void sleep() {
        System.out.println(name + "正在睡觉");
    }
    
    // 可以有静态方法
    public static void showInfo() {
        System.out.println("这是一个动物类");
    }
    
    // 可以有final方法
    public final void breathe() {
        System.out.println("动物在呼吸");
    }
    
    // 可以有静态变量
    public static final String KINGDOM = "Animalia";
    
    // 可以有main方法
    public static void main(String[] args) {
        System.out.println("抽象类的main方法");
    }
}

// 具体子类
class Dog extends Animal {
    private String breed;
    
    public Dog(String name, int age, String breed) {
        super(name, age);
        this.breed = breed;
    }
    
    @Override
    public void makeSound() {
        System.out.println(name + "（" + breed + "）汪汪叫");
    }
    
    @Override
    public void move() {
        System.out.println(name + "用四条腿跑");
    }
    
    // 特有方法
    public void fetch() {
        System.out.println(name + "在接飞盘");
    }
}

class Bird extends Animal {
    private boolean canFly;
    
    public Bird(String name, int age, boolean canFly) {
        super(name, age);
        this.canFly = canFly;
    }
    
    @Override
    public void makeSound() {
        System.out.println(name + "叽叽喳喳");
    }
    
    @Override
    public void move() {
        if (canFly) {
            System.out.println(name + "在飞翔");
        } else {
            System.out.println(name + "在跳跃");
        }
    }
    
    // 重写父类方法
    @Override
    public void eat() {
        System.out.println(name + "正在啄食");
    }
}

// 使用
public class AbstractClassDemo {
    public static void main(String[] args) {
        // 不能创建抽象类的实例
        // Animal animal = new Animal();  // 编译错误
        
        Dog dog = new Dog("旺财", 3, "金毛");
        dog.makeSound();
        dog.move();
        dog.eat();
        dog.sleep();
        dog.breathe();  // 继承的final方法
        dog.fetch();    // 特有方法
        
        System.out.println("---");
        
        Bird bird = new Bird("小翠", 2, true);
        bird.makeSound();
        bird.move();
        bird.eat();     // 重写的方法
        bird.sleep();
        
        // 多态
        Animal[] animals = {dog, bird};
        for (Animal animal : animals) {
            animal.makeSound();
            animal.move();
            System.out.println("---");
        }
        
        // 访问静态成员
        System.out.println("生物界: " + Animal.KINGDOM);
        Animal.showInfo();
    }
}
```

### 2. 抽象类的模板方法模式

```
// 模板方法模式示例
abstract class DataProcessor {
    // 模板方法 - 定义算法骨架
    public final void processData() {
        validateData();
        preprocessData();
        doProcess();
        postprocessData();
        saveResult();
    }
    
    // 具体方法
    private void validateData() {
        System.out.println("验证数据...");
    }
    
    private void saveResult() {
        System.out.println("保存结果...");
    }
    
    // 抽象方法 - 由子类实现
    protected abstract void preprocessData();
    protected abstract void doProcess();
    protected abstract void postprocessData();
    
    // 钩子方法 - 可选重写
    protected boolean needPostprocess() {
        return true;
    }
}

// 具体处理器
class CSVProcessor extends DataProcessor {
    @Override
    protected void preprocessData() {
        System.out.println("CSV预处理: 解析CSV格式");
    }
    
    @Override
    protected void doProcess() {
        System.out.println("CSV处理: 计算统计数据");
    }
    
    @Override
    protected void postprocessData() {
        System.out.println("CSV后处理: 生成报告");
    }
}

class JSONProcessor extends DataProcessor {
    @Override
    protected void preprocessData() {
        System.out.println("JSON预处理: 解析JSON结构");
    }
    
    @Override
    protected void doProcess() {
        System.out.println("JSON处理: 转换数据格式");
    }
    
    @Override
    protected void postprocessData() {
        System.out.println("JSON后处理: 验证数据完整性");
    }
    
    // 重写钩子方法
    @Override
    protected boolean needPostprocess() {
        return false;  // JSON处理不需要后处理
    }
}

// 使用
public class TemplateMethodDemo {
    public static void main(String[] args) {
        DataProcessor csvProcessor = new CSVProcessor();
        csvProcessor.processData();
        
        System.out.println("---");
        
        DataProcessor jsonProcessor = new JSONProcessor();
        jsonProcessor.processData();
    }
}
```

### 3. 抽象类与构造方法

```
// 抽象类的继承链
abstract class Shape {
    protected String color;
    protected boolean filled;
    
    // 构造方法
    public Shape() {
        this("黑色", false);
    }
    
    public Shape(String color, boolean filled) {
        this.color = color;
        this.filled = filled;
        System.out.println("Shape构造方法: " + color + ", " + filled);
    }
    
    public abstract double getArea();
    public abstract double getPerimeter();
    
    public String getColor() {
        return color;
    }
    
    public void setColor(String color) {
        this.color = color;
    }
}

abstract class TwoDShape extends Shape {
    protected double x, y;  // 位置
    
    public TwoDShape(String color, boolean filled, double x, double y) {
        super(color, filled);
        this.x = x;
        this.y = y;
        System.out.println("TwoDShape构造方法: (" + x + ", " + y + ")");
    }
    
    public abstract void draw();
}

class Circle extends TwoDShape {
    private double radius;
    
    public Circle(double radius, String color, boolean filled, double x, double y) {
        super(color, filled, x, y);
        this.radius = radius;
        System.out.println("Circle构造方法: 半径=" + radius);
    }
    
    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }
    
    @Override
    public double getPerimeter() {
        return 2 * Math.PI * radius;
    }
    
    @Override
    public void draw() {
        System.out.println("绘制圆形: 半径=" + radius + 
                          ", 位置=(" + x + ", " + y + ")" +
                          ", 颜色=" + color);
    }
}

class Rectangle extends TwoDShape {
    private double width, height;
    
    public Rectangle(double width, double height, String color, boolean filled, double x, double y) {
        super(color, filled, x, y);
        this.width = width;
        this.height = height;
        System.out.println("Rectangle构造方法: 宽=" + width + ", 高=" + height);
    }
    
    @Override
    public double getArea() {
        return width * height;
    }
    
    @Override
    public double getPerimeter() {
        return 2 * (width + height);
    }
    
    @Override
    public void draw() {
        System.out.println("绘制矩形: 宽=" + width + ", 高=" + height +
                          ", 位置=(" + x + ", " + y + ")" +
                          ", 颜色=" + color);
    }
}

// 使用
public class AbstractConstructorDemo {
    public static void main(String[] args) {
        System.out.println("创建圆形:");
        Circle circle = new Circle(5.0, "红色", true, 10, 20);
        circle.draw();
        System.out.println("面积: " + circle.getArea());
        
        System.out.println("\n创建矩形:");
        Rectangle rect = new Rectangle(4.0, 6.0, "蓝色", false, 30, 40);
        rect.draw();
        System.out.println("周长: " + rect.getPerimeter());
    }
}
```

---

## 三、接口 vs 抽象类

### 1. 核心区别对比

```
// 表格形式展示
/*

| 特性 | 抽象类 (Abstract Class) | 接口 (Interface) |
|------|------------------------|------------------|
| 定义 | abstract class A { } | interface I { } |
| 继承 | 单继承 (extends) | 多实现 (implements) |
| 构造方法 | 有 | 无 |
| 成员变量 | 任意类型 | 只能是 public static final 常量 |
| 方法实现 | 可以有具体方法 | Java 8前只能是抽象方法 |
| 访问修饰符 | 任意 | 默认 public |
| 设计目的 | 代码复用，is-a关系 | 定义规范，has-a关系 |
| 使用场景 | 有共同代码的类层次结构 | 定义API，回调，策略模式 |

*/

// 代码示例对比
abstract class AnimalBase {  // 抽象类
    // 可以有构造方法
    public AnimalBase(String name) {
        this.name = name;
    }
    
    // 可以有实例变量
    protected String name;
    private int age;  // 可以是private
    
    // 可以有具体方法
    public void eat() {
        System.out.println(name + "正在吃东西");
    }
    
    // 可以有抽象方法
    public abstract void makeSound();
    
    // 可以有静态方法
    public static void breathe() {
        System.out.println("呼吸");
    }
    
    // 可以有final方法
    public final void live() {
        System.out.println("活着");
    }
    
    // 可以有main方法
    public static void main(String[] args) {
        System.out.println("抽象类main方法");
    }
}

interface AnimalBehavior {  // 接口
    // 不能有构造方法
    // public AnimalBehavior() { }  // 错误
    
    // 只能是常量
    String TYPE = "动物行为";  // 默认 public static final
    
    // 不能有实例变量
    // private String name;  // 错误
    
    // 可以有抽象方法
    void makeSound();
    
    // 可以有默认方法（Java 8+）
    default void sleep() {
        System.out.println("睡觉");
    }
    
    // 可以有静态方法（Java 8+）
    static void showInfo() {
        System.out.println("动物行为接口");
    }
    
    // 可以有私有方法（Java 9+）
    private void internalMethod() {
        System.out.println("内部方法");
    }
    
    // 可以有main方法
    public static void main(String[] args) {
        System.out.println("接口main方法");
    }
}
```

### 2. 选择指南

```
// 情况1：使用抽象类
// 当有多个相关类共享代码时
abstract class PaymentProcessor {
    protected String transactionId;
    protected double amount;
    
    // 共享的验证逻辑
    protected boolean validate() {
        return amount > 0;
    }
    
    // 共享的日志逻辑
    protected void logTransaction() {
        System.out.println("记录交易: " + transactionId);
    }
    
    // 子类必须实现的抽象方法
    public abstract void process();
    
    // 模板方法
    public final void execute() {
        if (validate()) {
            process();
            logTransaction();
        }
    }
}

class CreditCardProcessor extends PaymentProcessor {
    private String cardNumber;
    
    @Override
    public void process() {
        System.out.println("处理信用卡支付: " + cardNumber);
    }
}

class PayPalProcessor extends PaymentProcessor {
    private String email;
    
    @Override
    public void process() {
        System.out.println("处理PayPal支付: " + email);
    }
}

// 情况2：使用接口
// 当需要定义规范，不关心实现时
interface NotificationService {
    void send(String message, String recipient);
    boolean isAvailable();
}

class EmailService implements NotificationService {
    @Override
    public void send(String message, String recipient) {
        System.out.println("发送邮件到 " + recipient + ": " + message);
    }
    
    @Override
    public boolean isAvailable() {
        return true;
    }
}

class SMSService implements NotificationService {
    @Override
    public void send(String message, String recipient) {
        System.out.println("发送短信到 " + recipient + ": " + message);
    }
    
    @Override
    public boolean isAvailable() {
        return true;
    }
}

class PushService implements NotificationService {
    @Override
    public void send(String message, String recipient) {
        System.out.println("发送推送通知到 " + recipient + ": " + message);
    }
    
    @Override
    public boolean isAvailable() {
        return true;
    }
}

// 情况3：结合使用
// 抽象类实现接口，提供基础实现
interface List<T> {
    void add(T element);
    T get(int index);
    int size();
    boolean isEmpty();
}

abstract class AbstractList<T> implements List<T> {
    protected int size = 0;
    
    @Override
    public int size() {
        return size;
    }
    
    @Override
    public boolean isEmpty() {
        return size == 0;
    }
    
    // 抽象方法
    protected abstract void ensureCapacity();
}

class ArrayList<T> extends AbstractList<T> {
    private Object[] elements = new Object[10];
    
    @Override
    public void add(T element) {
        ensureCapacity();
        elements[size++] = element;
    }
    
    @Override
    @SuppressWarnings("unchecked")
    public T get(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException();
        }
        return (T) elements[index];
    }
    
    @Override
    protected void ensureCapacity() {
        if (size == elements.length) {
            // 扩容逻辑
        }
    }
}
```

### 3. 实际应用：支付系统

```
// 使用接口定义支付规范
interface Payment {
    boolean pay(double amount);
    boolean refund(String transactionId, double amount);
    String getPaymentMethod();
    
    // 默认方法
    default boolean validateAmount(double amount) {
        return amount > 0;
    }
    
    default void logPayment(String transactionId, double amount) {
        System.out.println("[" + getPaymentMethod() + "] 支付记录: " + 
                          transactionId + ", 金额: " + amount);
    }
    
    // 静态方法
    static String getVersion() {
        return "1.0.0";
    }
}

// 使用抽象类提供通用实现
abstract class BasePayment implements Payment {
    protected String merchantId;
    protected String apiKey;
    
    public BasePayment(String merchantId, String apiKey) {
        this.merchantId = merchantId;
        this.apiKey = apiKey;
    }
    
    protected abstract boolean callPaymentAPI(double amount);
    protected abstract boolean callRefundAPI(String transactionId, double amount);
    
    @Override
    public boolean pay(double amount) {
        if (!validateAmount(amount)) {
            return false;
        }
        
        String transactionId = generateTransactionId();
        boolean success = callPaymentAPI(amount);
        
        if (success) {
            logPayment(transactionId, amount);
        }
        
        return success;
    }
    
    @Override
    public boolean refund(String transactionId, double amount) {
        if (!validateAmount(amount)) {
            return false;
        }
        
        return callRefundAPI(transactionId, amount);
    }
    
    protected String generateTransactionId() {
        return "TXN" + System.currentTimeMillis();
    }
    
    protected boolean validateMerchant() {
        return merchantId != null && !merchantId.isEmpty() &&
               apiKey != null && !apiKey.isEmpty();
    }
}

// 具体实现
class AlipayPayment extends BasePayment {
    public AlipayPayment(String merchantId, String apiKey) {
        super(merchantId, apiKey);
    }
    
    @Override
    protected boolean callPaymentAPI(double amount) {
        if (!validateMerchant()) {
            return false;
        }
        System.out.println("调用支付宝API支付: " + amount);
        return true;
    }
    
    @Override
    protected boolean callRefundAPI(String transactionId, double amount) {
        System.out.println("调用支付宝API退款: " + transactionId + ", " + amount);
        return true;
    }
    
    @Override
    public String getPaymentMethod() {
        return "支付宝";
    }
}

class WeChatPayment extends BasePayment {
    public WeChatPayment(String merchantId, String apiKey) {
        super(merchantId, apiKey);
    }
    
    @Override
    protected boolean callPaymentAPI(double amount) {
        if (!validateMerchant()) {
            return false;
        }
        System.out.println("调用微信支付API: " + amount);
        return true;
    }
    
    @Override
    protected boolean callRefundAPI(String transactionId, double amount) {
        System.out.println("调用微信支付API退款: " + transactionId + ", " + amount);
        return true;
    }
    
    @Override
    public String getPaymentMethod() {
        return "微信支付";
    }
}

// 使用
public class PaymentSystem {
    public static void main(String[] args) {
        Payment alipay = new AlipayPayment("M001", "key123");
        Payment wechat = new WeChatPayment("M002", "key456");
        
        System.out.println("支付系统版本: " + Payment.getVersion());
        
        // 测试支付宝支付
        boolean result1 = alipay.pay(100.0);
        System.out.println("支付宝支付结果: " + result1);
        
        // 测试微信支付
        boolean result2 = wechat.pay(200.0);
        System.out.println("微信支付结果: " + result2);
        
        // 退款
        boolean refundResult = alipay.refund("TXN123", 50.0);
        System.out.println("退款结果: " + refundResult);
        
        // 多态使用
        Payment[] payments = {alipay, wechat};
        for (Payment payment : payments) {
            System.out.println("支付方式: " + payment.getPaymentMethod());
            payment.pay(50.0);
        }
    }
}
```

---

## 四、高级特性

### 1. 标记接口

```
// 标记接口：没有任何方法的接口
interface Serializable { }  // Java内置的标记接口
interface Cloneable { }     // 另一个标记接口
interface RandomAccess { }  // 用于标记支持随机访问

// 自定义标记接口
interface Loggable { }  // 标记需要记录日志的类
interface Cacheable { } // 标记可以缓存的类
interface Immutable { } // 标记不可变类

// 使用标记接口
class User implements Serializable, Cloneable, Loggable {
    private String name;
    private int age;
    
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}

// 工具类利用标记接口
class Logger {
    public static void log(Object obj) {
        if (obj instanceof Loggable) {
            System.out.println("记录对象日志: " + obj);
        }
    }
}

class Cache {
    public static void cache(Object obj) {
        if (obj instanceof Cacheable) {
            System.out.println("缓存对象: " + obj);
        }
    }
}
```

### 2. 嵌套接口

```
// 接口中可以定义接口
interface OuterInterface {
    void outerMethod();
    
    // 嵌套接口
    interface NestedInterface {
        void nestedMethod();
    }
    
    // 嵌套类
    class NestedClass {
        public void nestedClassMethod() {
            System.out.println("嵌套类方法");
        }
    }
    
    // 嵌套枚举
    enum NestedEnum {
        VALUE1, VALUE2, VALUE3
    }
}

// 实现嵌套接口
class OuterImpl implements OuterInterface {
    @Override
    public void outerMethod() {
        System.out.println("实现外部接口方法");
    }
}

class NestedImpl implements OuterInterface.NestedInterface {
    @Override
    public void nestedMethod() {
        System.out.println("实现嵌套接口方法");
    }
}

// 使用
public class NestedInterfaceDemo {
    public static void main(String[] args) {
        OuterInterface outer = new OuterImpl();
        outer.outerMethod();
        
        OuterInterface.NestedInterface nested = new NestedImpl();
        nested.nestedMethod();
        
        OuterInterface.NestedClass nestedClass = new OuterInterface.NestedClass();
        nestedClass.nestedClassMethod();
        
        OuterInterface.NestedEnum value = OuterInterface.NestedEnum.VALUE1;
        System.out.println("枚举值: " + value);
    }
}
```

### 3. 接口与默认方法冲突解决

```
interface A {
    default void method() {
        System.out.println("接口A的默认方法");
    }
}

interface B {
    default void method() {
        System.out.println("接口B的默认方法");
    }
}

interface C extends A, B {
    // 必须重写冲突的默认方法
    @Override
    default void method() {
        // 明确指定调用哪个接口的方法
        A.super.method();
        B.super.method();
        System.out.println("接口C重写的方法");
    }
}

class D implements A, B {
    // 必须重写冲突的默认方法
    @Override
    public void method() {
        // 明确指定调用哪个接口的方法
        A.super.method();
        // 或者自己实现
        System.out.println("类D重写的方法");
    }
}

// 使用菱形继承
interface E {
    default void test() {
        System.out.println("E.test()");
    }
}

interface F1 extends E {
    @Override
    default void test() {
        System.out.println("F1.test()");
    }
}

interface F2 extends E {
    @Override
    default void test() {
        System.out.println("F2.test()");
    }
}

// 编译错误：需要重写test()方法
// class G implements F1, F2 { }

class H implements F1, F2 {
    @Override
    public void test() {
        F1.super.test();  // 调用F1的实现
        F2.super.test();  // 调用F2的实现
        System.out.println("H.test()");
    }
}
```

---

## 五、设计模式中的应用

### 1. 策略模式

```
// 策略接口
interface SortingStrategy {
    void sort(int[] array);
}

// 具体策略
class BubbleSort implements SortingStrategy {
    @Override
    public void sort(int[] array) {
        System.out.println("使用冒泡排序");
        // 实现冒泡排序算法
    }
}

class QuickSort implements SortingStrategy {
    @Override
    public void sort(int[] array) {
        System.out.println("使用快速排序");
        // 实现快速排序算法
    }
}

class MergeSort implements SortingStrategy {
    @Override
    public void sort(int[] array) {
        System.out.println("使用归并排序");
        // 实现归并排序算法
    }
}

// 上下文
class Sorter {
    private SortingStrategy strategy;
    
    public void setStrategy(SortingStrategy strategy) {
        this.strategy = strategy;
    }
    
    public void sortArray(int[] array) {
        if (strategy != null) {
            strategy.sort(array);
        } else {
            System.out.println("未设置排序策略");
        }
    }
}

// 使用
public class StrategyPatternDemo {
    public static void main(String[] args) {
        int[] data = {5, 2, 8, 1, 9};
        Sorter sorter = new Sorter();
        
        // 动态切换策略
        sorter.setStrategy(new BubbleSort());
        sorter.sortArray(data);
        
        sorter.setStrategy(new QuickSort());
        sorter.sortArray(data);
        
        sorter.setStrategy(new MergeSort());
        sorter.sortArray(data);
    }
}
```

### 2. 工厂模式

```
// 产品接口
interface Product {
    void use();
    String getDescription();
}

// 具体产品
class Book implements Product {
    @Override
    public void use() {
        System.out.println("阅读书籍");
    }
    
    @Override
    public String getDescription() {
        return "这是一本书";
    }
}

class Electronics implements Product {
    @Override
    public void use() {
        System.out.println("使用电子设备");
    }
    
    @Override
    public String getDescription() {
        return "这是一件电子产品";
    }
}

class Clothing implements Product {
    @Override
    public void use() {
        System.out.println("穿衣服");
    }
    
    @Override
    public String getDescription() {
        return "这是一件衣服";
    }
}

// 抽象工厂
abstract class ProductFactory {
    public abstract Product createProduct();
    
    public void displayInfo() {
        Product product = createProduct();
        product.use();
        System.out.println("描述: " + product.getDescription());
    }
}

// 具体工厂
class BookFactory extends ProductFactory {
    @Override
    public Product createProduct() {
        return new Book();
    }
}

class ElectronicsFactory extends ProductFactory {
    @Override
    public Product createProduct() {
        return new Electronics();
    }
}

class ClothingFactory extends ProductFactory {
    @Override
    public Product createProduct() {
        return new Clothing();
    }
}

// 使用
public class FactoryPatternDemo {
    public static void main(String[] args) {
        ProductFactory factory = new BookFactory();
        factory.displayInfo();
        
        factory = new ElectronicsFactory();
        factory.displayInfo();
        
        factory = new ClothingFactory();
        factory.displayInfo();
    }
}
```

---

## 六、最佳实践

### 1. 接口设计原则

```
// 1. 接口隔离原则
// 错误的：一个大接口包含太多方法
interface BadWorker {
    void code();
    void test();
    void design();
    void deploy();
    void monitor();
}

// 正确的：拆分接口
interface Developer {
    void code();
    void test();
}

interface Architect {
    void design();
}

interface DevOps {
    void deploy();
    void monitor();
}

// 2. 依赖倒置原则
// 高层模块不应该依赖低层模块，两者都应该依赖抽象
interface MessageSender {
    void send(String message, String recipient);
}

class EmailSender implements MessageSender {
    @Override
    public void send(String message, String recipient) {
        System.out.println("发送邮件: " + message);
    }
}

class SMSSender implements MessageSender {
    @Override
    public void send(String message, String recipient) {
        System.out.println("发送短信: " + message);
    }
}

class NotificationService {
    private MessageSender sender;
    
    public NotificationService(MessageSender sender) {
        this.sender = sender;  // 依赖抽象
    }
    
    public void notifyUser(String message, String recipient) {
        sender.send(message, recipient);
    }
}

// 3. 面向接口编程
class ServiceLocator {
    private static Map<String, Object> services = new HashMap<>();
    
    public static void register(String name, Object service) {
        services.put(name, service);
    }
    
    @SuppressWarnings("unchecked")
    public static <T> T get(String name, Class<T> type) {
        Object service = services.get(name);
        if (service != null && type.isInstance(service)) {
            return (T) service;
        }
        return null;
    }
}
```

### 2. 抽象类设计原则

```
// 1. 模板方法模式
abstract class DataExporter {
    // 模板方法
    public final void exportData() {
        connect();
        validateData();
        doExport();
        cleanup();
    }
    
    protected abstract void doExport();
    
    protected void connect() {
        System.out.println("连接数据源");
    }
    
    protected void validateData() {
        System.out.println("验证数据");
    }
    
    protected void cleanup() {
        System.out.println("清理资源");
    }
}

// 2. 提供基础实现
abstract class BaseRepository<T, ID> {
    protected abstract T findById(ID id);
    protected abstract List<T> findAll();
    protected abstract void save(T entity);
    protected abstract void delete(ID id);
    
    // 通用方法
    protected boolean exists(ID id) {
        return findById(id) != null;
    }
    
    protected long count() {
        return findAll().size();
    }
}
```

### 3. 接口和抽象类的组合使用

```
// 示例：缓存系统
interface Cache<K, V> {
    V get(K key);
    void put(K key, V value);
    void remove(K key);
    void clear();
    boolean containsKey(K key);
    int size();
    
    // 默认方法
    default V getOrDefault(K key, V defaultValue) {
        V value = get(key);
        return value != null ? value : defaultValue;
    }
    
    default void putAll(Map<? extends K, ? extends V> map) {
        map.forEach(this::put);
    }
}

// 抽象类提供通用实现
abstract class AbstractCache<K, V> implements Cache<K, V> {
    protected final int maxSize;
    protected final long expireTime;  // 毫秒
    
    public AbstractCache(int maxSize, long expireTime) {
        this.maxSize = maxSize;
        this.expireTime = expireTime;
    }
    
    protected abstract boolean isExpired(K key);
    protected abstract void evict();
    
    @Override
    public boolean containsKey(K key) {
        return get(key) != null && !isExpired(key);
    }
    
    // 模板方法
    @Override
    public void put(K key, V value) {
        if (size() >= maxSize) {
            evict();
        }
        doPut(key, value);
    }
    
    protected abstract void doPut(K key, V value);
}

// 具体实现
class LRUCache<K, V> extends AbstractCache<K, V> {
    private final LinkedHashMap<K, V> map = new LinkedHashMap<>();
    
    public LRUCache(int maxSize, long expireTime) {
        super(maxSize, expireTime);
    }
    
    @Override
    protected boolean isExpired(K key) {
        // 简化实现
        return false;
    }
    
    @Override
    protected void evict() {
        if (!map.isEmpty()) {
            K firstKey = map.keySet().iterator().next();
            map.remove(firstKey);
        }
    }
    
    @Override
    protected void doPut(K key, V value) {
        map.put(key, value);
    }
    
    @Override
    public V get(K key) {
        V value = map.get(key);
        if (value != null) {
            // 移动到最近使用
            map.remove(key);
            map.put(key, value);
        }
        return value;
    }
    
    @Override
    public void remove(K key) {
        map.remove(key);
    }
    
    @Override
    public void clear() {
        map.clear();
    }
    
    @Override
    public int size() {
        return map.size();
    }
}
```

---

## 七、常见面试题

### 1. 接口 vs 抽象类的区别？

```
/*
1. 设计目的不同
   - 接口：定义规范/契约，has-a关系
   - 抽象类：代码复用，is-a关系

2. 方法实现
   - 接口：Java 8前只有抽象方法，现在可以有默认方法
   - 抽象类：可以有具体方法和抽象方法

3. 成员变量
   - 接口：只能是public static final常量
   - 抽象类：可以有任意类型的成员变量

4. 构造方法
   - 接口：没有构造方法
   - 抽象类：有构造方法

5. 继承
   - 接口：多继承
   - 抽象类：单继承

6. 访问修饰符
   - 接口：默认public
   - 抽象类：任意访问修饰符
*/
```

### 2. 什么时候用接口？什么时候用抽象类？

```
// 用接口：
// 1. 定义API
// 2. 需要多继承
// 3. 定义数据类型标记
// 4. 回调机制
// 5. 策略模式

// 用抽象类：
// 1. 多个类有共享代码
// 2. 需要控制子类的构造
// 3. 需要非public的方法
// 4. 需要声明非static、非final的字段
// 5. 模板方法模式
```

### 3. Java 8中接口的变化？

```
/*
1. 默认方法
   - 使用default关键字
   - 解决接口演化问题
   - 可以被子类重写

2. 静态方法
   - 使用static关键字
   - 接口级别的工具方法
   - 不能被子类继承

3. Java 9新增私有方法
   - 解决默认方法代码复用问题
   - 可以是静态或非静态
*/
```

---

## 八、练习题

### 练习1：图形系统

```
// 设计一个图形系统
// 1. 创建Shape接口，包含计算面积和周长的方法
// 2. 创建抽象类AbstractShape，提供颜色、位置等通用属性
// 3. 创建Circle、Rectangle、Triangle等具体类
// 4. 使用工厂模式创建图形对象

interface Shape {
    double getArea();
    double getPerimeter();
    void draw();
}
```

### 练习2：数据访问层

```
// 设计一个数据访问层
// 1. 创建Repository接口，包含CRUD操作
// 2. 创建抽象类BaseRepository，提供通用实现
// 3. 创建UserRepository、ProductRepository等具体实现
// 4. 支持多种数据库（MySQL、PostgreSQL、MongoDB）

interface Repository<T, ID> {
    Optional<T> findById(ID id);
    List<T> findAll();
    T save(T entity);
    void delete(ID id);
    boolean existsById(ID id);
}
```

### 练习3：消息通知系统

```
// 设计一个消息通知系统
// 1. 创建Notification接口，包含发送消息方法
// 2. 创建EmailNotification、SMSNotification、PushNotification等实现
// 3. 使用抽象类提供模板方法
// 4. 支持消息优先级、重试机制

interface Notification {
    void send(String message, String recipient);
    NotificationType getType();
    int getPriority();
    
    enum NotificationType {
        EMAIL, SMS, PUSH
    }
}
```

---

## 总结

### 接口的核心要点：

1. ✅ **定义规范**：约定实现类必须提供的方法
    
2. ✅ **多继承**：一个类可以实现多个接口
    
3. ✅ **解耦**：依赖抽象，不依赖具体实现
    
4. ✅ **扩展性**：新增接口不影响现有代码
    
5. ✅ **Java 8+特性**：默认方法、静态方法、私有方法
    

### 抽象类的核心要点：

1. ✅ **代码复用**：提供通用实现
    
2. ✅ **部分抽象**：可以有具体方法
    
3. ✅ **构造方法**：可以有构造方法初始化状态
    
4. ✅ **访问控制**：可以控制成员访问权限
    
5. ✅ **模板模式**：定义算法骨架
    

### 选择指南：

- **需要多继承**​ → 接口
    
- **有共享代码**​ → 抽象类
    
- **定义API规范**​ → 接口
    
- **控制对象创建**​ → 抽象类
    
- **标记功能**​ → 接口
    
- **模板方法**​ → 抽象类
    

### 最佳实践：

1. **优先使用接口**：提高灵活性和扩展性
    
2. **合理使用抽象类**：在真正需要代码复用时使用
    
3. **接口隔离原则**：拆分大接口
    
4. **依赖倒置原则**：依赖抽象
    
5. **组合优于继承**：考虑使用组合替代继承层次