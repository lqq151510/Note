# Java封装详解

## 一、什么是封装？

**封装**是面向对象的三大特性之一，它将**数据**和**操作数据的方法**包装在一起，并**隐藏内部实现细节**，只对外提供安全的访问接口。

### 比喻理解

- 就像一台电视机：
    
    - 内部电路板复杂（私有）
        
    - 只提供按钮/遥控器给你使用（公有接口）
        
    - 你不需要知道内部工作原理
        
    

---

## 二、封装的基本实现

### 1. 使用访问修饰符控制访问

```
public class Student {
    // 私有字段 - 数据被隐藏
    private String name;
    private int age;
    private double score;
    
    // 公有构造方法 - 用于创建对象
    public Student(String name, int age) {
        this.name = name;
        setAge(age);  // 通过setter设置，可以添加验证
        this.score = 0;
    }
    
    // 公有getter方法 - 提供读取访问
    public String getName() {
        return name;
    }
    
    public int getAge() {
        return age;
    }
    
    // 公有setter方法 - 提供修改访问（带验证）
    public void setAge(int age) {
        if (age > 0 && age < 120) {
            this.age = age;
        } else {
            System.out.println("年龄必须在1-119之间");
        }
    }
    
    // 业务方法
    public void study(int hours) {
        if (hours > 0) {
            score += hours * 0.5;
            System.out.println(name + "学习了" + hours + "小时，分数增加" + (hours * 0.5));
        }
    }
    
    // 只读属性（只有getter，没有setter）
    public double getScore() {
        return score;
    }
}
```

---

## 三、封装的四个访问级别

### 访问修饰符对比

```
package com.school;

public class Person {
    public String publicField = "公开";      // 任何地方可访问
    protected String protectedField = "受保护"; // 同包或子类
    String defaultField = "默认";          // 同包内
    private String privateField = "私有";     // 仅本类
    
    public void showAccess() {
        // 在本类中，所有级别都可以访问
        System.out.println(publicField);     // ✓
        System.out.println(protectedField);  // ✓
        System.out.println(defaultField);    // ✓
        System.out.println(privateField);    // ✓
    }
}

// 同包的其他类
class TestSamePackage {
    void test() {
        Person p = new Person();
        System.out.println(p.publicField);     // ✓
        System.out.println(p.protectedField);  // ✓
        System.out.println(p.defaultField);    // ✓
        // System.out.println(p.privateField); // ✗ 编译错误
    }
}
```

```
package com.other;
import com.school.Person;

// 不同包的子类
class Student extends Person {
    void test() {
        Person p = new Person();
        System.out.println(p.publicField);     // ✓
        // System.out.println(p.protectedField); // ✗ 不能通过对象访问
        // System.out.println(p.defaultField);   // ✗
        // System.out.println(p.privateField);   // ✗
        
        // 但可以访问继承的protected成员
        System.out.println(protectedField);    // ✓ 直接访问继承的
    }
}

// 不同包的非子类
class Stranger {
    void test() {
        Person p = new Person();
        System.out.println(p.publicField);     // ✓
        // 其他都不能访问
    }
}
```

---

## 四、封装的完整示例：银行账户

```
public class BankAccount {
    // 完全私有的数据
    private final String accountNumber;  // 账户号 - 只读（final）
    private String accountHolder;        // 持卡人
    private double balance;              // 余额
    private String password;             // 密码
    private boolean isActive;            // 是否激活
    
    // 静态变量 - 跟踪总账户数和总余额
    private static int totalAccounts = 0;
    private static double totalBalance = 0;
    
    // 构造方法 - 初始化对象
    public BankAccount(String accountHolder, String password, double initialDeposit) {
        // 生成唯一账户号
        this.accountNumber = generateAccountNumber();
        this.accountHolder = accountHolder;
        this.password = hashPassword(password);  // 密码加密存储
        this.isActive = true;
        
        // 初始存款验证
        if (initialDeposit >= 0) {
            this.balance = initialDeposit;
            totalBalance += initialDeposit;
        } else {
            this.balance = 0;
        }
        
        totalAccounts++;
        System.out.println("账户创建成功！账户号：" + accountNumber);
    }
    
    // 私有方法 - 内部使用，不对外公开
    private String generateAccountNumber() {
        return "ACC" + System.currentTimeMillis() + totalAccounts;
    }
    
    private String hashPassword(String password) {
        // 简化的密码哈希（实际应用中应使用更安全的算法）
        return "HASH_" + password.hashCode();
    }
    
    private boolean verifyPassword(String inputPassword) {
        return hashPassword(inputPassword).equals(this.password);
    }
    
    // 公开的业务方法
    
    // 存款
    public boolean deposit(double amount, String password) {
        if (!isActive) {
            System.out.println("账户已冻结");
            return false;
        }
        
        if (!verifyPassword(password)) {
            System.out.println("密码错误");
            return false;
        }
        
        if (amount > 0) {
            balance += amount;
            totalBalance += amount;
            System.out.println("存款成功！存入：" + amount + "，当前余额：" + balance);
            return true;
        } else {
            System.out.println("存款金额必须大于0");
            return false;
        }
    }
    
    // 取款
    public boolean withdraw(double amount, String password) {
        if (!isActive) {
            System.out.println("账户已冻结");
            return false;
        }
        
        if (!verifyPassword(password)) {
            System.out.println("密码错误");
            return false;
        }
        
        if (amount <= 0) {
            System.out.println("取款金额必须大于0");
            return false;
        }
        
        if (amount <= balance) {
            balance -= amount;
            totalBalance -= amount;
            System.out.println("取款成功！取出：" + amount + "，当前余额：" + balance);
            return true;
        } else {
            System.out.println("余额不足！当前余额：" + balance);
            return false;
        }
    }
    
    // 转账
    public boolean transferTo(BankAccount targetAccount, double amount, String password) {
        if (!isActive || !targetAccount.isActive) {
            System.out.println("账户状态异常");
            return false;
        }
        
        if (!verifyPassword(password)) {
            System.out.println("密码错误");
            return false;
        }
        
        if (this.withdraw(amount, password)) {
            targetAccount.deposit(amount, targetAccount.password);
            System.out.println("转账成功！向" + targetAccount.accountHolder + 
                             "转账" + amount + "元");
            return true;
        }
        return false;
    }
    
    // Getter方法 - 提供有限的读取访问
    public String getAccountNumber() {
        return accountNumber;
    }
    
    public String getAccountHolder() {
        return accountHolder;
    }
    
    public double getBalance() {
        return balance;
    }
    
    // Setter方法 - 提供受控的修改访问
    public void setAccountHolder(String newName, String password) {
        if (verifyPassword(password)) {
            this.accountHolder = newName;
            System.out.println("持卡人姓名修改成功");
        } else {
            System.out.println("密码错误，无法修改");
        }
    }
    
    public void changePassword(String oldPassword, String newPassword) {
        if (verifyPassword(oldPassword)) {
            this.password = hashPassword(newPassword);
            System.out.println("密码修改成功");
        } else {
            System.out.println("原密码错误");
        }
    }
    
    // 账户状态管理
    public void freezeAccount(String adminPassword) {
        if ("ADMIN123".equals(adminPassword)) {
            this.isActive = false;
            System.out.println("账户已冻结");
        }
    }
    
    public void activateAccount(String adminPassword) {
        if ("ADMIN123".equals(adminPassword)) {
            this.isActive = true;
            System.out.println("账户已激活");
        }
    }
    
    // 静态方法 - 类级别的操作
    public static int getTotalAccounts() {
        return totalAccounts;
    }
    
    public static double getTotalBalance() {
        return totalBalance;
    }
    
    // 显示账户信息（受保护的信息不显示）
    public void displayAccountInfo() {
        System.out.println("=== 账户信息 ===");
        System.out.println("账户号：" + accountNumber);
        System.out.println("持卡人：" + accountHolder);
        System.out.println("余额：" + balance + "元");
        System.out.println("状态：" + (isActive ? "正常" : "冻结"));
        System.out.println("=================");
    }
}

// 测试类
public class BankTest {
    public static void main(String[] args) {
        // 创建账户
        BankAccount account1 = new BankAccount("张三", "123456", 1000);
        BankAccount account2 = new BankAccount("李四", "654321", 500);
        
        // 存款
        account1.deposit(500, "123456");
        
        // 取款
        account1.withdraw(200, "123456");
        
        // 转账
        account1.transferTo(account2, 300, "123456");
        
        // 查看信息
        account1.displayAccountInfo();
        account2.displayAccountInfo();
        
        // 修改信息（需要密码验证）
        account1.setAccountHolder("张三丰", "123456");
        account1.changePassword("123456", "newpassword");
        
        // 查看统计信息
        System.out.println("总账户数：" + BankAccount.getTotalAccounts());
        System.out.println("总余额：" + BankAccount.getTotalBalance());
        
        // 尝试非法操作（会被封装阻止）
        // account1.balance = 1000000;  // 编译错误 - private
        // account1.password = "hacked"; // 编译错误 - private
    }
}
```

---

## 五、封装的设计模式

### 1. ==JavaBean规范==

```
public class Product implements Serializable {
    // 1. 私有字段
    private String id;
    private String name;
    private double price;
    private int stock;
    
    // 2. 无参构造方法
    public Product() {}
    
    // 3. 有参构造方法
    public Product(String id, String name, double price, int stock) {
        this.id = id;
        this.name = name;
        this.price = price;
        this.stock = stock;
    }
    
    // 4. Getter/Setter（符合命名规范）
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public double getPrice() {
        return price;
    }
    
    public void setPrice(double price) {
        if (price >= 0) {
            this.price = price;
        }
    }
    
    public int getStock() {
        return stock;
    }
    
    public void setStock(int stock) {
        if (stock >= 0) {
            this.stock = stock;
        }
    }
    
    // 5. toString方法
    @Override
    public String toString() {
        return "Product [id=" + id + ", name=" + name + 
               ", price=" + price + ", stock=" + stock + "]";
    }
    
    // 6. equals和hashCode方法
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Product product = (Product) obj;
        return id.equals(product.id);
    }
    
    @Override
    public int hashCode() {
        return id.hashCode();
    }
}
```

### 2. 建造者模式（Builder Pattern）

```
public class Computer {
    // 必需参数
    private final String cpu;
    private final String ram;
    
    // 可选参数
    private final String gpu;
    private final String storage;
    private final boolean hasBluetooth;
    private final boolean hasWifi;
    
    // 私有构造方法
    private Computer(Builder builder) {
        this.cpu = builder.cpu;
        this.ram = builder.ram;
        this.gpu = builder.gpu;
        this.storage = builder.storage;
        this.hasBluetooth = builder.hasBluetooth;
        this.hasWifi = builder.hasWifi;
    }
    
    // 静态内部类 Builder
    public static class Builder {
        // 必需参数
        private final String cpu;
        private final String ram;
        
        // 可选参数 - 使用默认值
        private String gpu = "集成显卡";
        private String storage = "256GB SSD";
        private boolean hasBluetooth = false;
        private boolean hasWifi = false;
        
        public Builder(String cpu, String ram) {
            this.cpu = cpu;
            this.ram = ram;
        }
        
        public Builder gpu(String gpu) {
            this.gpu = gpu;
            return this;
        }
        
        public Builder storage(String storage) {
            this.storage = storage;
            return this;
        }
        
        public Builder hasBluetooth(boolean hasBluetooth) {
            this.hasBluetooth = hasBluetooth;
            return this;
        }
        
        public Builder hasWifi(boolean hasWifi) {
            this.hasWifi = hasWifi;
            return this;
        }
        
        public Computer build() {
            return new Computer(this);
        }
    }
    
    // Getter方法
    public String getCpu() { return cpu; }
    public String getRam() { return ram; }
    public String getGpu() { return gpu; }
    public String getStorage() { return storage; }
    public boolean isHasBluetooth() { return hasBluetooth; }
    public boolean isHasWifi() { return hasWifi; }
}

// 使用建造者模式
Computer gamingPC = new Computer.Builder("Intel i9", "32GB")
    .gpu("NVIDIA RTX 3080")
    .storage("1TB NVMe SSD")
    .hasBluetooth(true)
    .hasWifi(true)
    .build();
```

---

## 六、封装的好处

### 1. **数据保护**

```
public class Salary {
    private double baseSalary;
    private double bonus;
    
    public double getTotalSalary() {
        return baseSalary + bonus;
    }
    
    // 防止直接修改
    public void setBonus(double bonus) {
        if (bonus >= 0 && bonus <= baseSalary * 2) {
            this.bonus = bonus;
        }
    }
}
```

### 2. **易于维护**

```
public class User {
    private String username;
    private String password;
    
    // 修改密码验证逻辑只需改这里
    public boolean changePassword(String oldPassword, String newPassword) {
        if (verifyPassword(oldPassword)) {
            if (isPasswordValid(newPassword)) {
                this.password = encrypt(newPassword);
                return true;
            }
        }
        return false;
    }
    
    private boolean isPasswordValid(String password) {
        // 密码验证规则可以随时修改
        return password.length() >= 8 
            && password.matches(".*[A-Z].*")
            && password.matches(".*[a-z].*")
            && password.matches(".*\\d.*");
    }
}
```

### 3. **增加安全性**

```
public class CreditCard {
    private String cardNumber;
    
    // 不直接暴露完整卡号
    public String getMaskedCardNumber() {
        return "****-****-****-" + cardNumber.substring(12);
    }
    
    // 验证时可以添加额外逻辑
    public boolean validatePayment(double amount, String cvv) {
        if (isCardValid() && hasSufficientCredit(amount)) {
            if (verifyCVV(cvv)) {
                return processPayment(amount);
            }
        }
        return false;
    }
}
```

---

## 七、常见封装模式

### 1. 只读封装

```
public class ImmutablePerson {
    private final String name;  // final确保不可变
    private final int age;
    
    public ImmutablePerson(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // 只有getter，没有setter
    public String getName() {
        return name;
    }
    
    public int getAge() {
        return age;
    }
}
```

### 2. 延迟初始化

```
public class HeavyResource {
    private ExpensiveObject resource;  // 重量级对象
    
    public ExpensiveObject getResource() {
        if (resource == null) {
            resource = createExpensiveObject();  // 首次访问时才创建
        }
        return resource;
    }
    
    private ExpensiveObject createExpensiveObject() {
        // 复杂的初始化过程
        return new ExpensiveObject();
    }
}
```

### 3. 缓存封装

```
public class UserService {
    private Map<String, User> userCache = new HashMap<>();
    
    public User getUser(String userId) {
        // 先查缓存
        User user = userCache.get(userId);
        if (user == null) {
            // 缓存中没有，从数据库加载
            user = loadFromDatabase(userId);
            userCache.put(userId, user);
        }
        return user;
    }
    
    private User loadFromDatabase(String userId) {
        // 数据库查询逻辑
        return new User(userId);
    }
}
```

---

## 八、封装实践练习

### 练习1：温度转换器

```
public class Temperature {
    private double celsius;
    
    // TODO: 1. 实现构造方法
    // TODO: 2. 实现getCelsius()和getFahrenheit()
    // TODO: 3. 实现setCelsius()和setFahrenheit()
    // TODO: 4. 验证温度不能低于绝对零度(-273.15°C)
}
```

### 练习2：购物车

```
public class ShoppingCart {
    private List<Item> items;
    private String userId;
    
    // TODO: 1. 实现添加商品（验证库存）
    // TODO: 2. 实现移除商品
    // TODO: 3. 计算总价（考虑折扣）
    // TODO: 4. 实现结账功能
}
```

### 练习3：用户会话

```
public class UserSession {
    private String sessionId;
    private long createdAt;
    private long lastAccessed;
    private Map<String, Object> attributes;
    
    // TODO: 1. 实现会话超时检查
    // TODO: 2. 实现属性存储（线程安全）
    // TODO: 3. 实现会话刷新
}
```

---

## 九、封装最佳实践

### 1. **最小化访问权限**

```
// 不好：所有字段都是public
public class BadExample {
    public String name;
    public int age;
}

// 好：使用private字段 + getter/setter
public class GoodExample {
    private String name;
    private int age;
    
    // 提供必要的访问方法
}
```

### 2. **对变化进行封装**

```
public class PaymentProcessor {
    // 不好的设计：直接依赖具体类
    public void processPayment(CreditCardPayment payment) {
        // 处理逻辑
    }
    
    // 好的设计：依赖接口
    public void processPayment(Payment payment) {
        payment.pay();
    }
}

interface Payment {
    void pay();
}
```

### 3. **使用不可变对象**

```
// 线程安全，易于缓存
public final class ImmutablePoint {
    private final int x;
    private final int y;
    
    public ImmutablePoint(int x, int y) {
        this.x = x;
        this.y = y;
    }
    
    public int getX() { return x; }
    public int getY() { return y; }
    
    // 返回新对象，而不是修改原对象
    public ImmutablePoint move(int dx, int dy) {
        return new ImmutablePoint(x + dx, y + dy);
    }
}
```

---

## 十、封装总结

### 核心原则：

1. **隐藏实现细节**：内部数据私有化
    
2. **提供公共接口**：通过方法访问和修改数据
    
3. **添加验证逻辑**：在setter中验证数据有效性
    
4. **保持一致性**：确保对象状态始终有效
    

### 关键点：

- **private**：数据保护的第一道防线
    
- **getter/setter**：受控的访问方式
    
- **构造方法**：确保对象创建时的正确性
    
- **final**：创建不可变对象
    
- **static**：封装类级别的数据
    

### 记住这句话：

> **"Tell, Don't Ask"**（告诉对象做什么，不要询问它的状态）

封装不是简单的"private + getter/setter"，而是**信息隐藏**和**行为抽象**的结合。好的封装让代码更安全、更易维护、更易扩展。