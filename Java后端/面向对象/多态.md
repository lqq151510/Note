# Java多态详解

## 一、多态的基本概念

### 1. 什么是多态？

**多态**是指同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。

```
// 多态的三种形式
// 1. 继承多态
// 2. 接口多态
// 3. 方法重载（编译时多态）

// 示例：继承多态
class Animal {
    public void makeSound() {
        System.out.println("动物发出声音");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("汪汪汪");
    }
}

class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("喵喵喵");
    }
}

class Bird extends Animal {
    @Override
    public void makeSound() {
        System.out.println("叽叽喳喳");
    }
}

public class PolymorphismDemo {
    public static void main(String[] args) {
        // 多态的表现：父类引用指向子类对象
        Animal animal1 = new Dog();  // Dog是Animal
        Animal animal2 = new Cat();  // Cat是Animal
        Animal animal3 = new Bird(); // Bird是Animal
        
        // 同一个方法，不同行为
        animal1.makeSound();  // 汪汪汪
        animal2.makeSound();  // 喵喵喵
        animal3.makeSound();  // 叽叽喳喳
        
        // 多态的实际应用
        Animal[] animals = {animal1, animal2, animal3, new Dog(), new Cat()};
        for (Animal animal : animals) {
            animal.makeSound();  // 根据实际对象类型调用对应方法
        }
    }
}
```

---

## 二、多态的实现方式

### 1. 继承多态

```
// 父类
class Shape {
    public double getArea() {
        return 0;
    }
    
    public void draw() {
        System.out.println("绘制图形");
    }
}

// 子类1
class Circle extends Shape {
    private double radius;
    
    public Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }
    
    @Override
    public void draw() {
        System.out.println("绘制圆形，半径：" + radius);
    }
}

// 子类2
class Rectangle extends Shape {
    private double width;
    private double height;
    
    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }
    
    @Override
    public double getArea() {
        return width * height;
    }
    
    @Override
    public void draw() {
        System.out.println("绘制矩形，宽：" + width + "，高：" + height);
    }
}

// 子类3
class Triangle extends Shape {
    private double base;
    private double height;
    
    public Triangle(double base, double height) {
        this.base = base;
        this.height = height;
    }
    
    @Override
    public double getArea() {
        return 0.5 * base * height;
    }
    
    @Override
    public void draw() {
        System.out.println("绘制三角形，底边：" + base + "，高：" + height);
    }
}

// 使用多态
public class ShapeDemo {
    public static void main(String[] args) {
        // 多态数组
        Shape[] shapes = new Shape[3];
        shapes[0] = new Circle(5.0);
        shapes[1] = new Rectangle(4.0, 6.0);
        shapes[2] = new Triangle(3.0, 4.0);
        
        // 统一接口，不同实现
        for (Shape shape : shapes) {
            shape.draw();
            System.out.println("面积：" + shape.getArea());
            System.out.println("---");
        }
        
        // 多态参数
        printShapeInfo(new Circle(10));  // 传递Circle对象
        printShapeInfo(new Rectangle(3, 4));  // 传递Rectangle对象
    }
    
    // 多态方法：参数是父类类型，可以接受任何子类对象
    public static void printShapeInfo(Shape shape) {
        shape.draw();
        System.out.println("面积：" + shape.getArea());
    }
}
```

### 2. 接口多态

```
// 接口
interface USB {
    void connect();
    void transferData();
}

// 实现类1
class Mouse implements USB {
    @Override
    public void connect() {
        System.out.println("鼠标已连接");
    }
    
    @Override
    public void transferData() {
        System.out.println("传输鼠标移动数据");
    }
}

// 实现类2
class Keyboard implements USB {
    @Override
    public void connect() {
        System.out.println("键盘已连接");
    }
    
    @Override
    public void transferData() {
        System.out.println("传输键盘输入数据");
    }
}

// 实现类3
class Printer implements USB {
    @Override
    public void connect() {
        System.out.println("打印机已连接");
    }
    
    @Override
    public void transferData() {
        System.out.println("传输打印数据");
    }
    
    // 特有方法
    public void print() {
        System.out.println("正在打印...");
    }
}

// 使用接口多态
public class InterfacePolymorphism {
    public static void main(String[] args) {
        // 接口引用指向实现类对象
        USB[] devices = new USB[3];
        devices[0] = new Mouse();
        devices[1] = new Keyboard();
        devices[2] = new Printer();
        
        // 统一操作
        for (USB device : devices) {
            device.connect();
            device.transferData();
            System.out.println("---");
        }
        
        // 多态方法调用
        testDevice(new Mouse());
        testDevice(new Keyboard());
        testDevice(new Printer());
    }
    
    public static void testDevice(USB device) {
        device.connect();
        device.transferData();
        
        // 类型判断和转换
        if (device instanceof Printer) {
            Printer printer = (Printer) device;  // 向下转型
            printer.print();  // 调用特有方法
        }
    }
}
```

### 3. 方法重载（编译时多态）

```
class Calculator {
    // 方法重载：相同的方法名，不同的参数列表
    public int add(int a, int b) {
        return a + b;
    }
    
    public double add(double a, double b) {
        return a + b;
    }
    
    public int add(int a, int b, int c) {
        return a + b + c;
    }
    
    public String add(String a, String b) {
        return a + b;  // 字符串连接
    }
    
    public int add(int[] numbers) {
        int sum = 0;
        for (int num : numbers) {
            sum += num;
        }
        return sum;
    }
}

public class OverloadingDemo {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        
        // 编译时确定调用哪个方法
        System.out.println(calc.add(5, 3));        // 调用 add(int, int)
        System.out.println(calc.add(5.5, 3.2));    // 调用 add(double, double)
        System.out.println(calc.add(1, 2, 3));     // 调用 add(int, int, int)
        System.out.println(calc.add("Hello", "World"));  // 调用 add(String, String)
        
        int[] nums = {1, 2, 3, 4, 5};
        System.out.println(calc.add(nums));        // 调用 add(int[])
    }
}
```

---

## 三、多态调用成员的特点

### 1. 成员变量访问特点(编译检查父类是否存在，输出父类变量)

```
class Parent {
    String name = "Parent";
    static String staticField = "Parent Static";
    
    public void show() {
        System.out.println("Parent show: " + name);
    }
}

class Child extends Parent {
    String name = "Child";  // 隐藏父类的name
    static String staticField = "Child Static";  // 隐藏父类的静态字段
    
    @Override
    public void show() {
        System.out.println("Child show: " + name);
    }
    
    public void showParentName() {
        System.out.println("Parent's name: " + super.name);
    }
}

public class FieldAccessDemo {
    public static void main(String[] args) {
        Parent obj = new Child();  // 多态
        
        // 成员变量：编译时类型决定访问哪个
        System.out.println(obj.name);           // "Parent" （编译时类型Parent）
        System.out.println(obj.staticField);    // "Parent Static"
        
        // 静态变量：编译时类型决定访问哪个
        System.out.println(Parent.staticField); // "Parent Static"
        System.out.println(Child.staticField);  // "Child Static"
        
        // 实例变量：运行时类型决定访问哪个
        Child child = new Child();
        System.out.println(child.name);         // "Child"
        
        // 通过子类对象访问父类成员
        child.showParentName();                 // "Parent's name: Parent"
    }
}
```

### 2. 成员方法调用特点(编译检查父类是否存在，运行子类方法)

```
class Base {
    public void instanceMethod() {
        System.out.println("Base instanceMethod");
    }
    
    public static void staticMethod() {
        System.out.println("Base staticMethod");
    }
    
    public final void finalMethod() {
        System.out.println("Base finalMethod");
    }
    
    private void privateMethod() {
        System.out.println("Base privateMethod");
    }
}

class Derived extends Base {
    @Override
    public void instanceMethod() {
        System.out.println("Derived instanceMethod");
    }
    
    // 静态方法隐藏，不是重写
    public static void staticMethod() {
        System.out.println("Derived staticMethod");
    }
    
    // 不能重写final方法
    // public void finalMethod() { }
    
    // 这不是重写，只是同名方法
    private void privateMethod() {
        System.out.println("Derived privateMethod");
    }
    
    public void callPrivate() {
        privateMethod();  // 调用自己的privateMethod
    }
}

public class MethodCallDemo {
    public static void main(String[] args) {
        Base obj = new Derived();  // 多态
        
        // 实例方法：运行时类型决定（动态绑定）
        obj.instanceMethod();  // "Derived instanceMethod"
        
        // 静态方法：编译时类型决定（静态绑定）
        obj.staticMethod();    // "Base staticMethod"
        Derived.staticMethod(); // "Derived staticMethod"
        
        // final方法：不能被重写
        obj.finalMethod();     // "Base finalMethod"
        
        // private方法：不参与多态
        // obj.privateMethod();  // 编译错误
        
        Derived derived = new Derived();
        derived.callPrivate();  // "Derived privateMethod"
        
        // 实际类型判断
        if (obj instanceof Derived) {
            System.out.println("obj是Derived类型");
            Derived derivedObj = (Derived) obj;  // 向下转型
            derivedObj.instanceMethod();  // "Derived instanceMethod"
        }
    }
}
```

### 3. 构造方法中的多态

```
class A {
    public A() {
        System.out.println("A构造方法");
        show();  // 危险：在构造方法中调用可重写的方法
    }
    
    public void show() {
        System.out.println("A.show()");
    }
}

class B extends A {
    private int value = 10;
    
    public B() {
        System.out.println("B构造方法，value = " + value);
    }
    
    @Override
    public void show() {
        System.out.println("B.show()，value = " + value);
    }
}

public class ConstructorPolymorphism {
    public static void main(String[] args) {
        B b = new B();
        // 输出：
        // A构造方法
        // B.show()，value = 0  （注意：value还没初始化！）
        // B构造方法，value = 10
        
        // 结论：避免在构造方法中调用可重写的方法
    }
}
```

---

## 四、类型转换和多态

### 1. 向上转型（自动）

```
class Animal {
    public void eat() {
        System.out.println("动物吃东西");
    }
}

class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("狗吃骨头");
    }
    
    public void bark() {
        System.out.println("汪汪叫");
    }
}

public class UpcastingDemo {
    public static void main(String[] args) {
        // 向上转型：子类 → 父类（自动）
        Animal animal = new Dog();  // Dog向上转型为Animal
        
        animal.eat();  // "狗吃骨头"（多态）
        // animal.bark();  // 编译错误：不能访问Dog特有方法
        
        // 向上转型的优点
        feedAnimal(new Dog());     // Dog → Animal
        feedAnimal(new Cat());     // Cat → Animal
        feedAnimal(new Bird());    // Bird → Animal
    }
    
    public static void feedAnimal(Animal animal) {
        // 接受任何Animal子类
        animal.eat();
    }
}
```

### 2. 向下转型（强制）

```
class Animal {
    public void eat() {
        System.out.println("动物吃东西");
    }
}

class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("狗吃骨头");
    }
    
    public void guard() {
        System.out.println("狗在看家");
    }
}

class Cat extends Animal {
    @Override
    public void eat() {
        System.out.println("猫吃鱼");
    }
    
    public void catchMouse() {
        System.out.println("猫抓老鼠");
    }
}

public class DowncastingDemo {
    public static void main(String[] args) {
        // 向上转型
        Animal animal1 = new Dog();
        Animal animal2 = new Cat();
        
        // 向下转型：父类 → 子类（需要强制转换）
        if (animal1 instanceof Dog) {
            Dog dog = (Dog) animal1;  // 安全的向下转型
            dog.guard();  // "狗在看家"
        }
        
        if (animal2 instanceof Dog) {
            // 不会执行，animal2是Cat
            Dog dog = (Dog) animal2;  // 会抛出ClassCastException
        }
        
        // 安全的向下转型模式
        if (animal1 instanceof Dog dog) {  // Java 16+ 模式匹配
            dog.guard();
        }
        
        // 处理转型异常
        try {
            Cat cat = (Cat) animal1;  // 错误：animal1实际上是Dog
        } catch (ClassCastException e) {
            System.out.println("类型转换失败: " + e.getMessage());
        }
        
        // 使用泛型避免转型
        List<Animal> animals = new ArrayList<>();
        animals.add(new Dog());
        animals.add(new Cat());
        
        for (Animal animal : animals) {
            animal.eat();  // 多态调用
            
            if (animal instanceof Dog) {
                ((Dog) animal).guard();
            } else if (animal instanceof Cat) {
                ((Cat) animal).catchMouse();
            }
        }
    }
}
```

---

## 五、多态的优势

### 1. 提高代码可扩展性

```
// 支付系统示例
interface Payment {
    void pay(double amount);
}

class CreditCardPayment implements Payment {
    @Override
    public void pay(double amount) {
        System.out.println("信用卡支付: " + amount + "元");
        // 具体的信用卡支付逻辑
    }
}

class WeChatPayment implements Payment {
    @Override
    public void pay(double amount) {
        System.out.println("微信支付: " + amount + "元");
        // 具体的微信支付逻辑
    }
}

class AlipayPayment implements Payment {
    @Override
    public void pay(double amount) {
        System.out.println("支付宝支付: " + amount + "元");
        // 具体的支付宝支付逻辑
    }
}

// 新增支付方式不影响原有代码
class BankTransferPayment implements Payment {
    @Override
    public void pay(double amount) {
        System.out.println("银行转账: " + amount + "元");
    }
}

// 支付处理类
class PaymentProcessor {
    public void processPayment(Payment payment, double amount) {
        payment.pay(amount);
    }
    
    public void processBatch(List<Payment> payments, double amount) {
        for (Payment payment : payments) {
            payment.pay(amount);
        }
    }
}

// 使用
public class PaymentSystem {
    public static void main(String[] args) {
        PaymentProcessor processor = new PaymentProcessor();
        
        // 处理不同支付方式
        processor.processPayment(new CreditCardPayment(), 100.0);
        processor.processPayment(new WeChatPayment(), 200.0);
        processor.processPayment(new AlipayPayment(), 300.0);
        
        // 新增支付方式
        processor.processPayment(new BankTransferPayment(), 400.0);
    }
}
```

### 2. 提高代码可维护性

```
// 日志系统示例
interface Logger {
    void log(String message, LogLevel level);
}

enum LogLevel {
    DEBUG, INFO, WARN, ERROR
}

class ConsoleLogger implements Logger {
    @Override
    public void log(String message, LogLevel level) {
        System.out.println("[" + level + "] " + message);
    }
}

class FileLogger implements Logger {
    private String filename;
    
    public FileLogger(String filename) {
        this.filename = filename;
    }
    
    @Override
    public void log(String message, LogLevel level) {
        // 写入文件的逻辑
        System.out.println("写入文件[" + filename + "]: [" + level + "] " + message);
    }
}

class DatabaseLogger implements Logger {
    @Override
    public void log(String message, LogLevel level) {
        // 写入数据库的逻辑
        System.out.println("写入数据库: [" + level + "] " + message);
    }
}

// 日志管理器
class LogManager {
    private List<Logger> loggers = new ArrayList<>();
    
    public void addLogger(Logger logger) {
        loggers.add(logger);
    }
    
    public void log(String message, LogLevel level) {
        for (Logger logger : loggers) {
            logger.log(message, level);
        }
    }
    
    public void debug(String message) {
        log(message, LogLevel.DEBUG);
    }
    
    public void info(String message) {
        log(message, LogLevel.INFO);
    }
    
    public void error(String message) {
        log(message, LogLevel.ERROR);
    }
}

// 使用
public class LogSystem {
    public static void main(String[] args) {
        LogManager manager = new LogManager();
        manager.addLogger(new ConsoleLogger());
        manager.addLogger(new FileLogger("app.log"));
        manager.addLogger(new DatabaseLogger());
        
        // 统一接口记录日志
        manager.debug("调试信息");
        manager.info("普通信息");
        manager.error("错误信息");
        
        // 可以随时添加新的日志器而不修改原有代码
        manager.addLogger(new EmailLogger());  // 新增邮件日志
    }
}
```

### 3. 降低耦合度

```
// 数据访问层示例
interface UserRepository {
    void save(User user);
    User findById(String id);
    List<User> findAll();
    void delete(String id);
}

class User {
    private String id;
    private String name;
    private String email;
    
    // 构造方法、getter、setter省略
}

// 内存实现
class InMemoryUserRepository implements UserRepository {
    private Map<String, User> storage = new HashMap<>();
    
    @Override
    public void save(User user) {
        storage.put(user.getId(), user);
    }
    
    @Override
    public User findById(String id) {
        return storage.get(id);
    }
    
    @Override
    public List<User> findAll() {
        return new ArrayList<>(storage.values());
    }
    
    @Override
    public void delete(String id) {
        storage.remove(id);
    }
}

// 数据库实现
class DatabaseUserRepository implements UserRepository {
    @Override
    public void save(User user) {
        System.out.println("保存到数据库: " + user.getId());
        // 实际的数据库操作
    }
    
    @Override
    public User findById(String id) {
        System.out.println("从数据库查询: " + id);
        // 实际的数据库查询
        return new User(id, "张三", "zhangsan@example.com");
    }
    
    @Override
    public List<User> findAll() {
        System.out.println("查询所有用户");
        // 实际的数据库查询
        return new ArrayList<>();
    }
    
    @Override
    public void delete(String id) {
        System.out.println("从数据库删除: " + id);
        // 实际的数据库删除
    }
}

// 业务层
class UserService {
    private UserRepository repository;
    
    public UserService(UserRepository repository) {
        this.repository = repository;  // 依赖注入
    }
    
    public void createUser(String id, String name, String email) {
        User user = new User(id, name, email);
        repository.save(user);
    }
    
    public User getUser(String id) {
        return repository.findById(id);
    }
}

// 使用
public class UserManagement {
    public static void main(String[] args) {
        // 可以轻松切换存储实现
        UserRepository repository = new InMemoryUserRepository();  // 使用内存存储
        // UserRepository repository = new DatabaseUserRepository();  // 使用数据库存储
        
        UserService service = new UserService(repository);
        service.createUser("1", "张三", "zhangsan@example.com");
        
        User user = service.getUser("1");
        System.out.println("用户: " + user.getName());
        
        // 新增实现不影响业务层
        UserRepository cloudRepository = new CloudStorageUserRepository();
        UserService cloudService = new UserService(cloudRepository);
    }
}
```

---

## 六、多态的弊端

### 1. 性能开销

```
// 多态的方法调用比非多态调用慢
class PerformanceTest {
    interface Calculator {
        int calculate(int a, int b);
    }
    
    static class Adder implements Calculator {
        @Override
        public int calculate(int a, int b) {
            return a + b;
        }
    }
    
    static class Multiplier implements Calculator {
        @Override
        public int calculate(int a, int b) {
            return a * b;
        }
    }
    
    public static void main(String[] args) {
        int iterations = 1_000_000;
        
        // 直接调用
        long start1 = System.nanoTime();
        Adder adder = new Adder();
        for (int i = 0; i < iterations; i++) {
            adder.calculate(i, i + 1);
        }
        long time1 = System.nanoTime() - start1;
        
        // 多态调用
        long start2 = System.nanoTime();
        Calculator calculator = new Adder();
        for (int i = 0; i < iterations; i++) {
            calculator.calculate(i, i + 1);
        }
        long time2 = System.nanoTime() - start2;
        
        System.out.printf("直接调用: %.2f ms%n", time1 / 1_000_000.0);
        System.out.printf("多态调用: %.2f ms%n", time2 / 1_000_000.0);
        System.out.printf("性能差距: %.2f%%%n", (time2 - time1) * 100.0 / time1);
        
        // 注意：现代JVM有优化，实际差距可能不大
    }
}
```

### 2. 类型转换的复杂性

```
// 类型检查和转换的复杂性
class TypeConversionIssues {
    static class Animal {
        public void eat() {
            System.out.println("动物吃东西");
        }
    }
    
    static class Dog extends Animal {
        public void bark() {
            System.out.println("汪汪");
        }
    }
    
    static class Cat extends Animal {
        public void meow() {
            System.out.println("喵喵");
        }
    }
    
    public static void main(String[] args) {
        List<Animal> animals = new ArrayList<>();
        animals.add(new Dog());
        animals.add(new Cat());
        animals.add(new Dog());
        
        // 问题1：需要频繁的类型检查
        for (Animal animal : animals) {
            if (animal instanceof Dog) {
                ((Dog) animal).bark();
            } else if (animal instanceof Cat) {
                ((Cat) animal).meow();
            } else {
                animal.eat();
            }
        }
        
        // 问题2：向下转型可能失败
        Animal animal = new Dog();
        // Cat cat = (Cat) animal;  // 运行时异常
        
        // 问题3：代码冗余
        processDog(new Dog());
        processCat(new Cat());
        
        // 解决方案：使用访问者模式
        animals.forEach(a -> a.accept(new AnimalVisitor()));
    }
    
    // 冗余的方法
    public static void processDog(Dog dog) {
        dog.bark();
    }
    
    public static void processCat(Cat cat) {
        cat.meow();
    }
}
```

### 3. 设计复杂性

```
// 过度使用多态导致设计复杂
class ComplexDesign {
    // 基类
    static class Employee {
        protected String name;
        protected double salary;
        
        public double calculateBonus() {
            return salary * 0.1;  // 默认奖金
        }
    }
    
    // 子类1
    static class Manager extends Employee {
        @Override
        public double calculateBonus() {
            return salary * 0.2;  // 经理奖金更高
        }
        
        public void conductMeeting() {
            System.out.println(name + "在主持会议");
        }
    }
    
    // 子类2
    static class Developer extends Employee {
        private String programmingLanguage;
        
        @Override
        public double calculateBonus() {
            return salary * 0.15 + 1000;  // 额外奖金
        }
        
        public void writeCode() {
            System.out.println(name + "在写" + programmingLanguage + "代码");
        }
    }
    
    // 子类3
    static class SalesPerson extends Employee {
        private double salesAmount;
        
        @Override
        public double calculateBonus() {
            return salesAmount * 0.05;  // 按销售额提成
        }
    }
    
    public static void main(String[] args) {
        // 问题1：需要为每个子类添加特定处理
        Employee[] employees = {
            new Manager(),
            new Developer(),
            new SalesPerson(),
            new Manager()
        };
        
        for (Employee emp : employees) {
            // 问题2：无法直接访问子类特有方法
            if (emp instanceof Manager) {
                ((Manager) emp).conductMeeting();
            } else if (emp instanceof Developer) {
                ((Developer) emp).writeCode();
            }
            
            // 问题3：计算奖金逻辑分散在各个子类
            double bonus = emp.calculateBonus();
            System.out.println("奖金: " + bonus);
        }
        
        // 替代方案：使用组合或策略模式
        for (Employee emp : employees) {
            // 使用策略模式计算奖金
            BonusCalculator calculator = getBonusCalculator(emp);
            double bonus = calculator.calculate(emp);
            System.out.println("策略模式计算奖金: " + bonus);
        }
    }
    
    // 策略模式接口
    interface BonusCalculator {
        double calculate(Employee emp);
    }
    
    static BonusCalculator getBonusCalculator(Employee emp) {
        if (emp instanceof Manager) {
            return e -> e.salary * 0.2;
        } else if (emp instanceof Developer) {
            return e -> e.salary * 0.15 + 1000;
        } else if (emp instanceof SalesPerson) {
            SalesPerson sp = (SalesPerson) emp;
            return e -> sp.salesAmount * 0.05;
        } else {
            return e -> e.salary * 0.1;
        }
    }
}
```

### 4. 调试困难

```
// 多态增加调试复杂性
class DebuggingDifficulty {
    interface Shape {
        void draw();
    }
    
    static class Circle implements Shape {
        @Override
        public void draw() {
            System.out.println("绘制圆形");
            // 复杂的绘制逻辑
            throw new RuntimeException("绘制圆形时出错");
        }
    }
    
    static class Rectangle implements Shape {
        @Override
        public void draw() {
            System.out.println("绘制矩形");
            // 复杂的绘制逻辑
        }
    }
    
    static class Triangle implements Shape {
        @Override
        public void draw() {
            System.out.println("绘制三角形");
            // 复杂的绘制逻辑
        }
    }
    
    public static void main(String[] args) {
        List<Shape> shapes = Arrays.asList(
            new Circle(),
            new Rectangle(),
            new Triangle(),
            new Circle()
        );
        
        try {
            for (Shape shape : shapes) {
                shape.draw();  // 问题：哪个shape出的错？
            }
        } catch (Exception e) {
            // 调试困难：需要知道是哪个具体类型导致的异常
            e.printStackTrace();
            
            // 解决方案：添加更多调试信息
            for (int i = 0; i < shapes.size(); i++) {
                try {
                    shapes.get(i).draw();
                } catch (Exception ex) {
                    System.err.println("第" + (i + 1) + "个形状出错: " + 
                                     shapes.get(i).getClass().getSimpleName());
                    ex.printStackTrace();
                }
            }
        }
        
        // 更好的调试：使用工厂模式记录创建信息
        Shape shape1 = ShapeFactory.createCircle("Circle1");
        Shape shape2 = ShapeFactory.createRectangle("Rectangle1");
    }
    
    static class ShapeFactory {
        static Map<String, String> creationInfo = new HashMap<>();
        
        static Shape createCircle(String name) {
            creationInfo.put(name, "Circle created at " + new java.util.Date());
            return new Circle();
        }
        
        static Shape createRectangle(String name) {
            creationInfo.put(name, "Rectangle created at " + new java.util.Date());
            return new Rectangle();
        }
    }
}
```

---

## 七、多态的最佳实践

### 1. 使用设计模式

```
// 策略模式替代继承
class StrategyPatternExample {
    // 策略接口
    interface DiscountStrategy {
        double applyDiscount(double amount);
    }
    
    // 具体策略
    static class NoDiscount implements DiscountStrategy {
        @Override
        public double applyDiscount(double amount) {
            return amount;
        }
    }
    
    static class PercentageDiscount implements DiscountStrategy {
        private double percentage;
        
        public PercentageDiscount(double percentage) {
            this.percentage = percentage;
        }
        
        @Override
        public double applyDiscount(double amount) {
            return amount * (1 - percentage);
        }
    }
    
    static class FixedDiscount implements DiscountStrategy {
        private double discountAmount;
        
        public FixedDiscount(double discountAmount) {
            this.discountAmount = discountAmount;
        }
        
        @Override
        public double applyDiscount(double amount) {
            return Math.max(0, amount - discountAmount);
        }
    }
    
    // 上下文
    static class ShoppingCart {
        private DiscountStrategy discountStrategy = new NoDiscount();
        
        public void setDiscountStrategy(DiscountStrategy strategy) {
            this.discountStrategy = strategy;
        }
        
        public double calculateTotal(double amount) {
            return discountStrategy.applyDiscount(amount);
        }
    }
    
    public static void main(String[] args) {
        ShoppingCart cart = new ShoppingCart();
        double amount = 1000;
        
        // 使用不同策略
        cart.setDiscountStrategy(new NoDiscount());
        System.out.println("无折扣: " + cart.calculateTotal(amount));
        
        cart.setDiscountStrategy(new PercentageDiscount(0.1));  // 9折
        System.out.println("9折: " + cart.calculateTotal(amount));
        
        cart.setDiscountStrategy(new FixedDiscount(200));  // 减200
        System.out.println("减200: " + cart.calculateTotal(amount));
        
        // 可以轻松添加新策略
        cart.setDiscountStrategy(new HolidayDiscount());
        System.out.println("节日折扣: " + cart.calculateTotal(amount));
    }
    
    // 新增策略
    static class HolidayDiscount implements DiscountStrategy {
        @Override
        public double applyDiscount(double amount) {
            return amount * 0.8;  // 8折
        }
    }
}
```

### 2. 合理使用继承和多态

```
// 继承层次设计
class GoodInheritanceDesign {
    // 基类应该足够抽象
    abstract class PaymentMethod {
        protected String accountNumber;
        
        public PaymentMethod(String accountNumber) {
            this.accountNumber = accountNumber;
        }
        
        public abstract boolean processPayment(double amount);
        public abstract String getPaymentType();
        
        // 模板方法模式
        public final void executePayment(double amount) {
            if (validateAccount()) {
                if (processPayment(amount)) {
                    logPayment(amount);
                    sendReceipt();
                }
            }
        }
        
        protected boolean validateAccount() {
            return accountNumber != null && !accountNumber.isEmpty();
        }
        
        protected void logPayment(double amount) {
            System.out.println("记录支付: " + getPaymentType() + ", 金额: " + amount);
        }
        
        protected abstract void sendReceipt();
    }
    
    // 具体实现
    class CreditCard extends PaymentMethod {
        private String cardHolder;
        
        public CreditCard(String accountNumber, String cardHolder) {
            super(accountNumber);
            this.cardHolder = cardHolder;
        }
        
        @Override
        public boolean processPayment(double amount) {
            System.out.println("处理信用卡支付: " + amount);
            return true;
        }
        
        @Override
        public String getPaymentType() {
            return "信用卡";
        }
        
        @Override
        protected void sendReceipt() {
            System.out.println("发送信用卡支付凭证给: " + cardHolder);
        }
        
        // 特有方法
        public void checkCreditLimit() {
            System.out.println("检查信用额度");
        }
    }
    
    class BankTransfer extends PaymentMethod {
        public BankTransfer(String accountNumber) {
            super(accountNumber);
        }
        
        @Override
        public boolean processPayment(double amount) {
            System.out.println("处理银行转账: " + amount);
            return true;
        }
        
        @Override
        public String getPaymentType() {
            return "银行转账";
        }
        
        @Override
        protected void sendReceipt() {
            System.out.println("发送银行转账凭证");
        }
    }
}
```

### 3. 性能优化建议

```
class PerformanceOptimization {
    // 避免不必要的多态
    interface Processor {
        int process(int value);
    }
    
    static class FastProcessor implements Processor {
        @Override
        public int process(int value) {
            return value * 2;
        }
    }
    
    static class SlowProcessor implements Processor {
        @Override
        public int process(int value) {
            // 复杂计算
            return value * 3;
        }
    }
    
    public static void main(String[] args) {
        int iterations = 10_000_000;
        
        // 热点代码避免多态
        Processor processor = new FastProcessor();
        
        // 热点循环
        long start = System.nanoTime();
        int result = 0;
        for (int i = 0; i < iterations; i++) {
            // 在循环内部避免多态调用
            if (processor instanceof FastProcessor) {
                result = ((FastProcessor) processor).process(i);
            } else {
                result = processor.process(i);
            }
        }
        long time = System.nanoTime() - start;
        
        System.out.printf("优化后时间: %.2f ms%n", time / 1_000_000.0);
        
        // 使用内联缓存
        result = 0;
        start = System.nanoTime();
        if (processor instanceof FastProcessor) {
            FastProcessor fp = (FastProcessor) processor;
            for (int i = 0; i < iterations; i++) {
                result = fp.process(i);  // 非多态调用
            }
        } else {
            for (int i = 0; i < iterations; i++) {
                result = processor.process(i);  // 多态调用
            }
        }
        time = System.nanoTime() - start;
        
        System.out.printf("内联缓存时间: %.2f ms%n", time / 1_000_000.0);
    }
}
```

---

## 八、实际应用场景

### 场景1：插件系统

```
// 插件架构
interface Plugin {
    String getName();
    void initialize();
    void execute();
    void destroy();
}

class PluginManager {
    private List<Plugin> plugins = new ArrayList<>();
    
    public void registerPlugin(Plugin plugin) {
        plugins.add(plugin);
    }
    
    public void initializeAll() {
        plugins.forEach(Plugin::initialize);
    }
    
    public void executeAll() {
        plugins.forEach(Plugin::execute);
    }
    
    public void destroyAll() {
        plugins.forEach(Plugin::destroy);
    }
}

// 具体插件
class LoggingPlugin implements Plugin {
    @Override
    public String getName() {
        return "日志插件";
    }
    
    @Override
    public void initialize() {
        System.out.println("初始化日志插件");
    }
    
    @Override
    public void execute() {
        System.out.println("执行日志记录");
    }
    
    @Override
    public void destroy() {
        System.out.println("销毁日志插件");
    }
}

class SecurityPlugin implements Plugin {
    @Override
    public String getName() {
        return "安全插件";
    }
    
    @Override
    public void initialize() {
        System.out.println("初始化安全插件");
    }
    
    @Override
    public void execute() {
        System.out.println("执行安全检查");
    }
    
    @Override
    public void destroy() {
        System.out.println("销毁安全插件");
    }
}
```

### 场景2：事件处理系统

```
// 事件系统
interface EventListener {
    void onEvent(Event event);
}

abstract class Event {
    private String name;
    private long timestamp;
    
    public Event(String name) {
        this.name = name;
        this.timestamp = System.currentTimeMillis();
    }
    
    public abstract void process();
}

class ClickEvent extends Event {
    private int x, y;
    
    public ClickEvent(int x, int y) {
        super("点击事件");
        this.x = x;
        this.y = y;
    }
    
    @Override
    public void process() {
        System.out.println("处理点击事件: (" + x + ", " + y + ")");
    }
}

class KeyPressEvent extends Event {
    private char key;
    
    public KeyPressEvent(char key) {
        super("按键事件");
        this.key = key;
    }
    
    @Override
    public void process() {
        System.out.println("处理按键事件: " + key);
    }
}

class EventDispatcher {
    private List<EventListener> listeners = new ArrayList<>();
    
    public void addListener(EventListener listener) {
        listeners.add(listener);
    }
    
    public void dispatchEvent(Event event) {
        event.process();
        listeners.forEach(listener -> listener.onEvent(event));
    }
}
```

---

## 九、总结

### 多态的核心特点：

1. **运行时绑定**：实例方法在运行时确定
    
2. **编译时绑定**：静态方法、成员变量、构造方法在编译时确定
    
3. **向上转型**：自动转换，失去子类特有方法
    
4. **向下转型**：需要强制转换，可能抛出异常
    

### 多态的优势：

1. ✅ **提高扩展性**：新增类型不影响现有代码
    
2. ✅ **提高维护性**：统一接口，减少重复代码
    
3. ✅ **降低耦合**：依赖抽象，不依赖具体实现
    
4. ✅ **支持开闭原则**：对扩展开放，对修改关闭
    

### 多态的弊端：

1. ❌ **性能开销**：方法调用需要动态查找
    
2. ❌ **类型转换复杂**：需要频繁的类型检查和转换
    
3. ❌ **设计复杂性**：可能导致过度设计
    
4. ❌ **调试困难**：运行时行为难以跟踪
    

### 最佳实践：

1. **合理使用**：在真正需要扩展性的地方使用
    
2. **避免滥用**：不要为了多态而多态
    
3. **使用设计模式**：策略、模板方法、工厂等模式
    
4. **性能敏感处优化**：热点代码避免多态调用
    
5. **文档和测试**：充分文档化和测试多态行为
    

### 使用场景：

- 框架和库的设计
    
- 插件系统
    
- 事件处理
    
- 算法策略
    
- 数据访问层
    
- 日志系统