# Java内部类详解

## 一、内部类概述

### 什么是内部类？

**内部类**是在一个类的内部定义的类，可以访问外部类的成员，包括私有成员。

```
// 外部类
class OuterClass {
    private String outerField = "外部类字段";
    
    // 内部类
    class InnerClass {
        private String innerField = "内部类字段";
        
        public void display() {
            // 内部类可以访问外部类的私有成员
            System.out.println("访问外部类字段: " + outerField);
            System.out.println("访问内部类字段: " + innerField);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        // 创建外部类实例
        OuterClass outer = new OuterClass();
        
        // 通过外部类实例创建内部类实例
        OuterClass.InnerClass inner = outer.new InnerClass();
        
        inner.display();
    }
}
```

---

## 二、成员内部类（非静态内部类）

### 1. 基本用法

```
class Car {
    private String brand = "奔驰";
    private String model = "S500";
    private Engine engine;  // 对引擎的引用
    
    // 成员内部类
    class Engine {
        private String type = "V8";
        private int horsepower = 500;
        
        public void start() {
            // 可以直接访问外部类的私有成员
            System.out.println(brand + " " + model + " 的发动机启动");
            System.out.println("发动机类型: " + type);
            System.out.println("马力: " + horsepower);
        }
        
        public void showCarInfo() {
            // 通过外部类.this引用外部类实例
            System.out.println("外部车信息: " + Car.this.brand + " " + Car.this.model);
        }
    }
    
    // 外部类构造方法
    public Car() {
        this.engine = new Engine();  // 创建内部类实例
    }
    
    public void drive() {
        engine.start();
        System.out.println("车辆开始行驶");
    }
    
    public Engine getEngine() {
        return engine;
    }
}

public class MemberInnerClassDemo {
    public static void main(String[] args) {
        // 创建外部类实例
        Car myCar = new Car();
        myCar.drive();
        
        System.out.println("---");
        
        // 创建内部类实例（两种方式）
        // 方式1：通过外部类实例创建
        Car.Engine engine1 = myCar.new Engine();
        engine1.start();
        
        // 方式2：通过外部类方法获取
        Car.Engine engine2 = myCar.getEngine();
        engine2.showCarInfo();
    }
}
```

### 2. 内部类实例持有外部类引用

```
class Outer {
    private int value = 10;
    
    class Inner {
        private int value = 20;
        
        public void print() {
            int value = 30;  // 局部变量
            
            System.out.println("局部变量: " + value);           // 30
            System.out.println("内部类变量: " + this.value);     // 20
            System.out.println("外部类变量: " + Outer.this.value); // 10
            
            // 验证内部类持有外部类引用
            Outer outer = Outer.this;
            System.out.println("内部类持有的外部类引用: " + outer);
        }
    }
    
    public void test() {
        Inner inner = new Inner();
        inner.print();
    }
}

public class InnerReferenceDemo {
    public static void main(String[] args) {
        Outer outer = new Outer();
        outer.test();
        
        // 查看内部类的类文件
        Outer.Inner inner = outer.new Inner();
        System.out.println("内部类类型: " + inner.getClass().getName());  // Outer$Inner
    }
}
```

### 3. 成员内部类的限制

```
class OuterClass {
    private int x = 10;
    private static int staticX = 20;
    
    // 成员内部类
    class MemberInner {
        // 不能有静态声明（Java 16之前）
        // private static int y = 30;  // 编译错误（Java 16前）
        
        // Java 16+ 可以有静态成员，但必须是final
        private static final int CONSTANT = 100;  // ✓
        
        // 可以有静态方法（Java 16+）
        static void staticMethod() {
            System.out.println("静态方法");
        }
        
        public void accessOuter() {
            System.out.println("访问外部实例变量: " + x);      // ✓
            System.out.println("访问外部静态变量: " + staticX);  // ✓
        }
    }
    
    // 外部类访问内部类
    public void test() {
        MemberInner inner = new MemberInner();
        // 可以访问内部类的非私有成员
        inner.accessOuter();
    }
}
```

---

## 三、静态内部类

### 1. 基本用法

```
// 外部类
class MathUtils {
    private static String author = "数学家";
    private String version = "1.0";
    
    // 静态内部类
    static class Calculator {
        private static String type = "科学计算器";
        
        public static int add(int a, int b) {
            return a + b;
        }
        
        public int multiply(int a, int b) {
            return a * b;
        }
        
        public void showInfo() {
            // 只能访问外部类的静态成员
            System.out.println("作者: " + author);  // ✓
            // System.out.println("版本: " + version);  // ✗ 不能访问非静态
            
            System.out.println("计算器类型: " + type);
        }
    }
    
    // 普通内部类（对比）
    class Helper {
        public void help() {
            System.out.println("版本: " + version);  // 可以访问
        }
    }
}

public class StaticInnerClassDemo {
    public static void main(String[] args) {
        // 创建静态内部类实例（不需要外部类实例）
        MathUtils.Calculator calc = new MathUtils.Calculator();
        
        // 调用静态方法
        int sum = MathUtils.Calculator.add(5, 3);
        System.out.println("5 + 3 = " + sum);
        
        // 调用实例方法
        int product = calc.multiply(5, 3);
        System.out.println("5 × 3 = " + product);
        
        calc.showInfo();
        
        // 对比普通内部类
        MathUtils utils = new MathUtils();
        MathUtils.Helper helper = utils.new Helper();  // 需要外部类实例
        helper.help();
    }
}
```

### 2. 静态内部类的实际应用

```
// Builder模式
class User {
    private final String username;
    private final String email;
    private final int age;
    private final boolean isActive;
    
    // 私有构造方法
    private User(Builder builder) {
        this.username = builder.username;
        this.email = builder.email;
        this.age = builder.age;
        this.isActive = builder.isActive;
    }
    
    // 静态内部类 - Builder
    public static class Builder {
        // 必需参数
        private final String username;
        private final String email;
        
        // 可选参数（默认值）
        private int age = 0;
        private boolean isActive = true;
        
        public Builder(String username, String email) {
            this.username = username;
            this.email = email;
        }
        
        public Builder age(int age) {
            this.age = age;
            return this;
        }
        
        public Builder isActive(boolean isActive) {
            this.isActive = isActive;
            return this;
        }
        
        public User build() {
            return new User(this);
        }
    }
    
    // Getters
    public String getUsername() { return username; }
    public String getEmail() { return email; }
    public int getAge() { return age; }
    public boolean isActive() { return isActive; }
    
    @Override
    public String toString() {
        return String.format("User{username='%s', email='%s', age=%d, isActive=%s}",
                username, email, age, isActive);
    }
}

public class BuilderPatternDemo {
    public static void main(String[] args) {
        // 使用Builder创建对象
        User user = new User.Builder("张三", "zhangsan@example.com")
                .age(25)
                .isActive(true)
                .build();
        
        System.out.println(user);
        
        // 另一种方式
        User user2 = new User.Builder("李四", "lisi@example.com")
                .age(30)
                .build();  // 使用默认的isActive
        
        System.out.println(user2);
    }
}
```

### 3. 静态内部类与外部类的关系

```
class Container {
    private int instanceVar = 10;
    private static int staticVar = 20;
    
    // 非静态内部类
    class NonStaticInner {
        public void show() {
            System.out.println("外部实例变量: " + instanceVar);  // 可以访问
            System.out.println("外部静态变量: " + staticVar);    // 可以访问
        }
    }
    
    // 静态内部类
    static class StaticInner {
        public void show() {
            // System.out.println("外部实例变量: " + instanceVar);  // 错误
            System.out.println("外部静态变量: " + staticVar);      // 可以访问
        }
        
        public static void staticShow() {
            System.out.println("静态方法: " + staticVar);
        }
    }
    
    public void test() {
        // 外部类中创建内部类实例
        NonStaticInner nonStatic = new NonStaticInner();
        StaticInner staticInner = new StaticInner();  // 可以直接创建
        
        nonStatic.show();
        staticInner.show();
    }
}

public class RelationshipDemo {
    public static void main(String[] args) {
        Container container = new Container();
        container.test();
        
        // 从外部访问
        Container.NonStaticInner nonStatic = container.new NonStaticInner();
        Container.StaticInner staticInner = new Container.StaticInner();
        
        staticInner.show();
        Container.StaticInner.staticShow();  // 静态方法
    }
}
```

---

## 四、局部内部类

### 1. 基本用法

```
class Outer {
    private int outerValue = 100;
    
    public void testLocalClass(int param) {
        // 局部变量（必须是final或等效final）
        final int localFinal = 50;
        int effectivelyFinal = 60;  // 等效final（Java 8+）
        int notFinal = 70;
        notFinal = 80;  // 修改后就不是等效final了
        
        // 局部内部类
        class LocalInner {
            private int innerValue = 200;
            
            public void display() {
                // 可以访问外部类成员
                System.out.println("外部类变量: " + outerValue);
                
                // 可以访问final或等效final的局部变量
                System.out.println("final局部变量: " + localFinal);
                System.out.println("等效final局部变量: " + effectivelyFinal);
                
                // 不能访问非final局部变量
                // System.out.println("非final局部变量: " + notFinal);  // 错误
                
                // 可以访问参数（如果参数是final或等效final）
                System.out.println("参数: " + param);
                
                // 可以定义自己的变量
                System.out.println("内部类变量: " + innerValue);
            }
        }
        
        // 在方法内创建和使用局部内部类
        LocalInner local = new LocalInner();
        local.display();
        
        // 局部内部类的作用域仅限于方法内部
        // 不能在方法外使用
    }
    
    public void anotherMethod() {
        // 这里不能访问LocalInner类
        // LocalInner local;  // 编译错误
    }
}

public class LocalInnerClassDemo {
    public static void main(String[] args) {
        Outer outer = new Outer();
        outer.testLocalClass(999);
    }
}
```

### 2. 局部内部类的实际应用

```
// 数据处理器
class DataProcessor {
    
    public interface DataFilter {
        boolean filter(int data);
    }
    
    public List<Integer> filterData(List<Integer> data, DataFilter filter) {
        List<Integer> result = new ArrayList<>();
        for (int num : data) {
            if (filter.filter(num)) {
                result.add(num);
            }
        }
        return result;
    }
    
    public void processData() {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        // 定义阈值
        int threshold = 5;
        
        // 局部内部类 - 过滤器
        class GreaterThanFilter implements DataFilter {
            @Override
            public boolean filter(int data) {
                return data > threshold;  // 访问局部变量threshold
            }
        }
        
        // 使用局部内部类
        DataFilter filter = new GreaterThanFilter();
        List<Integer> filtered = filterData(numbers, filter);
        
        System.out.println("大于" + threshold + "的数: " + filtered);
        
        // 另一个局部内部类
        class EvenFilter implements DataFilter {
            @Override
            public boolean filter(int data) {
                return data % 2 == 0;
            }
        }
        
        List<Integer> evens = filterData(numbers, new EvenFilter());
        System.out.println("偶数: " + evens);
    }
    
    // 在静态方法中使用
    public static void staticProcess() {
        final String prefix = "Value: ";
        
        class Printer {
            public void print(int value) {
                System.out.println(prefix + value);  // 访问final局部变量
            }
        }
        
        Printer printer = new Printer();
        printer.print(100);
    }
}

public class LocalInnerClassUseCase {
    public static void main(String[] args) {
        DataProcessor processor = new DataProcessor();
        processor.processData();
        
        DataProcessor.staticProcess();
    }
}
```

### 3. 局部内部类的限制

```
class RestrictionsDemo {
    public void testRestrictions() {
        // 局部内部类不能有访问修饰符
        // public class LocalPublic { }  // 错误
        // private class LocalPrivate { }  // 错误
        // protected class LocalProtected { }  // 错误
        
        class LocalClass {  // 只能是默认访问权限
            // 不能有静态成员（Java 16前）
            // static int x = 10;  // 错误
            
            // 可以有静态final常量
            static final int CONSTANT = 100;  // ✓
            
            // 不能有静态初始化块
            // static { }  // 错误
            
            // 可以有实例初始化块
            { 
                System.out.println("实例初始化块");
            }
        }
        
        // 局部内部类不能是static的
        // static class StaticLocal { }  // 错误
        
        // 可以有接口
        interface LocalInterface {  // 局部接口
            void method();
        }
        
        // 实现局部接口
        class LocalImpl implements LocalInterface {
            public void method() {
                System.out.println("实现局部接口");
            }
        }
        
        LocalImpl impl = new LocalImpl();
        impl.method();
    }
}
```

---

## 五、匿名内部类（重点）

### 1. 基本概念

**匿名内部类**是没有名字的内部类，用于创建只需要用一次的类实例。

```
// 接口
interface Greeting {
    void sayHello(String name);
}

// 抽象类
abstract class Animal {
    abstract void makeSound();
    
    void eat() {
        System.out.println("动物在吃东西");
    }
}

public class AnonymousInnerClassDemo {
    public static void main(String[] args) {
        // 1. 实现接口的匿名内部类
        Greeting greeting = new Greeting() {
            @Override
            public void sayHello(String name) {
                System.out.println("你好, " + name + "!");
            }
            
            // 可以添加额外方法（但外部无法访问）
            public void additionalMethod() {
                System.out.println("额外方法");
            }
        };
        
        greeting.sayHello("张三");
        // greeting.additionalMethod();  // 编译错误，接口类型没有这个方法
        
        // 2. 继承抽象类的匿名内部类
        Animal dog = new Animal() {
            @Override
            void makeSound() {
                System.out.println("汪汪汪");
            }
            
            // 可以重写父类方法
            @Override
            void eat() {
                System.out.println("狗在吃骨头");
            }
            
            // 可以添加新方法
            void bark() {
                System.out.println("大声叫");
            }
        };
        
        dog.makeSound();
        dog.eat();
        // dog.bark();  // 编译错误，Animal类型没有这个方法
        
        // 3. 继承普通类的匿名内部类
        Thread thread = new Thread() {
            @Override
            public void run() {
                System.out.println("匿名线程在运行");
            }
            
            public void extra() {
                System.out.println("额外方法");
            }
        };
        
        thread.start();
        
        // 4. 立即执行的匿名内部类
        new Animal() {
            {
                // 实例初始化块
                System.out.println("匿名对象创建");
            }
            
            @Override
            void makeSound() {
                System.out.println("立即执行");
            }
        }.makeSound();
    }
}
```

### 2. 匿名内部类与final变量

```
public class AnonymousFinalVariables {
    public static void main(String[] args) {
        int x = 10;  // 等效final
        final int y = 20;
        int z = 30;
        z = 40;  // 修改后不是final
        
        // 匿名内部类
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                // 可以访问final或等效final的局部变量
                System.out.println("x = " + x);
                System.out.println("y = " + y);
                
                // 不能访问非final变量
                // System.out.println("z = " + z);  // 错误
                
                // 可以访问final参数
                testMethod(100);
            }
            
            public void testMethod(final int param) {
                System.out.println("参数: " + param);
            }
        };
        
        new Thread(runnable).start();
    }
    
    public void test(final int param) {
        int local = 50;
        
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("参数: " + param);
                System.out.println("局部变量: " + local);
            }
        }).start();
        
        // 如果在这里修改local，上面的匿名类就不能访问它
        // local = 60;  // 取消注释会编译错误
    }
}
```

### 3. 匿名内部类的实际应用

#### 应用1：事件监听器

```
import javax.swing.*;
import java.awt.event.*;

public class EventListenerDemo {
    public static void main(String[] args) {
        JFrame frame = new JFrame("匿名内部类示例");
        JButton button = new JButton("点击我");
        
        // 使用匿名内部类作为事件监听器
        button.addActionListener(new ActionListener() {
            private int clickCount = 0;
            
            @Override
            public void actionPerformed(ActionEvent e) {
                clickCount++;
                System.out.println("按钮被点击了 " + clickCount + " 次");
                
                // 可以访问外部类的final变量
                final String message = "点击次数: ";
                System.out.println(message + clickCount);
                
                // 修改按钮文本
                button.setText("点击次数: " + clickCount);
            }
            
            // 内部方法
            private void log(String msg) {
                System.out.println("日志: " + msg);
            }
        });
        
        // 另一个监听器
        button.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                System.out.println("鼠标进入按钮区域");
            }
            
            @Override
            public void mouseExited(MouseEvent e) {
                System.out.println("鼠标离开按钮区域");
            }
        });
        
        frame.add(button);
        frame.setSize(300, 200);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
    }
}
```

#### 应用2：排序和比较

```
import java.util.*;

class Person {
    private String name;
    private int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public String getName() { return name; }
    public int getAge() { return age; }
    
    @Override
    public String toString() {
        return name + "(" + age + ")";
    }
}

public class SortingDemo {
    public static void main(String[] args) {
        List<Person> people = Arrays.asList(
            new Person("张三", 25),
            new Person("李四", 20),
            new Person("王五", 30),
            new Person("赵六", 22)
        );
        
        System.out.println("原始列表: " + people);
        
        // 使用匿名内部类按年龄排序
        Collections.sort(people, new Comparator<Person>() {
            @Override
            public int compare(Person p1, Person p2) {
                return Integer.compare(p1.getAge(), p2.getAge());
            }
        });
        
        System.out.println("按年龄排序: " + people);
        
        // 使用匿名内部类按姓名排序
        Collections.sort(people, new Comparator<Person>() {
            @Override
            public int compare(Person p1, Person p2) {
                return p1.getName().compareTo(p2.getName());
            }
        });
        
        System.out.println("按姓名排序: " + people);
        
        // 复杂比较：先按年龄，再按姓名
        Collections.sort(people, new Comparator<Person>() {
            @Override
            public int compare(Person p1, Person p2) {
                int ageCompare = Integer.compare(p1.getAge(), p2.getAge());
                if (ageCompare != 0) {
                    return ageCompare;
                }
                return p1.getName().compareTo(p2.getName());
            }
        });
        
        System.out.println("先按年龄再按姓名排序: " + people);
    }
}
```

#### 应用3：线程创建

```
public class ThreadDemo {
    public static void main(String[] args) {
        // 方式1：继承Thread的匿名内部类
        Thread thread1 = new Thread() {
            @Override
            public void run() {
                for (int i = 0; i < 5; i++) {
                    System.out.println("线程1: " + i);
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        
        // 方式2：实现Runnable的匿名内部类
        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 5; i++) {
                    System.out.println("线程2: " + i);
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        });
        
        // 方式3：带参数的匿名内部类
        final String threadName = "工作线程";
        Thread thread3 = new Thread(new Runnable() {
            private int counter = 0;
            
            @Override
            public void run() {
                while (counter < 3) {
                    System.out.println(threadName + " 执行次数: " + (++counter));
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        });
        
        thread1.start();
        thread2.start();
        thread3.start();
        
        // 定时任务
        Timer timer = new Timer();
        timer.schedule(new TimerTask() {
            private int count = 0;
            
            @Override
            public void run() {
                System.out.println("定时任务执行: " + (++count));
                if (count >= 5) {
                    timer.cancel();
                }
            }
        }, 0, 1000);  // 立即开始，每秒执行一次
    }
}
```

### 4. 匿名内部类的构造方法

```
class BaseClass {
    protected String name;
    
    public BaseClass(String name) {
        this.name = name;
        System.out.println("BaseClass构造: " + name);
    }
    
    public void show() {
        System.out.println("BaseClass: " + name);
    }
}

public class AnonymousConstructor {
    public static void main(String[] args) {
        // 匿名内部类可以有构造代码，但没有构造方法声明
        BaseClass obj = new BaseClass("初始名称") {
            // 实例初始化块 - 充当构造方法
            {
                name = "匿名类修改的名称";
                System.out.println("匿名内部类初始化块");
            }
            
            // 重写方法
            @Override
            public void show() {
                super.show();
                System.out.println("匿名内部类重写的方法");
            }
            
            // 添加新方法
            public void extra() {
                System.out.println("额外方法");
            }
        };
        
        obj.show();
        // obj.extra();  // 编译错误，BaseClass类型没有这个方法
        
        // 带参数的匿名内部类
        List<String> list = new ArrayList<String>() {
            // 初始化块添加元素
            {
                add("元素1");
                add("元素2");
                add("元素3");
            }
            
            // 重写方法
            @Override
            public boolean add(String s) {
                System.out.println("添加元素: " + s);
                return super.add(s);
            }
        };
        
        list.add("元素4");
        System.out.println("列表: " + list);
    }
}
```

### 5. 匿名内部类的限制和特点

```
public class AnonymousLimitations {
    public static void main(String[] args) {
        // 1. 不能是抽象类
        // abstract class AbstractLocal { }  // 在匿名内部类中不能是抽象的
        
        // 2. 不能有显式的构造方法
        Object obj = new Object() {
            // 不能有构造方法
            // public MyClass() { }  // 错误
            
            // 但可以有初始化块
            {
                System.out.println("匿名内部类初始化");
            }
            
            // 可以重写方法
            @Override
            public String toString() {
                return "匿名内部类的toString";
            }
        };
        
        System.out.println(obj);
        
        // 3. 不能实现多个接口
        interface A { void a(); }
        interface B { void b(); }
        
        // 只能继承一个类或实现一个接口
        A a = new A() {
            public void a() { System.out.println("A.a()"); }
        };
        
        // 4. 不能是静态的
        // static Object staticObj = new Object() { };  // 错误
        
        // 5. 可以包含静态成员的情况
        Object obj2 = new Object() {
            // Java 16之前：不能有静态成员
            // static int x = 10;  // 错误
            
            // Java 16+：可以有static final常量
            static final int CONSTANT = 100;  // ✓
            
            // 不能有静态方法
            // static void staticMethod() { }  // 错误
        };
        
        // 6. 可以定义内部类
        Runnable r = new Runnable() {
            class Inner {  // 匿名内部类中的内部类
                void show() {
                    System.out.println("嵌套的内部类");
                }
            }
            
            @Override
            public void run() {
                new Inner().show();
            }
        };
        
        new Thread(r).start();
    }
}
```

### 6. Lambda表达式 vs 匿名内部类

```
@FunctionalInterface
interface Operation {
    int calculate(int a, int b);
}

public class LambdaVsAnonymous {
    public static void main(String[] args) {
        // 匿名内部类方式
        Operation add1 = new Operation() {
            @Override
            public int calculate(int a, int b) {
                return a + b;
            }
        };
        
        // Lambda表达式方式
        Operation add2 = (a, b) -> a + b;
        
        System.out.println("匿名内部类: 5 + 3 = " + add1.calculate(5, 3));
        System.out.println("Lambda: 5 + 3 = " + add2.calculate(5, 3));
        
        // 区别1：this关键字
        Operation op1 = new Operation() {
            @Override
            public int calculate(int a, int b) {
                System.out.println("匿名内部类this: " + this.getClass());
                return a * b;
            }
        };
        
        Operation op2 = (a, b) -> {
            // Lambda中的this指向外部类
            System.out.println("Lambda this: " + this.getClass());
            return a * b;
        };
        
        op1.calculate(2, 3);
        op2.calculate(2, 3);
        
        // 区别2：变量访问
        int factor = 2;
        
        Operation multiply1 = new Operation() {
            @Override
            public int calculate(int a, int b) {
                // 可以有自己的状态
                int result = a * b * factor;
                return result;
            }
        };
        
        Operation multiply2 = (a, b) -> a * b * factor;
        
        // 区别3：编译后类文件
        // 匿名内部类：会生成 LambdaVsAnonymous$1.class
        // Lambda表达式：不会生成额外的类文件（使用invokedynamic）
    }
    
    // 不能使用Lambda表达式的情况
    interface ComplexOperation {
        int calculate(int a, int b);
        void log(String message);  // 第二个抽象方法
    }
    
    public void testComplex() {
        // 多个抽象方法，不能使用Lambda
        ComplexOperation complex = new ComplexOperation() {
            @Override
            public int calculate(int a, int b) {
                log("计算: " + a + ", " + b);
                return a + b;
            }
            
            @Override
            public void log(String message) {
                System.out.println("日志: " + message);
            }
        };
        
        // 有状态的匿名内部类
        Operation counter = new Operation() {
            private int count = 0;
            
            @Override
            public int calculate(int a, int b) {
                count++;
                System.out.println("调用次数: " + count);
                return a + b;
            }
        };
        
        counter.calculate(1, 2);
        counter.calculate(3, 4);
    }
}
```

---

## 六、内部类的内存模型

```
class Outer {
    private int data = 100;
    
    class Inner {
        private int innerData = 200;
        
        public void show() {
            System.out.println("外部data: " + data);
            System.out.println("内部innerData: " + innerData);
        }
    }
    
    public void test() {
        // 内部类实例持有外部类引用
        Inner inner = new Inner();
        System.out.println("内部类实例: " + inner);
        inner.show();
    }
}

public class MemoryModel {
    public static void main(String[] args) {
        Outer outer1 = new Outer();
        Outer outer2 = new Outer();
        
        // 每个内部类实例都绑定到一个外部类实例
        Outer.Inner inner1 = outer1.new Inner();
        Outer.Inner inner2 = outer2.new Inner();
        
        // 验证引用
        System.out.println("outer1: " + outer1);
        System.out.println("inner1的外部引用: 通过Outer.this访问");
        
        System.out.println("outer2: " + outer2);
        System.out.println("inner2的外部引用: 通过Outer.this访问");
        
        // 静态内部类不持有外部类引用
        StaticOuter.StaticInner staticInner = new StaticOuter.StaticInner();
        System.out.println("静态内部类: " + staticInner);
    }
}

class StaticOuter {
    static class StaticInner {
        public void show() {
            System.out.println("静态内部类");
        }
    }
}
```

---

## 七、内部类的最佳实践

### 1. 使用场景建议

```
// 1. 紧密相关的类
class LinkedList {
    private Node head;
    
    // 节点类，只被链表使用
    private class Node {
        int data;
        Node next;
        
        Node(int data) {
            this.data = data;
        }
    }
    
    public void add(int data) {
        Node newNode = new Node(data);
        // ... 实现
    }
}

// 2. 迭代器模式
class Collection<T> {
    private List<T> items = new ArrayList<>();
    
    public Iterator<T> iterator() {
        return new IteratorImpl();
    }
    
    // 私有迭代器实现
    private class IteratorImpl implements Iterator<T> {
        private int index = 0;
        
        @Override
        public boolean hasNext() {
            return index < items.size();
        }
        
        @Override
        public T next() {
            return items.get(index++);
        }
    }
}

interface Iterator<T> {
    boolean hasNext();
    T next();
}

// 3. 回调机制
class Downloader {
    public interface Callback {
        void onSuccess(String data);
        void onError(Exception e);
    }
    
    public void download(String url, Callback callback) {
        new Thread(() -> {
            try {
                // 模拟下载
                Thread.sleep(1000);
                String data = "下载的数据";
                callback.onSuccess(data);
            } catch (Exception e) {
                callback.onError(e);
            }
        }).start();
    }
}

// 使用匿名内部类作为回调
class Client {
    public void test() {
        Downloader downloader = new Downloader();
        downloader.download("http://example.com", new Downloader.Callback() {
            @Override
            public void onSuccess(String data) {
                System.out.println("下载成功: " + data);
            }
            
            @Override
            public void onError(Exception e) {
                System.err.println("下载失败: " + e.getMessage());
            }
        });
    }
}
```

### 2. 性能考虑

```
class PerformanceTest {
    private int value = 10;
    
    // 非静态内部类
    class Inner {
        public int getValue() {
            return value;
        }
    }
    
    // 静态内部类
    static class StaticInner {
        public int getValue(PerformanceTest obj) {
            return obj.value;
        }
    }
    
    public void testPerformance() {
        int iterations = 10_000_000;
        
        // 测试非静态内部类
        long start1 = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            Inner inner = new Inner();
            inner.getValue();
        }
        long time1 = System.nanoTime() - start1;
        
        // 测试静态内部类
        long start2 = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            StaticInner staticInner = new StaticInner();
            staticInner.getValue(this);
        }
        long time2 = System.nanoTime() - start2;
        
        System.out.printf("非静态内部类: %.2f ms%n", time1 / 1_000_000.0);
        System.out.printf("静态内部类: %.2f ms%n", time2 / 1_000_000.0);
        
        // 结论：静态内部类性能稍好，但差异通常不大
    }
}
```

---

## 八、总结

### 各类内部类对比

|类型|语法|是否有外部类引用|能否有静态成员|访问权限|使用场景|
|---|---|---|---|---|---|
|成员内部类|`class Outer { class Inner {} }`|是|Java 16+可以有|任意|紧密关联的组件|
|静态内部类|`class Outer { static class Inner {} }`|否|可以|任意|工具类、Builder模式|
|局部内部类|方法内定义|是|有限制|默认|方法内临时使用|
|匿名内部类|`new Interface() { }`|是|有限制|默认|回调、事件监听|

### 匿名内部类重点总结：

1. **定义**：没有类名的内部类
    
2. **语法**：`new 父类/接口() { 类体 }`
    
3. **特点**：
    
    - 只能继承一个类或实现一个接口
        
    - 不能有构造方法，但可以有初始化块
        
    - 可以访问final或等效final的局部变量
        
    - 可以有额外方法，但外部无法调用
        
    
4. **使用场景**：
    
    - 事件监听器
        
    - 线程创建
        
    - 排序比较器
        
    - 回调函数
        
    
5. **vs Lambda**：
    
    - Lambda只能用于函数式接口
        
    - 匿名内部类可以有状态
        
    - 匿名内部类可以重写多个方法
        
    

### 最佳实践：

1. **优先使用静态内部类**：除非需要访问外部实例成员
    
2. **合理使用匿名内部类**：只在简单、一次性场景使用
    
3. **考虑Lambda替代**：函数式接口优先用Lambda
    
4. **注意内存泄漏**：非静态内部类持有外部引用
    
5. **明确访问权限**：合理使用private、protected
    

### 常见面试题：

1. **内部类如何访问外部类成员？**
    
    - 非静态：直接访问
        
    - 静态：通过外部类实例访问
        
    
2. **匿名内部类能继承抽象类吗？**
    
    - 可以，语法：`new 抽象类() { 实现方法 }`
        
    
3. **为什么匿名内部类访问的局部变量必须是final？**
    
    - 生命周期问题：局部变量在方法结束后销毁
        
    - 匿名内部类可能在其他线程使用该变量
        
    - Java通过复制final变量的值来解决
        
    
4. **内部类编译后生成什么文件？**
    
    - 成员内部类：`Outer$Inner.class`
        
    - 匿名内部类：`Outer$1.class`、`Outer$2.class`
        
    
5. **什么时候用内部类？**
    
    - 类只被一个类使用时
        
    - 需要访问外部类的私有成员时
        
    - 实现多继承的变通方案时