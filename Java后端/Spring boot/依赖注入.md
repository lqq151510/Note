`@Autowired`是 Spring 框架中用于实现**依赖注入**的核心注解。它的核心作用是让 Spring 容器自动将你所需要的组件（Bean）装配到指定的位置，从而无需手动通过 `new`关键字来创建对象，有效降低了代码之间的耦合度。

下面这个表格汇总了 `@Autowired`的核心特性，帮你快速建立整体认知。

|特性|说明|
|---|---|
|**核心功能**​|**依赖注入**，由 Spring 容器自动将 Bean 装配到指定位置。|
|**默认装配方式**​|**按类型匹配**。容器会查找与所需类型相同的 Bean 进行注入。|
|**可用位置**​|成员变量、Setter 方法、**构造方法**、普通方法、方法参数。|
|**关键属性**​|`required`：默认为 `true`，表示依赖必须存在，否则报错；设为 `false`时，找不到依赖则注入 `null`。|

### 💡 主要用法详解

`@Autowired`非常灵活，可以根据不同场景应用在多种位置。

1. **字段注入**
    
    这是最直接和常见的方式，直接将注解标注在字段上。Spring 会通过反射机制为私有字段赋值。
    
    ```
    @Service
    public class BookService {
        @Autowired
        private BookRepository bookRepository;
    }
    ```
    
2. **Setter 方法注入**
    
    将注解标注在 Setter 方法上，Spring 会调用该方法并传入依赖对象。
    
    ```
    @Service
    public class BookService {
        private BookRepository bookRepository;
    
        @Autowired
        public void setBookRepository(BookRepository bookRepository) {
            this.bookRepository = bookRepository;
        }
    }
    ```
    
3. **构造器注入**
    
    将注解标注在构造方法上。这是 **Spring 团队推荐**的方式，因为它能明确依赖关系，并确保依赖对象在初始化时就被设置好，有利于实现不可变对象。
    
    ```
    @Service
    public class BookService {
        private final BookRepository bookRepository;
    
        @Autowired
        public BookService(BookRepository bookRepository) {
            this.bookRepository = bookRepository;
        }
    }
    ```
    
    **注意**：在 Spring 4.3 及以后版本，如果类只有一个构造方法，`@Autowired`注解可以省略。
    
4. **其他方法注入**
    
    实际上，你可以将 `@Autowired`标注在**任何包含参数的方法**上。Spring 容器在创建 Bean 后，会自动调用该方法，并将方法参数自动装配。
    
    ```
    @Service
    public class BookService {
        private BookRepository bookRepository;
    
        @Autowired
        public void prepare(BookRepository bookRepository) {
            this.bookRepository = bookRepository;
        }
    }
    ```
    

### 🛠️ 处理歧义性：当有多个同类型 Bean 时

默认按类型装配的方式，在遇到同一类型有多个实现时就会失效。例如，有一个 `BookRepository`接口，它有 `JdbcBookRepository`和 `MongoBookRepository`两个实现类，Spring 无法知道该注入哪一个，此时会抛出 `NoUniqueBeanDefinitionException`异常。

解决这个问题主要有两种方式：

1. **使用 `@Qualifier`指定 Bean 名称**
    
    通过 `@Qualifier`注解显式指定要注入的 Bean 的 ID 或名称。
    
    ```
    @Service
    public class BookService {
        @Autowired
        @Qualifier("jdbcBookRepository") // 指定注入名为 jdbcBookRepository 的 Bean
        private BookRepository bookRepository;
    }
    ```
    
2. **使用 `@Primary`设置首选 Bean**
    
    在多个候选 Bean 中，将其中一个标记为 `@Primary`。当按类型查找出现多个时，Spring 会优先选择带有 `@Primary`注解的 Bean。
    
    ```
    @Repository
    @Primary // 当需要 BookRepository 时，优先注入这个
    public class JdbcBookRepository implements BookRepository { ... }
    ```
    

### ⚙️ 进阶特性

- **注入集合类型**：`@Autowired`的强大之处在于，它可以自动注入**所有**符合类型的 Bean 到集合中。
    
    ```
    @Service
    public class OrderService {
        // 将所有实现了 DiscountCalculator 接口的 Bean 注入到 List 中
        @Autowired
        private List<DiscountCalculator> calculators;
    
        // 也可以注入到 Map，Key 为 Bean 的名称
        @Autowired
        private Map<String, DiscountCalculator> calculatorMap;
    }
    ```
    
- **`required`属性**：将 `@Autowired(required = false)`设置为非必须时，如果 Spring 找不到匹配的 Bean，则会注入 `null`。使用时要小心避免空指针异常。
    

### ⚠️ 常见问题与最佳实践

- **确保 Bean 被 Spring 管理**：被 `@Autowired`注入的类本身必须也是一个由 Spring 管理的 Bean（使用 `@Component`, `@Service`, `@Repository`等注解标记）。
    
- **避免循环依赖**：两个 Bean 互相依赖（A 依赖 B，B 也依赖 A）可能导致问题。虽然 Spring 有机制（三级缓存）尝试解决，但良好的设计应尽量避免循环依赖。
    
- **推荐使用构造器注入**：对于必须的依赖，使用构造器注入可以使组件在初始化后就处于完全可用状态，并且依赖关系更清晰，有利于测试。
    

希望这些解释能帮助你全面理解 `@Autowired`注解。如果你对特定用法或与其他注解（如 `@Resource`）的区别有进一步兴趣，我们可以继续探讨。