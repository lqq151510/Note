Spring Cache 是 Spring 框架提供的一套缓存抽象层（Cache Abstraction），它通过在方法上添加注解，实现对方法返回结果的缓存，从而避免重复计算或数据库查询，提升应用性能。

### 核心特性

1. **声明式缓存**：通过注解（如 `@Cacheable`）定义缓存行为，无需侵入业务代码。
    
2. **多种缓存支持**：抽象层统一，支持与多种缓存提供商（如 Caffeine、Redis、Ehcache 等）集成。
    
3. **SpEL 支持**：注解中的关键属性（如缓存名、键）支持使用 Spring 表达式语言（SpEL）进行动态配置。
    

### 常用注解

- **`==@Cacheable`==**：表明方法的结果是可缓存的。执行前先检查缓存，若命中则直接返回缓存值，否则执行方法并将结果存入缓存。
    
    - 常用属性：`value`/`cacheNames`（缓存名称）、`key`（缓存键，支持 SpEL）、`condition`（缓存条件）。
        
    
- ==**`@CachePut==`**：总是执行方法，并用其结果更新对应的缓存。通常用于更新操作。
    
- *==*`@CacheEvict==`**：从缓存中移除一个或全部数据。通常用于删除操作。
    
    - 常用属性：`key`（指定移除的键）、`allEntries`（是否清空整个缓存区）。
        
    
- **`@Caching`**：组合多个缓存操作注解。
    
- **`@CacheConfig`**：在类级别共享缓存配置（如缓存名称）。
    

### 基本配置（以 Spring Boot 为例）

1. **添加依赖**：引入缓存 starter 和具体的缓存实现（如 Caffeine）。
    
    ```
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-cache</artifactId>
    </dependency>
    <dependency>
        <groupId>com.github.ben-manes.caffeine</groupId>
        <artifactId>caffeine</artifactId>
    </dependency>
    ```
    
1. **启用缓存**：==在主应用类或配置类上添加 `==@EnableCaching==`==。
    
2. **配置缓存管理器**：Spring Boot 会根据依赖自动配置（如 `CaffeineCacheManager`），也可在 `application.yml`中自定义。
    

### 典型应用场景

- **读多写少的数据**：如商品信息、配置数据。
    
- **热点数据**：频繁访问的数据库查询结果。
    
- **耗时计算的结果**：如复杂的报表数据。
    

### 示例代码

```
@Service
@CacheConfig(cacheNames = "users") // 类级别默认缓存名
public class UserService {

    @Cacheable(key = "#id", unless = "#result == null") // 按id缓存，结果为null时不缓存
    public User getUserById(Long id) {
        // 模拟数据库查询
        return findUserFromDB(id);
    }

    @CachePut(key = "#user.id") // 更新用户后，同步更新缓存
    public User updateUser(User user) {
        // 更新数据库
        return saveUserToDB(user);
    }

    @CacheEvict(key = "#id") // 删除用户后，移除对应缓存
    public void deleteUserById(Long id) {
        deleteUserFromDB(id);
    }
}
```

### 注意事项

- **默认键生成**：如果未指定 `key`，Spring 会使用方法参数生成一个键（简单参数直接使用，对象使用其 `hashCode()`）。
    
- **缓存一致性**：在更新或删除数据时，需通过 `@CachePut`或 `@CacheEvict`及时维护缓存，避免脏数据。
    
- **序列化**：使用分布式缓存（如 Redis）时，返回的对象需实现 `Serializable`接口。
    
- **缓存穿透/雪崩**：生产环境需考虑缓存空值、设置过期时间、使用锁等策略来防止这些问题。
    

Spring Cache 通过简洁的注解大幅降低了缓存的使用门槛，是提升 Spring 应用性能的常用工具。