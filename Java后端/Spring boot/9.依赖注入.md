依赖注入（Dependency Injection，简称 DI）是一种重要的软件设计模式，也是实现控制反转（IoC）原则的核心技术。它的核心思想是**将对象的创建和依赖关系的管理从对象内部转移到外部容器或框架**，从而大幅降低代码的耦合度，提升程序的可维护性、可测试性和可扩展性。

为了让你快速把握精髓，下表对比了传统编码方式与使用依赖注入方式的主要区别：

|对比维度|传统方式 (对象自己控制依赖)|依赖注入方式 (容器控制依赖)|
|---|---|---|
|**控制权**​|对象内部主动创建依赖 (`new Xxx()`)|容器在外部创建并注入依赖，对象被动接收|
|**耦合度**​|**高耦合**，对象直接依赖具体实现类|**低耦合**，对象仅依赖抽象（接口或抽象类）|
|**灵活性**​|差，修改依赖需要改动代码|强，通过配置即可替换依赖的实现，符合开闭原则|
|**可测试性**​|难，难以隔离测试对象，依赖无法模拟|易，可以轻松注入模拟对象进行单元测试|

### 💡 核心原理：谁来做主？

想象一下制造汽车。传统方式是，汽车工厂需要自己生产每一个零件，包括最核心的引擎。这导致工厂和特定引擎品牌深度绑定，如果想换一种引擎，整个生产线都要改动。

**依赖注入**则完全不同。汽车工厂不再生产引擎，而是定义一个标准的引擎接口。任何符合该接口的引擎都可以被“注入”到汽车里。这个注入的动作，由一个专门的“装配中心”（即IoC容器）来完成。

简单来说，依赖注入实现了**依赖对象的获得被反转了**。原本由对象A自己负责创建和管理依赖对象B，现在转变为由一个统一的外部容器来创建B，并在适当的时候提供给A。

### 🛠️ 三种常见的注入方式

依赖注入主要通过以下三种方式实现：

1. **构造函数注入**
    
    在创建对象时，通过其构造函数将依赖项传入。这是**最推荐**的方式，因为它可以保证依赖项在对象创建时就完全就绪，且对象在其生命周期内是不可变的（如果使用final字段）。
    
    ```
    public class UserService {
        private final UserRepository userRepository;
        // 依赖通过构造函数注入
        public UserService(UserRepository userRepository) {
            this.userRepository = userRepository;
        }
    }
    能清晰看到类的依赖关系，提高代码安全性
    
    代码繁琐，如果构造参数多，会导致代码臃肿
    ```
    
2. **Setter方法注入**
    
    通过对象的setter方法将依赖项传入。这种方式提供了更灵活的注入时机，但无法保证依赖项在对象使用时已被设置。
    
    ```
    public class UserService {
        private UserRepository userRepository;
        // 依赖通过setter方法注入
        public void setUserRepository(UserRepository userRepository) {
            this.userRepository = userRepository;
        }
    }
    保持类的封装性，依赖关系清晰
    
    需要额外编写setter方法，增加代码量
    ```
    
1. **属性注入**
    
```
@RestController//将UserController类的实例注册到Spring容器中
public class UserController {
    @Autowired
    private UserService userService;

    }
}
代码简洁，方便开发

隐藏类与类之间的依赖关系，可能破坏封装性
```
    

### 🚀 依赖注入的价值

采用依赖注入能带来多重好处：

- **提升可测试性**：单元测试时，可以轻松地将真实的、复杂的依赖（如数据库连接、网络请求）替换为模拟对象，让测试更纯粹、更快速。
    
- **降低耦合度**：组件不再依赖于具体的实现，而是依赖于抽象接口。这使得更换实现变得非常简单，只需修改配置即可，无需改动业务代码。
    
- **增强可维护性和可扩展性**：程序的各个部分职责更加单一，代码结构更清晰，便于团队协作和功能扩展。
    
- **统一管理资源**：IoC容器可以统一管理组件的生命周期（如单例、多例）以及依赖关系。
    

### 📦 依赖注入容器

在现代开发中，我们通常使用**依赖注入容器**（或称为IoC容器）来自动化管理所有这些依赖关系的创建和注入。Spring框架的核心就是一个功能强大的IoC容器。在Spring中，你通过注解（如`@Autowired`）或配置告诉容器依赖关系，容器就会在运行时自动为你完成装配。

```
// 在Spring中，使用注解非常简单
@Service
public class UserService {
    @Autowired // Spring容器会自动查找并注入UserRepository类型的Bean
    private UserRepository userRepository;
}
```

希望这份解释能帮助你清晰地理解依赖注入这一核心概念。它是构建松耦合、高质量软件系统的基石。如果你对如何在Spring中具体使用依赖注入，或者对其中的细节有更多疑问，我们可以继续深入探讨。



下面我帮你梳理一下这三种方式的特点和适用场景，方便你根据实际情况选择。

### 💉 三种依赖注入方式对比

|注入方式|优点|缺点|适用场景|
|---|---|---|---|
|**属性注入**​|代码简洁，编写方便|1. 不能用于注入不可变对象（final 字段）  <br>2. 类与 Spring 容器强耦合，难以脱离容器进行单元测试  <br>3. 依赖关系隐式，不够明确|快速原型开发、小型应用|
|**Setterm 注入**​|1. 灵活性高，注入的对象可以被重新设置  <br>2. 符合单一职责原则，每个 setter 只针对一个对象  <br>3. 便于进行单元测试|1. 不能保证依赖不可变（注入后可能被修改）  <br>2. 代码相对臃肿|**可选依赖**（即对象可以正常工作即使没有该依赖）|
|**构造器注入**​|1. **依赖不可变**：可使用 final 修饰符  <br>2. **依赖不为空**：保证完全初始化的状态，避免空指针  <br>3. **易于测试**：依赖关系明确，便于编写单元测试  <br>4. 能更好地检测循环依赖|当依赖项过多时，构造函数会显得冗长|**强制依赖**（对象正常工作的必要依赖），**Spring 官方推荐的方式**​|

### 💡 如何选择？

- **首选构造器注入**：对于程序运行所必需的**强制依赖**，强烈建议使用构造器注入。这是目前 Spring 官方最推荐的方式，它能保证你的代码更健壮、更安全 。
    
- **次选 Setter 注入**：如果某个依赖是**可选的**，或者在程序运行过程中可能需要改变，那么 Setter 注入是更合适的选择 。
    
- **属性注入需谨慎**：虽然写法简单，但由于其固有的缺点，在现代 Spring 应用开发中已不推荐作为首选 。
    

希望这个总结对你有帮助！如果你对某种注入方式的细节或在实际项目中的应用有更多疑问，我们可以继续探讨。