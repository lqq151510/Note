`@Builder`是 **Lombok**​ 库中的一个注解，用于自动生成**建造者模式（Builder Pattern）**​ 的代码。它让对象创建变得灵活、可读性更强，特别适合创建具有多个可选参数的复杂对象。

## 核心作用

为类自动生成一个内部 Builder 类，支持**链式调用**和**部分参数初始化**。

## 基本使用

### 1. 基础用法

```
import lombok.Builder;
import lombok.Getter;

@Getter
@Builder
public class User {
    private Long id;
    private String name;
    private String email;
    private Integer age;
    private String address;
}

// 创建对象 - 链式调用，清晰易读
User user = User.builder()
    .name("张三")
    .email("zhang@example.com")
    .age(25)
    .build();

// 只设置部分参数（address使用默认值null）
User user2 = User.builder()
    .name("李四")
    .age(30)
    .build();
```

### 2. 带默认值的 Builder

```
@Builder
@Getter
public class Product {
    @Builder.Default  // 设置默认值
    private Integer stock = 100;
    
    @Builder.Default
    private Boolean available = true;
    
    private String name;
    private Double price;
}

// 使用：未设置的字段使用默认值
Product product = Product.builder()
    .name("手机")
    .price(2999.0)
    .build();
// stock=100, available=true
```

## 高级特性

### 1. `@Builder`在构造方法上

```
public class Order {
    private Long id;
    private String orderNo;
    private BigDecimal amount;
    
    @Builder  // 只为这个构造方法生成Builder
    public Order(String orderNo, BigDecimal amount) {
        this.orderNo = orderNo;
        this.amount = amount;
    }
}

// 使用特定构造方法的Builder
Order order = Order.builder()
    .orderNo("ORD20260001")
    .amount(new BigDecimal("999.99"))
    .build();
```

### 2. 方法级别的 `@Builder`

```
@Getter
public class Response<T> {
    private int code;
    private String message;
    private T data;
    
    // 为静态方法生成Builder
    @Builder(builderMethodName = "successBuilder")
    public static <T> Response<T> success(T data) {
        Response<T> response = new Response<>();
        response.code = 200;
        response.message = "成功";
        response.data = data;
        return response;
    }
}

// 使用静态方法的Builder
Response<User> response = Response.successBuilder()
    .data(user)
    .build();
```

## 与普通构造方法的对比

### ❌ 传统构造方法的问题

```
// 1. 构造方法冗长
public User(Long id, String name, String email, Integer age, String address) {
    // ...
}

// 2. 需要多个重载构造方法
public User(String name) { /* ... */ }
public User(String name, String email) { /* ... */ }

// 3. 使用混乱，容易参数错位
User user = new User(null, "张三", null, 25, null);
// 哪个参数对应哪个？容易出错！
```

### ✅ @Builder 的优势

```
// 清晰明了，避免参数错位
User user = User.builder()
    .name("张三")      // 明确知道设置的是name
    .age(25)          // 明确知道设置的是age
    .build();         // 其他字段保持null或默认值
```

## 实际应用场景

### 1. DTO/VO 对象创建

```
// API响应对象
@Builder
@Getter
public class ApiResponse<T> {
    private boolean success;
    private String code;
    private String message;
    private T data;
    private Long timestamp;
    
    @Builder.Default
    private Map<String, Object> metadata = new HashMap<>();
}

// 构建复杂的API响应
ApiResponse<UserDTO> response = ApiResponse.<UserDTO>builder()
    .success(true)
    .code("200")
    .message("操作成功")
    .data(userDTO)
    .timestamp(System.currentTimeMillis())
    .metadata(Map.of("traceId", "abc123"))
    .build();
```

### 2. 配置类对象

```
@Builder
@Getter
public class RedisConfig {
    @Builder.Default
    private String host = "localhost";
    
    @Builder.Default
    private Integer port = 6379;
    
    @Builder.Default
    private Integer timeout = 3000;
    
    private String password;
}

// 配置对象创建
RedisConfig config = RedisConfig.builder()
    .host("192.168.1.100")
    .port(16379)
    .password("secret")
    .build();
```

## 与其他 Lombok 注解配合

```
@Data                    // 生成getter/setter/toString等
@Builder
@NoArgsConstructor      // 无参构造
@AllArgsConstructor     // 全参构造
public class Employee {
    private Long id;
    private String name;
    private String department;
    @Builder.Default
    private LocalDateTime hireDate = LocalDateTime.now();
}

// 可以这样使用：
Employee emp1 = Employee.builder()
    .name("王五")
    .department("技术部")
    .build();

Employee emp2 = new Employee();  // 无参构造
Employee emp3 = new Employee(1L, "赵六", "市场部", LocalDateTime.now());  // 全参构造
```

## 注意事项

1. **不可变性**：Builder 创建的对象默认是**可变**的，如果需要不可变对象，配合 `@Value`使用
    
    ```
    @Value
    @Builder
    public class ImmutablePoint {
        private final int x;
        private final int y;
    }
    ```
    
2. **继承问题**：Builder 默认不支持继承，父类的 Builder 不会包含子类字段
    
    ```
    // 解决方案：使用 @SuperBuilder（Lombok 1.18.2+）
    @SuperBuilder
    public class Parent { /* ... */ }
    
    @SuperBuilder
    public class Child extends Parent { /* ... */ }
    ```
    
3. **性能考虑**：Builder 会生成额外的类文件，但运行时性能影响极小
    

## 总结

`@Builder`的主要优势：

- ✅ **可读性强**：链式调用，意图明确
    
- ✅ **灵活性高**：支持部分参数初始化
    
- ✅ **维护性好**：避免构造方法爆炸
    
- ✅ **安全性高**：避免参数顺序错误
    

适合场景：DTO/VO对象、配置类、复杂业务对象等需要多个可选参数的类。