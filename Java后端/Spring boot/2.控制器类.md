在Spring Boot中，`@RestController`、`@RequestMapping("/hello")`和 `@GetMapping`是构建Web控制器最核心的三个注解。为了让你快速把握全局，下面这个表格清晰地展示了它们的角色和协作方式。

|注解|角色与层级|主要职责|类比|
|---|---|---|---|
|**`@RestController`**​|**类级别**​|1. 标记整个类为**RESTful控制器**；  <br>2. 确保方法返回值直接作为**HTTP响应体**。|公司的**部门**（如“客服部”）|
|**`@RequestMapping`**​|类/方法级别|1. **定义请求的基准路径**；  <br>2. 可配置更复杂的映射条件（如请求头、类型）。|部门的**总机号码**或**服务范围**​|
|**`@GetMapping`**​|**方法级别**​|**`@RequestMapping`的快捷方式**，专门映射**HTTP GET**请求到特定方法。|部门内处理**查询业务**的**专员分机**​|

### 💡 注解详解与协作流程

**1. @RestController：声明主阵地**

这是你的控制器类的“身份证”。它本身是一个**组合注解**，结合了`@Controller`和`@ResponseBody`的功能。这意味着：

- 被它标记的类会被Spring容器识别为Web控制器。
    
- 该类中所有方法的返回值**不会被视为视图名称**（即不会跳转到JSP或Thymeleaf页面），而是会通过Spring内置的转换机制（如Jackson库）**直接序列化为JSON或XML**，并写入HTTP响应体。这非常适合构建前后端分离的RESTful API。
    

**2. @RequestMapping：规划路线图**

这个注解非常灵活，可以用在**类上**或**方法上**，其主要作用是为HTTP请求映射到具体的处理方法提供规则。

- **在类上使用**：通常用来定义**所有处理方法的共同基准路径**。例如，`@RequestMapping("/api")`意味着这个控制器下的所有接口地址都以`/api`开头。
    
- **在方法上使用**：定义具体方法的访问路径。它支持精细控制，不仅可以指定路径，还能通过`method`属性限定HTTP方法（如`method = RequestMethod.GET`），通过`produces`和`consumes`指定接收和返回的数据类型等。
    

**3. @GetMapping：处理GET请求的专员**

`@GetMapping`是Spring 4.3引入的**组合注解**，它的作用等价于`@RequestMapping(method = RequestMethod.GET)`。它**通常只用于方法上**，是一种更简洁、更具表达力的写法，专门用于处理HTTP GET请求。GET请求通常用于**获取资源**，不应涉及修改服务器数据的操作。

### 🛠️ 完整代码示例

下面的代码片段展示了这三个注解如何协同工作，共同定义一个完整的RESTful接口：

```
import org.springframework.web.bind.annotation.*;

// 1. 使用 @RestController 声明这是一个RESTful控制器
@RestController
// 2. 使用 @RequestMapping 在类级别定义基准路径为 "/hello"
@RequestMapping("/hello")
public class HelloController {

    // 3. 使用 @GetMapping 在方法级别映射GET请求到 "/hello/sayHello"
    @GetMapping("/sayHello") 
    public String sayHello() {
        return "Hello, World!";
    }

    // 4. 另一个例子：通过路径变量接收参数
    @GetMapping("/greet/{name}")
    public String greetUser(@PathVariable String name) {
        return "Hello, " + name;
    }
}
```

**代码执行流程**：

1. 当你在浏览器访问 `http://localhost:8080/hello/sayHello`时，Spring MVC会接收到这个GET请求。
    
2. 它首先根据类上的`@RequestMapping("/hello")`找到`HelloController`。
    
3. 然后，根据方法上的`@GetMapping("/sayHello")`找到具体的处理方法`sayHello()`。
    
4. 方法执行，返回字符串。
    
5. 由于类上有`@RestController`，返回值`"Hello, World!"`会被直接写入HTTP响应体，而不是去查找一个名为`"Hello, World!"`的视图页面。
    

### ⚠️ 核心区别与最佳实践

- **`@RestController`vs `@Controller`**：这是最根本的区别。如果你的控制器旨在返回数据（如JSON），请使用`@RestController`。如果你的控制器需要返回一个视图页面（如JSP、HTML），则使用`@Controller`，并且方法需要返回视图名称。
    
- **`@GetMapping`vs `@RequestMapping`**：在处理GET请求时，**优先使用更专一、更简洁的`@GetMapping`**，这能使代码意图更清晰。只有在需要非常复杂的映射条件（例如同时支持多种HTTP方法，或需要精细控制`headers`、`params`时）才考虑使用完整的`@RequestMapping`。
    

希望这份详细的解释能帮助你彻底理解这三个核心注解。如果你对如何处理POST请求（`@PostMapping`）或其他HTTP方法有疑问，我很乐意继续介绍。