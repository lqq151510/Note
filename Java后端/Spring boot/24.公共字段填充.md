在 Java 开发中，“公共字段填充”通常指在数据持久化（如保存、更新）时，自动为实体对象的某些通用字段（如创建人、创建时间、更新人、更新时间、逻辑删除标识等）赋予值的流程。这是实现数据审计、统一元数据管理的关键技术。

其核心目标是：**将分散的、重复的赋值逻辑抽取出来，通过统一的入口自动处理，保证数据一致性并提升开发效率。**

一个典型的、结构化的实现流程如下：

```
flowchart TD
    A[客户端发起保存/更新请求] --> B{拦截请求/方法调用}
    B --> C[进入统一处理切面/拦截器]
    
    C --> D[获取当前操作上下文]
    D --> D1[当前用户ID (来自ThreadLocal/SecurityContext)]
    D --> D2[当前时间 (new Date)]
    
    D1 & D2 --> E{判断操作类型}
    
    E -- “新增操作” --> F[填充“创建”相关字段<br>createBy, createTime]
    E -- “更新操作” --> G[填充“更新”相关字段<br>updateBy, updateTime]
    
    F --> H[将填充后的实体对象<br>传递给原业务方法]
    G --> H
    
    H --> I[业务方法正常执行<br>（如调用Mapper的insert/update）]
```

以下是实现这一流程的三种主流方案及其关键要点：

#### **方案一：基于 AOP 或拦截器（框架通用）**

这是最灵活、对业务代码无侵入的方式。

1. **定义注解**：创建如 `@AutoFill`的注解，可标注在方法上，并通过属性区分操作类型（INSERT/UPDATE）。
    
2. **编写切面（Aspect）**：
    
    - 拦截所有被 `@AutoFill`注解的方法。
        
    - 利用 **JoinPoint**​ 获取方法参数中的实体对象。
        
    - **获取上下文**：通过工具类（如基于 `ThreadLocal`）或 `SecurityContextHolder`获取当前操作员信息。
        
    - **反射赋值**：判断操作类型，使用反射（Reflection）或 `BeanWrapper`为实体对象的公共字段（如 `setCreateTime`, `setUpdateBy`）设值。
        
     在Mapper的方法加入AutoFill注解 
1. **优点**：适用于任何 ORM 框架（MyBatis, JPA），与持久层实现解耦。
    
2. **缺点**：反射操作有一定性能开销。
    

#### **方案二：利用 ORM 框架提供的扩展点（推荐，更高效）**

以 **MyBatis-Plus**​ 为例，这是目前最流行的方案：

1. **实现 `MetaObjectHandler`接口**：
    
    ```
    @Component
    public class MyMetaObjectHandler implements MetaObjectHandler {
        @Override
        public void insertFill(MetaObject metaObject) {
            this.strictInsertFill(metaObject, "createTime", LocalDateTime.class, LocalDateTime.now());
            this.strictInsertFill(metaObject, "createBy", String.class, getCurrentUserId());
        }
        @Override
        public void updateFill(MetaObject metaObject) {
            this.strictUpdateFill(metaObject, "updateTime", LocalDateTime.class, LocalDateTime.now());
            this.strictInsertFill(metaObject, "updateBy", String.class, getCurrentUserId());
        }
    }
    ```
    
2. **原理**：MyBatis-Plus 在执行 `insert()`和 `update()`方法时，会自动调用这个处理器。
    
3. **优点**：无侵入、零反射（内部使用缓存）、性能高、配置简单。
    

#### **方案三：使用 JPA 的监听器（适用于 Spring Data JPA）**

1. **使用 `@EntityListeners`注解**：
    
    ```
    @EntityListeners(AuditingEntityListener.class)
    @Entity
    public class User {
        @CreatedDate
        private Date createTime;
        @LastModifiedDate
        private Date updateTime;
        @CreatedBy
        private String createBy;
        @LastModifiedBy
        private String updateBy;
    }
    ```
    
2. **配置审计器**：定义一个实现 `AuditorAware`的 Bean 来提供当前用户信息。
    
3. **优点**：规范标准，声明式配置，与 JPA 生态结合完美。
    

#### **核心设计要点与最佳实践**

1. **上下文获取**：填充“操作人ID”的难点在于如何获取当前用户。通常使用：
    
    - **`ThreadLocal`**：在登录拦截器中将用户信息存入，在填充器里取出。
        
    - **Spring Security**：通过 `SecurityContextHolder.getContext().getAuthentication()`获取。
        
    
2. **时间处理**：
    
    - 建议使用 `LocalDateTime`（Java 8+）或 `Date`。
        
    - 数据库层面，也可在字段上设置默认值（如 `CURRENT_TIMESTAMP`）作为双重保障。
        
    
3. **字段设计**：实体类中的公共字段通常定义为抽象基类，让所有实体继承。
    
4. **逻辑删除**：`deleted`标志字段的填充（通常设为 0 或 1）也在此流程中处理，MyBatis-Plus 提供了 `@TableLogic`注解自动实现。
    

**总结**：公共字段填充是一个典型的**横切关注点**，应通过**拦截+注入**的模式实现。对于 MyBatis 项目，**首选 MyBatis-Plus 的 `MetaObjectHandler`**；对于 JPA 项目，使用 **`@EntityListeners`审计功能**；如需框架无关的灵活方案，则采用 **自定义 AOP 切面**。关键在于将业务代码与这类基础支撑逻辑彻底解耦。