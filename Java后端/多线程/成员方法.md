在Java多线程编程中，`Thread`类提供了许多核心方法来管理线程的生命周期和行为。下面这个表格汇总了最常用的成员方法，帮助你快速掌握其功能。

|方法类别|方法签名|核心作用|关键说明|
|---|---|---|---|
|**线程基本信息**​|`String getName()`|获取线程名称。|未设置时，默认为 `Thread-<编号>`。|
||`void setName(String name)`|设置线程名称。|可通过构造方法或此方法设置。|
||`static Thread currentThread()`|**获取当前正在执行的线程对象**。|静态方法。是理解代码在哪个线程中运行的关键。|
|**线程生命周期控制**​|`void start()`|**启动新线程**。|使线程进入就绪状态，JVM会自动调用其`run()`方法。**一个线程只能启动一次**。|
||`static void sleep(long millis)`|**让当前正在执行的线程休眠**指定的毫秒数。|静态方法。休眠时**不释放已持有的锁**，线程进入`TIMED_WAITING`状态。|
||`final void join()`|**等待调用该方法的线程执行完毕**，当前线程才继续执行。|常用于协调线程间的执行顺序，实现“插队”效果。|
||`final void setDaemon(boolean on)`|将线程设置为**守护线程（Daemon Thread）**。|**必须在`start()`方法前调用**。当所有非守护线程结束时，JVM会终止所有守护线程。|
|**线程调度与优先级**​|`final void setPriority(int newPriority)`|设置线程优先级。|优先级范围1(`MIN_PRIORITY`)到10(`MAX_PRIORITY`)，默认5(`NORM_PRIORITY`)。**优先级高的线程只是获得CPU时间片的概率更大，并非绝对优先**。|
||`static void yield()`|**提示调度器当前线程愿意让出当前CPU使用权**。|静态方法。这是一种“礼让”行为，但调度器可以忽略此提示。|
|**线程中断**​|`void interrupt()`|**中断此线程**。|如果线程因`sleep`, `wait`, `join`而阻塞，会抛出`InterruptedException`并清除中断状态。|
||`static boolean interrupted()`|测试**当前线程**是否已被中断。|静态方法。**调用后会清除线程的中断状态**（即连续两次调用，第二次可能返回false）。|
||`boolean isInterrupted()`|测试**此线程对象**是否已被中断。|不清除线程的中断状态。|

### 💡 深入理解关键方法

- **`start()`vs `run()`**：这是初学者最易混淆的点。直接调用`run()`方法只会像普通方法一样在当前线程中顺序执行，**不会创建新线程**。启动新线程必须调用`start()`方法。
    
- **守护线程的典型场景**：守护线程通常用于执行支持性任务，如垃圾回收、监控等。它们的存在是为非守护线程（如主线程、处理用户请求的线程）服务的。一旦所有非守护线程结束，守护线程会随之终止，即使任务未完成。
    
- **`join()`的协作机制**：`join()`方法常用于需要等待子线程执行完毕并获取其结果后，主线程才能继续执行的场景。它可以协调多个线程的执行顺序。
    

### ⚠️ 实践中的注意事项

1. **异常处理**：`Thread.sleep()`和`join()`方法都会抛出**受检异常**`InterruptedException`，必须使用`try-catch`块处理或在方法签名上声明抛出。
    
2. **中断的正确处理**：当线程的`interrupt()`方法被调用时，线程需要正确地响应中断。通常是在循环条件中检查中断状态，或在捕获到`InterruptedException`后执行清理工作并退出。
    
3. **优先级并非万能**：不要过度依赖线程优先级来解决线程安全问题。线程调度依赖于底层操作系统，优先级设置可能并不总是按预期工作。保证程序正确性的基础应是同步机制，而非优先级。
    

希望这份梳理能帮助你清晰地掌握Java多线程的核心方法。如果你对特定方法的用法或线程同步机制有更深入的兴趣，我们可以继续探讨。