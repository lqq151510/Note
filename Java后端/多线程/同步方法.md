在Java多线程编程中，**同步方法**​ 是通过 `synchronized`关键字修饰实例方法或静态方法，利用Java内置的锁机制来确保同一时间只有一个线程可以执行该方法，从而保障线程安全。

### 🔒 核心机制与语法

同步方法的底层依赖于 **内置锁**（Intrinsic Lock）或 **监视器锁**（Monitor Lock）。每个Java对象和类都关联着这样一把锁。

- **实例同步方法**：锁对象是**当前实例对象**（`this`）。
    
    ```
    public class Counter {
        private int count = 0;
    
        // 实例同步方法，锁是当前Counter对象(this)
        public synchronized void increment() {
            count++; // 此操作现在是线程安全的
        }
    
        public synchronized int getCount() {
            return count;
        }
    }
    ```
    
- **静态同步方法**：锁对象是**当前类的Class对象**（如 `Counter.class`）。
    
    ```
    public class MyClass {
        private static int staticCount = 0;
    
        // 静态同步方法，锁是MyClass.class
        public static synchronized void incrementStatic() {
            staticCount++;
        }
    }
    ```
    

当一个线程进入同步方法时，它会自动获取对应的锁。在此期间，其他任何线程试图进入**同一个锁对象**上的任何同步方法或同步代码块都会被阻塞，直到锁被释放。

### ⚖️ 同步方法 vs. 同步代码块

为了帮助你更清晰地做出选择，下表对比了同步方法和同步代码块的关键特性：

|特性维度|**同步方法**​|**同步代码块**​|
|---|---|---|
|**锁的粒度**​|**粗粒度**，锁定整个方法。|**细粒度**，只锁定指定的代码段。|
|**锁对象**​|实例方法默认为 `this`；静态方法默认为 `类.class`对象。|**可灵活指定**任意对象作为锁。|
|**性能影响**​|相对较大，可能阻塞整个方法的执行。|相对较小，通过缩小同步范围减少线程等待。|
|**编码复杂度**​|**简单易用**，声明方法时直接添加关键字即可。|稍复杂，需要显式指定锁对象和管理代码块范围。|
|**灵活性**​|较低。|**很高**，能实现更复杂的同步策略，如使用专用锁对象。|

### 🎯 应用场景与选择建议

- **优先考虑同步方法当**：
    
    - 整个方法体都需要被同步保护，且逻辑简单。
        
    - 追求**代码的简洁性**，快速实现基本的线程安全。
        
    
- **优先考虑同步代码块当**：
    
    - 方法中只有一小部分代码需要同步，其他部分可以并发执行，这时能**显著提升性能**。
        
    - 需要**避免使用 `this`作为锁**（例如，当对象本身可能被发布到不受控的上下文时），可以使用一个私有的、最终的专用锁对象。
        
    
    ```
    public class FineGrainedSync {
        private final Object lock = new Object(); // 专用锁对象
        private int sharedData;
    
        public void someMethod() {
            // ... 一些无需同步的操作
            synchronized (lock) { // 使用专用锁，而非this
                // 只同步访问sharedData的关键代码
                sharedData++;
            }
            // ... 其他无需同步的操作
        }
    }
    ```
    

### ⚠️ 重要注意事项

1. **性能开销**：同步操作（无论是方法还是代码块）会带来性能成本，因为涉及锁的获取和释放，可能引起线程上下文切换。应遵循**“尽量缩小同步范围”**的原则。
    
2. **死锁风险**：当多个线程互相持有对方需要的锁时，可能发生死锁。在设计时要注意**锁的获取顺序**。
    
    ```
    // 一个典型的死锁场景
    public class DeadlockExample {
        private final Object lockA = new Object();
        private final Object lockB = new Object();
    
        public void method1() {
            synchronized (lockA) { // 线程1获取lockA
                synchronized (lockB) { // 等待线程2释放lockB
                    // ...
                }
            }
        }
        public void method2() {
            synchronized (lockB) { // 线程2获取lockB
                synchronized (lockA) { // 等待线程1释放lockA -> 死锁！
                    // ...
                }
            }
        }
    }
    ```
    
3. **考虑替代方案**：对于简单的计数器等场景，`java.util.concurrent.atomic`包下的**原子类**（如 `AtomicInteger`）性能通常更高，因为它们底层使用了CAS（Compare-And-Swap）等非阻塞算法。
    

### 💎 总结

同步方法是Java中实现线程安全的基础工具，它简单直接，适用于保护整个方法访问的场景。但其粗粒度的锁特性可能成为性能瓶颈。在复杂的并发程序中，**同步代码块凭借其细粒度控制能力，往往是更优的选择**。务必根据实际代码逻辑权衡利弊，在保证安全的前提下，追求更高的并发性能。

希望这些解释能帮助你清晰地掌握同步方法。如果你对如何避免死锁或 `java.util.concurrent`包中的高级并发工具感兴趣，我们可以继续深入探讨。