守护线程是Java中一种特殊类型的线程，它在后台运行，为其他线程提供服务。它的核心特点是：**当所有非守护线程执行完毕后，JVM会慢慢退出，而不会等待守护线程完成**。这使它非常适合执行一些辅助性、支持性的后台任务。

为了让你快速抓住核心，我先用一个表格来对比守护线程和用户线程（非守护线程）的主要区别。

|特性|**守护线程**​|**用户线程（非守护线程）**​|
|---|---|---|
|**生命周期决定因素**​|依赖于所有用户线程。用户线程全部结束，则守护线程随之被JVM强制终止。|独立于其他线程。即使其他用户线程结束，只要它自己没执行完，JVM就不会退出。|
|**JVM退出行为**​|JVM**不等待**其执行完毕。|JVM**必须等待**其全部执行完毕。|
|**核心用途**​|为其他线程提供后台服务，如垃圾回收、日志记录、监控等。|执行业务逻辑核心任务。|
|**优先级影响**​|通常设置为较低优先级。|优先级根据具体任务设定。|
|**默认类型**​|新创建的线程默认是用户线程，需要手动设置为守护线程。|线程默认类型。|

### 💡 如何创建守护线程

将一个线程设置为守护线程非常简单，关键在于调用 `setDaemon(true)`方法，并且**必须在调用 `start()`方法启动线程之前进行设置**，否则会抛出 `IllegalThreadStateException`异常。

以下是两种常见的创建方式：

**1. 继承Thread类**

```
class MyDaemonThread extends Thread {
    public MyDaemonThread() {
        // 关键步骤：在构造器中或启动前设置为守护线程
        this.setDaemon(true);
    }
    @Override
    public void run() {
        // 守护线程要执行的任务
        while (true) {
            System.out.println("守护线程正在运行...");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                break;
            }
        }
    }
}

public class Example {
    public static void main(String[] args) {
        MyDaemonThread daemonThread = new MyDaemonThread();
        daemonThread.start(); // 启动守护线程

        // 主线程（用户线程）休眠3秒后结束
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("主线程结束，JVM即将退出，守护线程也会被终止。");
    }
}
```

**2. 实现Runnable接口**

```
public class DaemonExample {
    public static void main(String[] args) {
        // 1. 实现Runnable接口
        Runnable daemonTask = () -> {
            while (true) {
                System.out.println("守护线程运行中...");
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    break;
                }
            }
        };

        // 2. 创建Thread对象，并传入Runnable实例
        Thread thread = new Thread(daemonTask);
        // 3. !!!关键步骤：设置为守护线程!!!
        thread.setDaemon(true);
        // 4. 启动线程
        thread.start();

        // 主线程逻辑
        System.out.println("主线程开始工作。");
        try {
            Thread.sleep(5000); // 主线程工作5秒
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("主线程工作完成，程序结束。");
        // 此时，JVM会发现只有守护线程还在运行，于是直接退出，守护线程的循环将被中断。
    }
}
```

### 🎯 典型应用场景

守护线程通常用于那些**周期性地执行、不影响程序核心业务、并且可以在任何时候被安全终止**的任务。例如：

- **垃圾回收（GC）**：JVM自身的垃圾回收线程就是最典型的守护线程。
    
- **日志记录**：将日志信息异步写入磁盘或数据库，即使最后几条日志因JVM退出而丢失也无妨。
    
- **缓存管理**：定期清理过期的缓存数据。
    
- **心跳检测与健康检查**：向监控系统发送心跳信号，表明应用存活。
    
- **连接池维护**：定期回收空闲的连接。
    

### ⚠️ 重要注意事项

使用守护线程时，以下几点需要特别留意：

1. **不可靠的生命周期**：这是最重要的原则。**绝对不要在守护线程中执行关键业务逻辑**，比如数据库事务提交、支付回调处理等。因为这些任务可能因JVM退出而在中途被强行终止，导致数据不一致或业务故障。
    
2. **资源清理问题**：守护线程**不应持有需要关闭的资源**（如打开的文件句柄、网络连接等）。因为JVM退出时不会给守护线程执行`finally`代码块或`try-with-resources`语句的机会来释放资源，这可能导致数据丢失或资源泄漏。
    
3. **设置时机绝对要早**：`setDaemon(true)`**必须在 `start()`方法之前调用**，否则会抛出异常。
    
4. **线程继承性**：在**守护线程中创建并启动的新线程，默认也是守护线程**。如果需要，必须显式将其设置为用户线程。
    
5. **finally代码块不保证执行**：JVM退出时，守护线程的`finally`代码块中的逻辑**可能没有机会执行**。
    
6. **与线程池的关系**：通过 `ExecutorService`线程池提交任务时，默认创建的线程是用户线程。如果需要使用守护线程，通常需要自定义 `ThreadFactory`。
    

### 💎 总结

守护线程是Java多线程工具箱中一个非常有用的工具，但它是一把“双刃剑”。它的价值在于处理那些**重要但不紧急、可随时中断的后台服务**。正确使用它的关键在于深刻理解其“**随主线程消亡而消亡**”的特性，并避免让它承担关键任务。

希望这些解释能帮助你清晰地理解和使用Java中的守护线程。