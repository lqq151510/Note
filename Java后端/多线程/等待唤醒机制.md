Java中的等待唤醒机制是实现多线程间协调工作的核心方式，它允许线程在特定条件未满足时主动等待，并在条件达成时被其他线程唤醒。下面这个表格能帮你快速抓住其核心方法与关键特性。

|特性维度|**Object 的 wait()/notify()**​|**Condition 接口**​|**LockSupport 类**​|
|---|---|---|---|
|**核心方法**​|`wait()`, `notify()`, `notifyAll()`|`await()`, `signal()`, `signalAll()`|`park()`, `unpark(Thread thread)`|
|**锁依赖**​|必须与 **`synchronized`**​ 同步块配合使用|必须与 **`Lock`**​ 配合使用|**无需强制获取锁**​|
|**精度与灵活性**​|一个对象只有一个等待队列，**唤醒粒度较粗**​|一个Lock可创建**多个Condition**，实现**精确唤醒**​|以**线程**为操作对象，最灵活|
|**等待条件检查**​|经典模式：使用 **`while`循环**检查条件，防止虚假唤醒|同左，也必须使用循环检查条件|本身不管理条件，需程序员自行维护|

### 💡 理解等待唤醒机制的核心

想象一个餐厅厨房：厨师（生产者线程）做好菜后需要通知服务员（消费者线程）上菜，而服务员需要等待厨师完成。如果服务员不停地问“好了吗？”（忙等待），会浪费大量精力。等待唤醒机制则允许服务员在厨师忙碌时**主动休息（等待）**，等厨师做好菜后**直接通知（唤醒）**​ 服务员，这样效率最高。

其底层依赖于Java的**对象监视器（Monitor）**​ 机制。每个对象都有一把“锁”，以及一个“等待队列”（Wait Set）。

- 当线程调用 `obj.wait()`时，它会**释放持有的锁**，并进入该对象的等待队列中休眠。
    
- 当其他线程调用 `obj.notify()`或 `obj.notifyAll()`时，会唤醒等待队列中的线程，被唤醒的线程需要重新竞争到锁后才能继续执行。
    

### 🛠️ 三种实现方式详解

#### 1. 使用 Object 的 wait() 和 notify()

这是最经典的方式，但使用时有多处细节需要特别注意。

```
// 以一个简单的生产者-消费者模型为例
class SharedResource {
    private int data;
    private boolean isEmpty = true; // 条件判断标志

    public synchronized void produce(int newData) throws InterruptedException {
        // 必须用while循环判断条件，防止虚假唤醒
        while (!isEmpty) {
            this.wait(); // 1. 释放锁，当前线程在此等待
        }
        data = newData;
        isEmpty = false;
        this.notifyAll(); // 2. 生产完成，唤醒所有等待的消费者线程
        System.out.println("生产了: " + data);
    }

    public synchronized int consume() throws InterruptedException {
        while (isEmpty) {
            this.wait();
        }
        isEmpty = true;
        this.notifyAll(); // 消费完成，唤醒可能等待的生产者线程
        System.out.println("消费了: " + data);
        return data;
    }
}
```

**关键点**：

- **同步上下文**：所有操作都必须在 `synchronized`同步块或同步方法内进行，否则会抛出 `IllegalMonitorStateException`。
    
- **循环检查条件**：判断条件时务必使用 **`while`**​ 而不是 `if`。这是因为可能存在“**虚假唤醒**”（Spurious Wakeup），即线程在没有收到`notify`的情况下被莫名唤醒。`while`循环能保证在条件不满足时，线程再次进入等待，确保安全性。
    
- **选择 notify 还是 notifyAll**：
    
    - `notify()`随机唤醒一个等待线程，效率高，但**可能唤醒的不是当前需要的线程**，有一定风险。
        
    - `notifyAll()`唤醒所有等待线程，更安全，但会带来一些性能开销。**在不确定时，使用 `notifyAll()`通常更稳妥**。
        
    

#### 2. 使用 Lock 和 Condition（更现代、更灵活）

Java 5 引入的 `java.util.concurrent.locks`包提供了更强大的控制能力。

```
import java.util.concurrent.locks.*;

class AdvancedSharedResource {
    private int data;
    private boolean isEmpty = true;
    private final Lock lock = new ReentrantLock();
    private final Condition notEmpty = lock.newCondition(); // 条件：缓冲区非空
    private final Condition notFull = lock.newCondition();  // 条件：缓冲区非满

    public void produce(int newData) throws InterruptedException {
        lock.lock();
        try {
            while (!isEmpty) {
                notFull.await(); // 等待"非满"条件。注意：这里用的是await(), 不是wait()
            }
            data = newData;
            isEmpty = false;
            notEmpty.signal(); // 精确地唤醒一个等待"非空"条件的消费者线程
            System.out.println("生产了: " + data);
        } finally {
            lock.unlock(); // 确保锁被释放
        }
    }

    public int consume() throws InterruptedException {
        lock.lock();
        try {
            while (isEmpty) {
                notEmpty.await();
            }
            isEmpty = true;
            notFull.signal(); // 精确地唤醒一个等待"非满"条件的生产者线程
            System.out.println("消费了: " + data);
            return data;
        } finally {
            lock.unlock();
        }
    }
}
```

**优势**：

- **多条件队列**：可以为不同的等待条件创建多个`Condition`对象（如“非满”、“非空”），实现**精确唤醒**，避免了无谓的线程竞争，性能更好。
    
- **可中断的等待**：`Condition.await()`方法支持超时和中断，提供了更灵活的控制。
    

#### 3. 使用 LockSupport（最底层的控制）

`LockSupport`是一个非常灵活的工具类，它不依赖于对象的监视器锁，而是直接以**线程对象**作为操作目标。

```
import java.util.concurrent.locks.LockSupport;

public class LockSupportExample {
    private static Thread producerThread, consumerThread;

    public static void main(String[] args) {
        producerThread = new Thread(() -> {
            System.out.println("生产者线程准备停车...");
            LockSupport.park(); // 线程在此"停车"（阻塞）
            System.out.println("生产者线程被放行，继续执行！");
        });

        consumerThread = new Thread(() -> {
            try {
                Thread.sleep(2000); // 模拟消费者做一些准备工作
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("消费者线程执行完毕，发放通行证！");
            LockSupport.unpark(producerThread); // 给生产者线程发放"通行证"
        });

        producerThread.start();
        consumerThread.start();
    }
}
```

**特点**：

- **许可机制**：`unpark(thread)`会为指定线程发放一个“许可”，`park()`方法会消耗一个许可并立即返回。如果调用 `park()`时没有许可，则线程阻塞。
    
- **顺序灵活**：`unpark`可以在 `park`之前调用，这样后续的 `park`会直接消耗掉许可而不会阻塞。
    
- **应用场景**：通常用于构建更高级的同步工具（如 `AQS`，它是 `ReentrantLock`等并发类的基础），在日常业务开发中较少直接使用。
    

### ⚠️ 核心要点与常见陷阱

1. **永远在循环中检查条件**：这是防止**虚假唤醒**的关键，务必牢记。
    
2. **必须在同步块内调用**：对于 `wait()/notify()`和 `Condition`的方法，调用线程必须**已经持有了对应的锁**，否则会抛出异常。
    
3. **`wait()`和 `sleep()`的根本区别**：
    
    - `wait()`是 `Object`的方法，**会释放锁**，用于线程间协作。
        
    - `sleep()`是 `Thread`的静态方法，**不会释放锁**，只是让当前线程休眠。
        
    
4. **处理好中断异常**：`wait()`, `await()`都会抛出 `InterruptedException`，需要妥善处理，通常选择在捕获异常后重新设置中断状态 `Thread.currentThread().interrupt()`。
    

### 💎 总结

- **基础场景**：简单的线程协作，使用 **`synchronized`+ `wait()/notifyAll()`**​ 组合，代码简洁。
    
- **复杂场景**：需要高性能或精确控制（如生产者-消费者模型），优先使用 **`Lock`+ `Condition`**。
    
- **底层控制**：构建自定义同步器或需要极高灵活性时，考虑 **`LockSupport`**。
    

希望这份详细的解释能帮助你清晰地掌握Java中的等待唤醒机制。如果你对特定的使用场景或并发工具还有疑问，我们可以继续深入探讨。