线程生命周期是理解多线程编程的核心，它描述了线程从创建到销毁的完整过程。下面这张图能帮你快速把握其全貌。

```
flowchart TD
    A[新建<br>NEW] -->|调用 start()| B[可运行<br>RUNNABLE]
    B -->|获取CPU时间片| C[运行中<br>RUNNING]
    C -->|时间片用完/ yield()| B
    C -->|等待锁| D[阻塞<br>BLOCKED]
    D -->|获取锁| B
    C -->|调用 wait()/<br>join()| E[等待<br>WAITING]
    E -->|被 notify()/线程结束| B
    C -->|调用 sleep()/<br>超时wait()| F[限时等待<br>TIMED_WAITING]
    F -->|超时/被唤醒| B
    C -->|run()方法执行完毕| G[终止<br>TERMINATED]
```

下面是每个状态的详细说明。

### 🔰 新建状态

线程被 `new`关键字创建后、但尚未调用 `start()`方法时的状态。此时它只是一个普通的Java对象，还没有真正的线程特性，系统也未为其分配资源 。

### 🏃 可运行状态

调用 `start()`方法后，线程进入可运行状态。此时线程已经具备了运行条件，在等待操作系统的线程调度器为其分配CPU时间片 。需要注意的是，Java将**就绪**和**运行**两种子状态都归入 `RUNNABLE`状态 。获得CPU时间片后，线程才会开始执行 `run()`方法中的代码 。

### ⏸️ 各种等待状态

当线程需要暂时暂停执行时，会根据原因进入不同的等待状态。

|状态|触发原因|如何回到可运行状态|
|---|---|---|
|**阻塞**​|等待获取一个由其他线程持有的排它锁。|当锁被释放，系统会唤醒所有等待该锁的线程去竞争 。|
|**等待**​|调用了无超时参数的 `Object.wait()`、`Thread.join()`或 `LockSupport.park()`。|需要其他线程通过 `Object.notify()`/`notifyAll()`唤醒，或等待的线程执行完毕 。|
|**限时等待**​|调用了有超时参数的方法，如 `Thread.sleep(long)`、`Object.wait(long)`、`Thread.join(long)`。|在指定的超时时间过后，线程会自动被系统唤醒 。|

### ⚠️ 关键注意事项

理解生命周期时，下面几点非常重要：

- **`start()`与 `run()`的区别**：请务必调用 `start()`来启动新线程。如果直接调用 `run()`方法，它只会作为一个普通方法在当前线程中执行，而不会创建新的执行流 。
    
- **状态的瞬时性**：通过 `Thread.getState()`获取的状态是一个**瞬时快照**，线程状态会随着系统调度而飞速变化 。
    
- **终止状态不可逆**：线程一旦进入终止状态，生命周期就结束了，**不能再次通过 `start()`方法重启**，否则会抛出 `IllegalThreadStateException`异常 。
    

### 💎 总结与联系

线程生命周期与多线程编程的多个核心概念紧密相连。**同步机制**可能导致线程进入`BLOCKED`状态；使用`Object.wait()/notify()`会引发`WAITING`状态的转换；而**线程池**中的线程则会在`RUNNABLE`、`WAITING`等状态间高效切换复用 。理解这些状态流转是诊断死锁、优化性能的基础。

希望这份图解和说明能帮助你清晰地掌握线程的生命周期。如果对特定的状态转换或应用场景有更深入的兴趣，我们可以继续探讨。