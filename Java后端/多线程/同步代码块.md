同步代码块是 Java 中解决多线程并发问题的重要工具，它通过 `synchronized`关键字锁定特定代码段，确保同一时刻只有一个线程能执行该段代码，从而保障线程安全。

### 🔒 理解同步代码块的核心

想象一下多个线程同时修改同一个变量，如果没有协调机制，结果将难以预测。同步代码块就像给一段关键代码加了一把锁，线程进入前必须先获得这把锁，离开时则释放锁，其他线程才能获取锁并执行。其基本语法如下：

```
synchronized (lockObject) {
    // 需要同步执行的代码
}
```

其中，`lockObject`就是作为锁的对象，多个线程必须使用**同一个**锁对象才能实现真正的同步。

### ⚖️ 选择锁对象

选择不同的锁对象，会直接影响同步的范围和效果。

| 锁对象类型       | 示例                                                                             | 同步范围                                          | 适用场景                                 |
| ----------- | ------------------------------------------------------------------------------ | --------------------------------------------- | ------------------------------------ |
| **当前实例对象**​ | `synchronized (this) { ... }`                                                  | 锁定当前对象实例。多个线程操作**同一个**实例时，其同步代码块互斥。           | 需要控制对==**单个对象实例**==内部状态的并发访问。        |
| **自定义锁对象**​ | `private final Object lock = new Object();`  <br>`synchronized (lock) { ... }` | 锁定自定义对象。灵活性高，可精确控制同步粒度，避免与对象本身内置锁混淆。          | 需要更细粒度的锁控制，或明确指定锁对象。                 |
| **类对象**​    | `synchronized (MyClass.class) { ... }`                                         | 锁定类的 Class 对象。对类的**所有实例**都生效，即所有实例的对应同步代码块互斥。 | 需要同步**静态数据**，或在非单例模式下控制所有实例对某些操作的访问。 |

### 🛠️ 基本使用示例

以下是一个使用同步代码块保证线程安全的计数器示例：

```
public class SafeCounter {
    private int count = 0;
    private final Object lock = new Object(); // 自定义锁对象

    public void increment() {
        // 使用synchronized代码块保证count++的原子性
        synchronized (lock) {
            count++;
        }
    }

    public int getCount() {
        // 读取操作也需要同步，确保能读到最新值
        synchronized (lock) {
            return count;
        }
    }
}
```

在这个例子中，`increment`和 `getCount`方法中的同步代码块都使用同一个 `lock`对象作为锁，确保了 `count`变量修改和读取的可见性与原子性。

### 💡 重要实践建议

1. **保持同步范围最小化**
    
    只同步真正存在线程安全问题的代码，这能减少线程等待时间，提升程序性能。避免在同步代码块中执行耗时操作（如IO操作、复杂计算）。
    
2. **警惕死锁**
    
    死锁指两个或多个线程互相持有对方需要的锁，导致所有线程都无法继续执行。典型场景是嵌套同步块且锁的获取顺序不一致。
    
    ```
    // 错误示范：可能引发死锁的代码结构
    public void transfer(Account from, Account to, int amount) {
        synchronized (from) {
            synchronized (to) { // 如果另一个线程以相反顺序锁定to和from，就可能死锁
                // ... 转账操作
            }
        }
    }
    ```
    
    预防死锁的有效方法之一是**强制规定锁的获取顺序**，例如按照对象的哈希值排序。
    
3. **了解替代方案**
    
    虽然 `synchronized`简单易用，但在需要更高级功能（如可定时等待、可中断等待、公平锁等）时，可以考虑 `java.util.concurrent.locks`包中的 `ReentrantLock`。对于简单的原子操作，`java.util.concurrent.atomic`包下的原子类（如 `AtomicInteger`）性能通常更高。
    

### 💎 核心要点

同步代码块通过精确控制同步范围，在保证线程安全的同时，能有效提升性能。理解并正确选择**锁对象**是发挥其作用的关键。

希望这些解释和示例能帮助你清晰地掌握同步代码块。如果你对特定场景下的应用或与其他同步机制的对比有更深入的兴趣，我们可以继续探讨。