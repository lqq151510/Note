# Java算法：插入排序

## 定义

**插入排序**（Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

### 算法原理

1. 从第一个元素开始，该元素可以认为已经被排序
    
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
    
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
    
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
    
5. 将新元素插入到该位置后
    
6. 重复步骤2-5，直到所有元素都被处理
    

### 特点

|特性|描述|
|---|---|
|**时间复杂度**​|最好O(n)，平均O(n²)，最坏O(n²)|
|**空间复杂度**​|O(1)|
|**稳定性**​|稳定排序算法|
|**原地排序**​|是|
|**自适应**​|是（对部分有序数组效率高）|

## 算法可视化

```
初始数组: [5, 2, 4, 6, 1, 3]

第1轮：处理元素2
[5, 2, 4, 6, 1, 3] → 2<5，5后移 → [5, 5, 4, 6, 1, 3] → 插入2 → [2, 5, 4, 6, 1, 3]

第2轮：处理元素4
[2, 5, 4, 6, 1, 3] → 4<5，5后移 → [2, 5, 5, 6, 1, 3] → 4>2，插入4 → [2, 4, 5, 6, 1, 3]

第3轮：处理元素6
[2, 4, 5, 6, 1, 3] → 6>5，位置正确 → [2, 4, 5, 6, 1, 3]

第4轮：处理元素1
[2, 4, 5, 6, 1, 3] → 1<6，6后移 → [2, 4, 5, 6, 6, 3]
→ 1<5，5后移 → [2, 4, 5, 5, 6, 3]
→ 1<4，4后移 → [2, 4, 4, 5, 6, 3]
→ 1<2，2后移 → [2, 2, 4, 5, 6, 3]
→ 插入1 → [1, 2, 4, 5, 6, 3]

第5轮：处理元素3
[1, 2, 4, 5, 6, 3] → 3<6，6后移 → [1, 2, 4, 5, 6, 6]
→ 3<5，5后移 → [1, 2, 4, 5, 5, 6]
→ 3<4，4后移 → [1, 2, 4, 4, 5, 6]
→ 3>2，插入3 → [1, 2, 3, 4, 5, 6]

最终数组: [1, 2, 3, 4, 5, 6]
```

## Java实现示例

### 1. 基础插入排序

```
import java.util.Arrays;

public class InsertionSort {
    
    /**
     * 基础插入排序
     * @param arr 待排序数组
     */
    public static void insertionSortBasic(int[] arr) {
        int n = arr.length;
        
        // 从第二个元素开始（第一个元素默认已排序）
        for (int i = 1; i < n; i++) {
            System.out.println("第 " + i + " 轮: 处理元素 arr[" + i + "] = " + arr[i]);
            System.out.println("  当前已排序部分: " + Arrays.toString(Arrays.copyOfRange(arr, 0, i)));
            
            int key = arr[i];  // 当前要插入的元素
            int j = i - 1;     // 已排序部分的最后一个元素索引
            
            // 从后向前扫描，找到合适的插入位置
            while (j >= 0 && arr[j] > key) {
                System.out.println("    将 arr[" + j + "] = " + arr[j] + " 后移到 arr[" + (j + 1) + "]");
                arr[j + 1] = arr[j];  // 元素后移
                j--;  // 继续向前比较
            }
            
            // 插入元素到正确位置
            arr[j + 1] = key;
            System.out.println("  插入 " + key + " 到位置 " + (j + 1));
            System.out.println("  当前数组: " + Arrays.toString(arr));
            System.out.println();
        }
    }
    
    /**
     * 插入排序（降序）
     */
    public static void insertionSortDescending(int[] arr) {
        int n = arr.length;
        
        for (int i = 1; i < n; i++) {
            int key = arr[i];
            int j = i - 1;
            
            // 与升序排序相反，当前元素比已排序元素大时才后移
            while (j >= 0 && arr[j] < key) {
                arr[j + 1] = arr[j];
                j--;
            }
            
            arr[j + 1] = key;
        }
    }
    
    /**
     * 插入排序（使用for循环）
     */
    public static void insertionSortForLoop(int[] arr) {
        int n = arr.length;
        
        for (int i = 1; i < n; i++) {
            int key = arr[i];
            
            // 将key插入到已排序的arr[0..i-1]中
            for (int j = i - 1; j >= 0 && arr[j] > key; j--) {
                arr[j + 1] = arr[j];  // 后移元素
                arr[j] = key;         // 临时插入
            }
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {5, 2, 4, 6, 1, 3};
        
        System.out.println("=== 基础插入排序演示（升序）===");
        System.out.println("原始数组: " + Arrays.toString(arr));
        System.out.println();
        
        int[] arrCopy = arr.clone();
        insertionSortBasic(arrCopy);
        
        System.out.println("排序结果: " + Arrays.toString(arrCopy));
        
        // 测试降序排序
        System.out.println("\n=== 插入排序演示（降序）===");
        int[] arr2 = {5, 2, 8, 1, 9, 3};
        System.out.println("原始数组: " + Arrays.toString(arr2));
        
        int[] arr2Copy = arr2.clone();
        insertionSortDescending(arr2Copy);
        System.out.println("排序结果: " + Arrays.toString(arr2Copy));
    }
}
```

### 2. 带统计信息的插入排序

```
import java.util.Arrays;

public class InsertionSortWithStats {
    
    /**
     * 带统计信息的插入排序
     */
    public static class SortStats {
        int comparisons;  // 比较次数
        int shifts;       // 后移次数
        int insertions;   // 插入次数
        long time;        // 耗时（纳秒）
        
        @Override
        public String toString() {
            return String.format("比较次数: %d, 后移次数: %d, 插入次数: %d, 耗时: %d ns", 
                                comparisons, shifts, insertions, time);
        }
    }
    
    /**
     * 插入排序（带统计）
     */
    public static SortStats insertionSortWithStats(int[] arr) {
        int[] arrCopy = arr.clone();
        int n = arrCopy.length;
        SortStats stats = new SortStats();
        
        long startTime = System.nanoTime();
        
        for (int i = 1; i < n; i++) {
            int key = arrCopy[i];
            int j = i - 1;
            
            // 比较并后移
            while (j >= 0 && arrCopy[j] > key) {
                stats.comparisons++;
                stats.shifts++;
                arrCopy[j + 1] = arrCopy[j];
                j--;
            }
            
            // 最后一次比较（当j<0或arr[j]<=key时退出循环）
            if (j >= 0) {
                stats.comparisons++;
            }
            
            // 插入
            stats.insertions++;
            arrCopy[j + 1] = key;
        }
        
        long endTime = System.nanoTime();
        stats.time = endTime - startTime;
        
        return stats;
    }
    
    /**
     * 优化插入排序：使用二分查找来找到插入位置
     */
    public static SortStats binaryInsertionSort(int[] arr) {
        int[] arrCopy = arr.clone();
        int n = arrCopy.length;
        SortStats stats = new SortStats();
        
        long startTime = System.nanoTime();
        
        for (int i = 1; i < n; i++) {
            int key = arrCopy[i];
            
            // 使用二分查找找到插入位置
            int left = 0;
            int right = i;
            
            while (left < right) {
                int mid = left + (right - left) / 2;
                stats.comparisons++;
                
                if (key < arrCopy[mid]) {
                    right = mid;
                } else {
                    left = mid + 1;
                }
            }
            
            // 从插入位置开始，将元素后移
            for (int j = i; j > left; j--) {
                stats.shifts++;
                arrCopy[j] = arrCopy[j - 1];
            }
            
            // 插入元素
            stats.insertions++;
            arrCopy[left] = key;
        }
        
        long endTime = System.nanoTime();
        stats.time = endTime - startTime;
        
        return stats;
    }
    
    /**
     * 希尔排序（插入排序的改进）
     */
    public static SortStats shellSort(int[] arr) {
        int[] arrCopy = arr.clone();
        int n = arrCopy.length;
        SortStats stats = new SortStats();
        
        long startTime = System.nanoTime();
        
        // 使用Knuth序列的增量
        int gap = 1;
        while (gap < n / 3) {
            gap = 3 * gap + 1;  // 1, 4, 13, 40, 121, ...
        }
        
        while (gap > 0) {
            // 对每个子序列进行插入排序
            for (int i = gap; i < n; i++) {
                int key = arrCopy[i];
                int j = i;
                
                while (j >= gap && arrCopy[j - gap] > key) {
                    stats.comparisons++;
                    stats.shifts++;
                    arrCopy[j] = arrCopy[j - gap];
                    j -= gap;
                }
                
                if (j >= gap) {
                    stats.comparisons++;
                }
                
                stats.insertions++;
                arrCopy[j] = key;
            }
            
            gap /= 3;  // 减小间隔
        }
        
        long endTime = System.nanoTime();
        stats.time = endTime - startTime;
        
        return stats;
    }
    
    /**
     * 可视化插入排序过程
     */
    public static void visualizeInsertionSort(int[] arr) {
        int[] arrCopy = arr.clone();
        int n = arrCopy.length;
        
        System.out.println("=== 插入排序可视化 ===");
        System.out.println("原始数组: " + Arrays.toString(arrCopy));
        System.out.println();
        
        for (int i = 1; i < n; i++) {
            System.out.println("第 " + i + " 轮: 处理元素 arr[" + i + "] = " + arrCopy[i]);
            
            // 显示当前数组状态
            System.out.print("  当前: [");
            for (int k = 0; k < n; k++) {
                if (k < i) {
                    System.out.print("(" + arrCopy[k] + ") ");  // 已排序部分
                } else if (k == i) {
                    System.out.print("[" + arrCopy[k] + "] ");  // 当前处理元素
                } else {
                    System.out.print(arrCopy[k] + " ");  // 未处理部分
                }
            }
            System.out.println("]");
            
            int key = arrCopy[i];
            int j = i - 1;
            int shiftCount = 0;
            
            // 从后向前扫描，找到插入位置
            while (j >= 0 && arrCopy[j] > key) {
                arrCopy[j + 1] = arrCopy[j];
                shiftCount++;
                j--;
            }
            
            if (shiftCount > 0) {
                System.out.println("  后移了 " + shiftCount + " 个元素");
            } else {
                System.out.println("  元素已在正确位置，无需后移");
            }
            
            // 插入元素
            arrCopy[j + 1] = key;
            System.out.println("  插入 " + key + " 到位置 " + (j + 1));
            System.out.println("  当前数组: " + Arrays.toString(arrCopy));
            System.out.println();
        }
        
        System.out.println("最终排序结果: " + Arrays.toString(arrCopy));
    }
    
    public static void main(String[] args) {
        int[] arr = {5, 2, 4, 6, 1, 3};
        
        // 可视化演示
        visualizeInsertionSort(arr);
        
        System.out.println("\n" + "=".repeat(50) + "\n");
        
        // 测试不同版本的插入排序
        int[] testArray = {29, 10, 14, 37, 13, 25, 8};
        System.out.println("测试数组: " + Arrays.toString(testArray));
        
        System.out.println("\n1. 基础插入排序统计:");
        SortStats basicStats = insertionSortWithStats(testArray);
        System.out.println(basicStats);
        
        System.out.println("\n2. 二分插入排序统计:");
        SortStats binaryStats = binaryInsertionSort(testArray);
        System.out.println(binaryStats);
        
        System.out.println("\n3. 希尔排序统计:");
        SortStats shellStats = shellSort(testArray);
        System.out.println(shellStats);
        
        // 性能比较
        System.out.println("\n性能比较:");
        System.out.println("基础插入排序比较次数: " + basicStats.comparisons);
        System.out.println("二分插入排序比较次数: " + binaryStats.comparisons);
        System.out.println("比较次数减少: " + (basicStats.comparisons - binaryStats.comparisons));
    }
}
```

### 3. 泛型插入排序

```
import java.util.Arrays;
import java.util.Comparator;

public class GenericInsertionSort {
    
    /**
     * 泛型插入排序（升序，使用Comparable接口）
     */
    public static <T extends Comparable<T>> void insertionSortGeneric(T[] arr) {
        int n = arr.length;
        
        for (int i = 1; i < n; i++) {
            T key = arr[i];
            int j = i - 1;
            
            // 从后向前扫描，找到合适的插入位置
            while (j >= 0 && arr[j].compareTo(key) > 0) {
                arr[j + 1] = arr[j];
                j--;
            }
            
            arr[j + 1] = key;
        }
    }
    
    /**
     * 泛型插入排序（使用Comparator比较器）
     */
    public static <T> void insertionSortGeneric(T[] arr, Comparator<T> comparator) {
        int n = arr.length;
        
        for (int i = 1; i < n; i++) {
            T key = arr[i];
            int j = i - 1;
            
            while (j >= 0 && comparator.compare(arr[j], key) > 0) {
                arr[j + 1] = arr[j];
                j--;
            }
            
            arr[j + 1] = key;
        }
    }
    
    /**
     * 泛型插入排序（返回排序后的新数组，不修改原数组）
     */
    public static <T extends Comparable<T>> T[] insertionSortImmutable(T[] arr) {
        T[] result = Arrays.copyOf(arr, arr.length);
        insertionSortGeneric(result);
        return result;
    }
    
    /**
     * 学生类，用于演示
     */
    static class Student implements Comparable<Student> {
        String name;
        int score;
        int age;
        
        Student(String name, int score, int age) {
            this.name = name;
            this.score = score;
            this.age = age;
        }
        
        @Override
        public int compareTo(Student other) {
            return Integer.compare(this.score, other.score);
        }
        
        @Override
        public String toString() {
            return String.format("%s(分数:%d, 年龄:%d)", name, score, age);
        }
    }
    
    /**
     * 产品类
     */
    static class Product {
        String name;
        double price;
        int stock;
        
        Product(String name, double price, int stock) {
            this.name = name;
            this.price = price;
            this.stock = stock;
        }
        
        @Override
        public String toString() {
            return String.format("%s($%.2f, 库存:%d)", name, price, stock);
        }
    }
    
    /**
     * 泛型二分插入排序
     */
    public static <T extends Comparable<T>> void binaryInsertionSortGeneric(T[] arr) {
        int n = arr.length;
        
        for (int i = 1; i < n; i++) {
            T key = arr[i];
            
            // 使用二分查找找到插入位置
            int left = 0;
            int right = i;
            
            while (left < right) {
                int mid = left + (right - left) / 2;
                if (key.compareTo(arr[mid]) < 0) {
                    right = mid;
                } else {
                    left = mid + 1;
                }
            }
            
            // 从插入位置开始，将元素后移
            for (int j = i; j > left; j--) {
                arr[j] = arr[j - 1];
            }
            
            // 插入元素
            arr[left] = key;
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== 泛型插入排序演示 ===");
        
        // 测试1: 整数数组
        System.out.println("\n1. 排序整数数组:");
        Integer[] intArray = {5, 2, 8, 1, 9, 3};
        System.out.println("排序前: " + Arrays.toString(intArray));
        
        insertionSortGeneric(intArray);
        System.out.println("排序后: " + Arrays.toString(intArray));
        
        // 测试2: 字符串数组
        System.out.println("\n2. 排序字符串数组:");
        String[] strArray = {"banana", "apple", "orange", "grape", "cherry"};
        System.out.println("排序前: " + Arrays.toString(strArray));
        
        insertionSortGeneric(strArray);
        System.out.println("排序后: " + Arrays.toString(strArray));
        
        // 测试3: 自定义对象数组（使用Comparable接口）
        System.out.println("\n3. 排序学生对象（按分数）:");
        Student[] students = {
            new Student("Alice", 85, 20),
            new Student("Bob", 92, 19),
            new Student("Charlie", 78, 21),
            new Student("David", 90, 20)
        };
        
        System.out.println("排序前: " + Arrays.toString(students));
        insertionSortGeneric(students);
        System.out.println("排序后: " + Arrays.toString(students));
        
        // 测试4: 使用自定义比较器
        System.out.println("\n4. 使用自定义比较器排序学生（按年龄）:");
        Student[] students2 = students.clone();
        Comparator<Student> ageComparator = Comparator.comparing(s -> s.age);
        
        System.out.println("排序前: " + Arrays.toString(students2));
        insertionSortGeneric(students2, ageComparator);
        System.out.println("排序后: " + Arrays.toString(students2));
        
        // 测试5: 多级排序（先按年龄，再按分数）
        System.out.println("\n5. 多级排序（先按年龄，再按分数）:");
        Student[] students3 = {
            new Student("Alice", 85, 20),
            new Student("Bob", 92, 20),
            new Student("Charlie", 78, 19),
            new Student("David", 90, 20)
        };
        
        Comparator<Student> multiComparator = Comparator
            .comparing((Student s) -> s.age)
            .thenComparing(s -> s.score);
        
        System.out.println("排序前: " + Arrays.toString(students3));
        insertionSortGeneric(students3, multiComparator);
        System.out.println("排序后: " + Arrays.toString(students3));
        
        // 测试6: 二分插入排序
        System.out.println("\n6. 二分插入排序:");
        Integer[] intArray2 = {5, 2, 8, 1, 9, 3};
        System.out.println("排序前: " + Arrays.toString(intArray2));
        
        binaryInsertionSortGeneric(intArray2);
        System.out.println("排序后: " + Arrays.toString(intArray2));
        
        // 测试7: 不可变排序
        System.out.println("\n7. 不可变排序（不修改原数组）:");
        Integer[] intArray3 = {5, 2, 8, 1, 9, 3};
        System.out.println("原数组: " + Arrays.toString(intArray3));
        
        Integer[] sortedArray = insertionSortImmutable(intArray3);
        System.out.println("新排序数组: " + Arrays.toString(sortedArray));
        System.out.println("原数组保持不变: " + Arrays.toString(intArray3));
    }
}
```

### 4. 插入排序性能分析

```
import java.util.Arrays;
import java.util.Random;

public class InsertionSortPerformance {
    
    /**
     * 生成随机数组
     */
    public static int[] generateRandomArray(int size, int maxValue) {
        int[] arr = new int[size];
        Random random = new Random();
        
        for (int i = 0; i < size; i++) {
            arr[i] = random.nextInt(maxValue);
        }
        
        return arr;
    }
    
    /**
     * 生成几乎有序的数组
     */
    public static int[] generateNearlySortedArray(int size) {
        int[] arr = new int[size];
        
        for (int i = 0; i < size; i++) {
            arr[i] = i;
        }
        
        // 随机交换几对元素
        Random random = new Random();
        int swaps = size / 10;  // 交换10%的元素
        
        for (int i = 0; i < swaps; i++) {
            int index1 = random.nextInt(size);
            int index2 = random.nextInt(size);
            
            int temp = arr[index1];
            arr[index1] = arr[index2];
            arr[index2] = temp;
        }
        
        return arr;
    }
    
    /**
     * 生成完全逆序数组
     */
    public static int[] generateReverseArray(int size) {
        int[] arr = new int[size];
        
        for (int i = 0; i < size; i++) {
            arr[i] = size - i;
        }
        
        return arr;
    }
    
    /**
     * 生成相同元素数组
     */
    public static int[] generateSameArray(int size, int value) {
        int[] arr = new int[size];
        Arrays.fill(arr, value);
        return arr;
    }
    
    /**
     * 性能测试
     */
    public static void performanceTest() {
        System.out.println("=== 插入排序性能测试 ===");
        System.out.println("数组大小: 1000");
        
        // 测试不同情况的数组
        String[] testCases = {"随机数组", "几乎有序数组", "完全逆序数组", "相同元素数组"};
        int[][] testArrays = new int[4][1000];
        
        testArrays[0] = generateRandomArray(1000, 10000);
        testArrays[1] = generateNearlySortedArray(1000);
        testArrays[2] = generateReverseArray(1000);
        testArrays[3] = generateSameArray(1000, 5);
        
        System.out.printf("%-20s %-15s %-15s %-15s%n", 
                         "测试用例", "比较次数", "后移次数", "耗时(ms)");
        System.out.println("-".repeat(65));
        
        for (int i = 0; i < 4; i++) {
            int[] arrCopy = testArrays[i].clone();
            
            long startTime = System.nanoTime();
            
            int comparisons = 0;
            int shifts = 0;
            int n = arrCopy.length;
            
            for (int j = 1; j < n; j++) {
                int key = arrCopy[j];
                int k = j - 1;
                
                while (k >= 0 && arrCopy[k] > key) {
                    comparisons++;
                    shifts++;
                    arrCopy[k + 1] = arrCopy[k];
                    k--;
                }
                
                if (k >= 0) {
                    comparisons++;  // 最后一次比较
                }
                
                arrCopy[k + 1] = key;
            }
            
            long endTime = System.nanoTime();
            long duration = (endTime - startTime) / 1_000_000;  // 转换为毫秒
            
            System.out.printf("%-20s %-15d %-15d %-15d%n", 
                             testCases[i], comparisons, shifts, duration);
        }
    }
    
    /**
     * 与冒泡排序、选择排序性能比较
     */
    public static void compareWithOtherSorts() {
        System.out.println("\n=== 插入排序 vs 冒泡排序 vs 选择排序 ===");
        System.out.println("数组大小: 1000");
        
        int[] randomArray = generateRandomArray(1000, 10000);
        
        // 插入排序
        long startTime = System.nanoTime();
        int[] insertionSorted = insertionSort(randomArray.clone());
        long insertionTime = System.nanoTime() - startTime;
        
        // 冒泡排序
        startTime = System.nanoTime();
        int[] bubbleSorted = bubbleSort(randomArray.clone());
        long bubbleTime = System.nanoTime() - startTime;
        
        // 选择排序
        startTime = System.nanoTime();
        int[] selectionSorted = selectionSort(randomArray.clone());
        long selectionTime = System.nanoTime() - startTime;
        
        // 验证排序结果是否相同
        boolean insertionBubbleEqual = Arrays.equals(insertionSorted, bubbleSorted);
        boolean bubbleSelectionEqual = Arrays.equals(bubbleSorted, selectionSorted);
        
        System.out.println("插入排序用时: " + insertionTime / 1_000_000 + " ms");
        System.out.println("冒泡排序用时: " + bubbleTime / 1_000_000 + " ms");
        System.out.println("选择排序用时: " + selectionTime / 1_000_000 + " ms");
        System.out.println("排序结果相同: " + (insertionBubbleEqual && bubbleSelectionEqual));
        
        // 找出最快的排序算法
        long minTime = Math.min(Math.min(insertionTime, bubbleTime), selectionTime);
        String fastest = "";
        
        if (minTime == insertionTime) fastest = "插入排序";
        else if (minTime == bubbleTime) fastest = "冒泡排序";
        else fastest = "选择排序";
        
        System.out.println("最快的排序算法: " + fastest);
    }
    
    /**
     * 插入排序实现
     */
    public static int[] insertionSort(int[] arr) {
        int[] arrCopy = arr.clone();
        int n = arrCopy.length;
        
        for (int i = 1; i < n; i++) {
            int key = arrCopy[i];
            int j = i - 1;
            
            while (j >= 0 && arrCopy[j] > key) {
                arrCopy[j + 1] = arrCopy[j];
                j--;
            }
            
            arrCopy[j + 1] = key;
        }
        
        return arrCopy;
    }
    
    /**
     * 冒泡排序实现
     */
    public static int[] bubbleSort(int[] arr) {
        int[] arrCopy = arr.clone();
        int n = arrCopy.length;
        boolean swapped;
        
        for (int i = 0; i < n - 1; i++) {
            swapped = false;
            
            for (int j = 0; j < n - 1 - i; j++) {
                if (arrCopy[j] > arrCopy[j + 1]) {
                    int temp = arrCopy[j];
                    arrCopy[j] = arrCopy[j + 1];
                    arrCopy[j + 1] = temp;
                    swapped = true;
                }
            }
            
            if (!swapped) {
                break;
            }
        }
        
        return arrCopy;
    }
    
    /**
     * 选择排序实现
     */
    public static int[] selectionSort(int[] arr) {
        int[] arrCopy = arr.clone();
        int n = arrCopy.length;
        
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            
            for (int j = i + 1; j < n; j++) {
                if (arrCopy[j] < arrCopy[minIndex]) {
                    minIndex = j;
                }
            }
            
            if (minIndex != i) {
                int temp = arrCopy[i];
                arrCopy[i] = arrCopy[minIndex];
                arrCopy[minIndex] = temp;
            }
        }
        
        return arrCopy;
    }
    
    /**
     * 不同数组大小的性能测试
     */
    public static void testDifferentSizes() {
        System.out.println("\n=== 不同数组大小的性能测试（插入排序）===");
        
        int[] sizes = {100, 500, 1000, 5000, 10000, 20000};
        
        System.out.printf("%-10s %-20s %-20s%n", "数组大小", "随机数组(ms)", "几乎有序数组(ms)");
        System.out.println("-".repeat(50));
        
        for (int size : sizes) {
            if (size <= 20000) {  // 避免过大数组导致长时间等待
                int[] randomArr = generateRandomArray(size, 10000);
                int[] nearlySortedArr = generateNearlySortedArray(size);
                
                // 测试随机数组
                long startTime = System.nanoTime();
                insertionSort(randomArr.clone());
                long randomTime = (System.nanoTime() - startTime) / 1_000_000;
                
                // 测试几乎有序数组
                startTime = System.nanoTime();
                insertionSort(nearlySortedArr.clone());
                long nearlySortedTime = (System.nanoTime() - startTime) / 1_000_000;
                
                System.out.printf("%-10d %-20d %-20d%n", size, randomTime, nearlySortedTime);
            }
        }
    }
    
    /**
     * 二分插入排序性能测试
     */
    public static void testBinaryInsertionSort() {
        System.out.println("\n=== 二分插入排序 vs 普通插入排序 ===");
        
        int[] sizes = {100, 500, 1000, 5000};
        
        System.out.printf("%-10s %-20s %-20s%n", "数组大小", "普通插入排序(ms)", "二分插入排序(ms)");
        System.out.println("-".repeat(50));
        
        for (int size : sizes) {
            int[] arr = generateRandomArray(size, 10000);
            
            // 普通插入排序
            long startTime = System.nanoTime();
            insertionSort(arr.clone());
            long normalTime = (System.nanoTime() - startTime) / 1_000_000;
            
            // 二分插入排序
            startTime = System.nanoTime();
            binaryInsertionSort(arr.clone());
            long binaryTime = (System.nanoTime() - startTime) / 1_000_000;
            
            System.out.printf("%-10d %-20d %-20d%n", size, normalTime, binaryTime);
        }
    }
    
    /**
     * 二分插入排序实现
     */
    public static int[] binaryInsertionSort(int[] arr) {
        int[] arrCopy = arr.clone();
        int n = arrCopy.length;
        
        for (int i = 1; i < n; i++) {
            int key = arrCopy[i];
            
            // 使用二分查找找到插入位置
            int left = 0;
            int right = i;
            
            while (left < right) {
                int mid = left + (right - left) / 2;
                if (key < arrCopy[mid]) {
                    right = mid;
                } else {
                    left = mid + 1;
                }
            }
            
            // 从插入位置开始，将元素后移
            for (int j = i; j > left; j--) {
                arrCopy[j] = arrCopy[j - 1];
            }
            
            // 插入元素
            arrCopy[left] = key;
        }
        
        return arrCopy;
    }
    
    public static void main(String[] args) {
        // 性能测试
        performanceTest();
        
        // 与其他排序算法比较
        compareWithOtherSorts();
        
        // 不同大小测试
        testDifferentSizes();
        
        // 二分插入排序测试
        testBinaryInsertionSort();
    }
}
```

### 5. 插入排序的变体

```
import java.util.Arrays;

public class InsertionSortVariants {
    
    /**
     * 递归插入排序
     */
    public static void recursiveInsertionSort(int[] arr) {
        recursiveInsertionSort(arr, arr.length);
    }
    
    private static void recursiveInsertionSort(int[] arr, int n) {
        if (n <= 1) {
            return;
        }
        
        // 先对前n-1个元素排序
        recursiveInsertionSort(arr, n - 1);
        
        // 将第n个元素插入到已排序的前n-1个元素中
        int key = arr[n - 1];
        int j = n - 2;
        
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        
        arr[j + 1] = key;
    }
    
    /**
     * 带哨兵的插入排序
     * 在数组开头添加一个哨兵元素，减少边界检查
     */
    public static int[] insertionSortWithSentinel(int[] arr) {
        if (arr == null || arr.length == 0) {
            return new int[0];
        }
        
        // 找到最小值作为哨兵
        int minIndex = 0;
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] < arr[minIndex]) {
                minIndex = i;
            }
        }
        
        // 将最小值交换到数组开头
        if (minIndex != 0) {
            int temp = arr[0];
            arr[0] = arr[minIndex];
            arr[minIndex] = temp;
        }
        
        // 从第二个元素开始插入排序
        for (int i = 2; i < arr.length; i++) {
            int key = arr[i];
            int j = i - 1;
            
            // 不需要检查j>=0，因为arr[0]是哨兵，肯定比key小
            while (arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            
            arr[j + 1] = key;
        }
        
        return arr;
    }
    
    /**
     * 链表插入排序
     */
    static class ListNode {
        int val;
        ListNode next;
        
        ListNode(int val) {
            this.val = val;
            this.next = null;
        }
        
        static ListNode fromArray(int[] arr) {
            if (arr == null || arr.length == 0) {
                return null;
            }
            
            ListNode head = new ListNode(arr[0]);
            ListNode current = head;
            
            for (int i = 1; i < arr.length; i++) {
                current.next = new ListNode(arr[i]);
                current = current.next;
            }
            
            return head;
        }
        
        static int[] toArray(ListNode head) {
            int size = 0;
            ListNode current = head;
            while (current != null) {
                size++;
                current = current.next;
            }
            
            int[] arr = new int[size];
            current = head;
            for (int i = 0; i < size; i++) {
                arr[i] = current.val;
                current = current.next;
            }
            
            return arr;
        }
    }
    
    public static ListNode insertionSortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        
        // 创建哑节点作为已排序链表的头
        ListNode dummy = new ListNode(0);
        ListNode current = head;
        
        while (current != null) {
            ListNode next = current.next;  // 保存下一个节点
            ListNode prev = dummy;  // 从头开始找插入位置
            
            // 在已排序链表中找到插入位置
            while (prev.next != null && prev.next.val < current.val) {
                prev = prev.next;
            }
            
            // 插入节点
            current.next = prev.next;
            prev.next = current;
            
            // 移动到下一个节点
            current = next;
        }
        
        return dummy.next;
    }
    
    /**
     * 对子数组进行插入排序
     */
    public static void insertionSortSubarray(int[] arr, int left, int right) {
        for (int i = left + 1; i <= right; i++) {
            int key = arr[i];
            int j = i - 1;
            
            while (j >= left && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            
            arr[j + 1] = key;
        }
    }
    
    /**
     * 自适应插入排序：当数组几乎有序时效率更高
     */
    public static void adaptiveInsertionSort(int[] arr) {
        int n = arr.length;
        
        for (int i = 1; i < n; i++) {
            int key = arr[i];
            
            // 如果key比前一个元素大，已经在正确位置
            if (key >= arr[i - 1]) {
                continue;
            }
            
            int j = i - 1;
            
            // 只移动比key大的元素
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            
            arr[j + 1] = key;
        }
    }
    
    /**
     * 稳定插入排序（针对有重复元素的数组）
     */
    public static void stableInsertionSort(int[] arr) {
        int n = arr.length;
        
        for (int i = 1; i < n; i++) {
            int key = arr[i];
            int j = i - 1;
            
            // 只有当严格大于时才后移，保持相等元素的相对顺序
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            
            arr[j + 1] = key;
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== 插入排序变体演示 ===");
        
        // 测试递归插入排序
        System.out.println("\n1. 递归插入排序:");
        int[] arr1 = {5, 2, 4, 6, 1, 3};
        System.out.println("原始数组: " + Arrays.toString(arr1));
        
        int[] arr1Copy = arr1.clone();
        recursiveInsertionSort(arr1Copy);
        System.out.println("排序后: " + Arrays.toString(arr1Copy));
        
        // 测试带哨兵的插入排序
        System.out.println("\n2. 带哨兵的插入排序:");
        int[] arr2 = {5, 2, 4, 6, 1, 3};
        System.out.println("原始数组: " + Arrays.toString(arr2));
        
        int[] arr2Copy = arr2.clone();
        insertionSortWithSentinel(arr2Copy);
        System.out.println("排序后: " + Arrays.toString(arr2Copy));
        
        // 测试链表插入排序
        System.out.println("\n3. 链表插入排序:");
        int[] arr3 = {4, 2, 1, 3, 5};
        System.out.println("原始数组: " + Arrays.toString(arr3));
        
        ListNode list = ListNode.fromArray(arr3);
        ListNode sortedList = insertionSortList(list);
        int[] sortedArr = ListNode.toArray(sortedList);
        System.out.println("排序后: " + Arrays.toString(sortedArr));
        
        // 测试子数组插入排序
        System.out.println("\n4. 子数组插入排序:");
        int[] arr4 = {9, 8, 7, 6, 5, 4, 3, 2, 1};
        System.out.println("原始数组: " + Arrays.toString(arr4));
        
        int[] arr4Copy = arr4.clone();
        insertionSortSubarray(arr4Copy, 2, 6);  // 对索引2到6的子数组排序
        System.out.println("对子数组[2..6]排序后: " + Arrays.toString(arr4Copy));
        
        // 测试自适应插入排序
        System.out.println("\n5. 自适应插入排序:");
        int[] arr5 = {1, 3, 2, 4, 6, 5, 8, 7, 9};  // 几乎有序
        System.out.println("原始数组: " + Arrays.toString(arr5));
        
        int[] arr5Copy = arr5.clone();
        adaptiveInsertionSort(arr5Copy);
        System.out.println("排序后: " + Arrays.toString(arr5Copy));
        
        // 测试稳定插入排序
        System.out.println("\n6. 稳定插入排序（保持相等元素顺序）:");
        int[] arr6 = {3, 1, 2, 3, 1, 2};
        System.out.println("原始数组: " + Arrays.toString(arr6));
        
        int[] arr6Copy = arr6.clone();
        stableInsertionSort(arr6Copy);
        System.out.println("排序后: " + Arrays.toString(arr6Copy));
        
        // 验证稳定性
        System.out.println("\n稳定性验证:");
        System.out.println("第一个3原位置: 0，排序后位置: 2");
        System.out.println("第二个3原位置: 3，排序后位置: 3");
        System.out.println("保持相对顺序: " + (arr6Copy[2] == 3 && arr6Copy[3] == 3));
    }
}
```

## 插入排序的应用场景

### 1. 实际应用示例

```
import java.util.Arrays;

public class PracticalExamples {
    
    /**
     * 扑克牌排序
     */
    static class CardGame {
        enum Suit { HEARTS, DIAMONDS, CLUBS, SPADES }
        enum Rank { TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, 
                    NINE, TEN, JACK, QUEEN, KING, ACE }
        
        static class Card implements Comparable<Card> {
            Suit suit;
            Rank rank;
            
            Card(Suit suit, Rank rank) {
                this.suit = suit;
                this.rank = rank;
            }
            
            int getValue() {
                return rank.ordinal() + 2;  // TWO=2, ACE=14
            }
            
            @Override
            public int compareTo(Card other) {
                return Integer.compare(this.getValue(), other.getValue());
            }
            
            @Override
            public String toString() {
                return rank + " of " + suit;
            }
        }
        
        public static void sortHand(Card[] hand) {
            // 使用插入排序理牌
            for (int i = 1; i < hand.length; i++) {
                Card key = hand[i];
                int j = i - 1;
                
                while (j >= 0 && hand[j].compareTo(key) > 0) {
                    hand[j + 1] = hand[j];
                    j--;
                }
                
                hand[j + 1] = key;
            }
        }
    }
    
    /**
     * 实时数据流排序
     */
    static class DataStreamSorter {
        private int[] buffer;
        private int size;
        private int capacity;
        
        DataStreamSorter(int capacity) {
            this.capacity = capacity;
            this.buffer = new int[capacity];
            this.size = 0;
        }
        
        public void add(int value) {
            if (size == capacity) {
                // 缓冲区已满，可以扩展或丢弃旧数据
                expandCapacity();
            }
            
            // 使用插入排序将新值插入到正确位置
            int i = size - 1;
            while (i >= 0 && buffer[i] > value) {
                buffer[i + 1] = buffer[i];
                i--;
            }
            
            buffer[i + 1] = value;
            size++;
        }
        
        private void expandCapacity() {
            capacity *= 2;
            int[] newBuffer = new int[capacity];
            System.arraycopy(buffer, 0, newBuffer, 0, size);
            buffer = newBuffer;
        }
        
        public int[] getSortedData() {
            return Arrays.copyOf(buffer, size);
        }
    }
    
    /**
     * 学生成绩管理系统
     */
    static class StudentManagement {
        static class Student {
            String id;
            String name;
            int score;
            
            Student(String id, String name, int score) {
                this.id = id;
                this.name = name;
                this.score = score;
            }
            
            @Override
            public String toString() {
                return String.format("学号: %s, 姓名: %s, 成绩: %d", id, name, score);
            }
        }
        
        public static void addStudentAndSort(Student[] students, int currentSize, Student newStudent) {
            // 插入新学生并保持数组有序
            int i = currentSize - 1;
            
            while (i >= 0 && students[i].score < newStudent.score) {
                students[i + 1] = students[i];
                i--;
            }
            
            students[i + 1] = newStudent;
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== 扑克牌排序 ===");
        CardGame.Card[] hand = {
            new CardGame.Card(CardGame.Suit.HEARTS, CardGame.Rank.KING),
            new CardGame.Card(CardGame.Suit.DIAMONDS, CardGame.Rank.FIVE),
            new CardGame.Card(CardGame.Suit.CLUBS, CardGame.Rank.ACE),
            new CardGame.Card(CardGame.Suit.SPADES, CardGame.Rank.TWO),
            new CardGame.Card(CardGame.Suit.HEARTS, CardGame.Rank.TEN)
        };
        
        System.out.println("原始手牌:");
        for (CardGame.Card card : hand) {
            System.out.println("  " + card);
        }
        
        CardGame.sortHand(hand);
        
        System.out.println("\n排序后手牌:");
        for (CardGame.Card card : hand) {
            System.out.println("  " + card);
        }
        
        System.out.println("\n=== 实时数据流排序 ===");
        DataStreamSorter sorter = new DataStreamSorter(10);
        int[] dataStream = {5, 3, 8, 1, 9, 2, 7, 4, 6};
        
        System.out.println("输入数据流: " + Arrays.toString(dataStream));
        for (int data : dataStream) {
            sorter.add(data);
            System.out.println("添加 " + data + " 后: " + 
                Arrays.toString(sorter.getSortedData()));
        }
        
        System.out.println("\n最终排序结果: " + Arrays.toString(sorter.getSortedData()));
        
        System.out.println("\n=== 学生成绩管理系统 ===");
        StudentManagement.Student[] students = new StudentManagement.Student[5];
        students[0] = new StudentManagement.Student("S001", "张三", 85);
        students[1] = new StudentManagement.Student("S002", "李四", 92);
        students[2] = new StudentManagement.Student("S003", "王五", 78);
        
        System.out.println("当前学生列表:");
        for (int i = 0; i < 3; i++) {
            if (students[i] != null) {
                System.out.println("  " + students[i]);
            }
        }
        
        // 添加新学生
        StudentManagement.Student newStudent = 
            new StudentManagement.Student("S004", "赵六", 90);
        StudentManagement.addStudentAndSort(students, 3, newStudent);
        
        System.out.println("\n添加新学生后:");
        for (int i = 0; i < 4; i++) {
            if (students[i] != null) {
                System.out.println("  " + students[i]);
            }
        }
    }
}
```

## 总结

### 插入排序的优缺点

**优点：**

1. **简单直观**：算法思想简单，容易理解和实现
    
2. **原地排序**：只需要O(1)的额外空间
    
3. **稳定排序**：保持相等元素的相对顺序
    
4. **自适应**：对部分有序数组效率很高，最好情况下可达O(n)
    
5. **在线算法**：可以处理动态输入，适用于数据流场景
    
6. **小规模数据高效**：当n ≤ 50时通常比其他O(n²)算法更快
    

**缺点：**

1. **时间复杂度高**：平均和最坏情况下为O(n²)
    
2. **移动操作多**：需要大量的元素后移操作
    
3. **不适用于大规模无序数据**：当数据量较大且无序时性能很差
    

### 与冒泡排序、选择排序的比较

|特性|插入排序|冒泡排序|选择排序|
|---|---|---|---|
|**时间复杂度**​|最好O(n)，最坏O(n²)|最好O(n)，最坏O(n²)|总是O(n²)|
|**比较次数**​|平均n²/4|平均n²/2|总是n²/2|
|**交换/移动次数**​|平均n²/4|平均n²/2|最多n-1|
|**稳定性**​|稳定|稳定|不稳定|
|**最佳适用场景**​|小规模、几乎有序数据|小规模数据|交换成本高的场景|
|**实际性能**​|通常最快|通常最慢|介于两者之间|

### 使用建议

1. **教学目的**：非常适合用于算法教学
    
2. **小规模数据**：当n ≤ 50时通常是最佳选择
    
3. **几乎有序的数据**：对已经基本有序的数据效率极高
    
4. **在线排序**：需要处理实时数据流的场景
    
5. **作为其他算法的基础**：快速排序、归并排序等高级算法在小规模子问题上使用插入排序
    
6. **稳定排序需求**：需要保持相等元素相对顺序的场景
    

### 优化技巧

1. **二分插入排序**：将比较次数从O(n)降低到O(log n)
    
2. **希尔排序**：插入排序的改进，通过间隔序列提高效率
    
3. **哨兵技巧**：减少边界检查
    
4. **递归实现**：更简洁的代码结构
    
5. **链表实现**：避免大量的元素移动
    

### 学习价值

插入排序不仅是简单排序算法的基础，还体现了许多重要的算法思想：

1. **增量法**：逐个处理输入元素
    
2. **原地排序**：高效的空间利用
    
3. **稳定性**：保持相等元素顺序的重要性
    
4. **适应性**：算法性能与输入特性的关系
    
5. **在线算法**：处理动态数据流的能力
    

理解插入排序对于学习更高级的排序算法（如快速排序、归并排序、希尔排序等）具有重要的基础作用。