# Java算法：树表查找

## 定义

**树表查找**（Tree-based Search）是一种基于树形数据结构进行查找的算法集合。与传统的线性查找不同，树表查找利用树的结构特性来实现高效的数据存储、查找、插入和删除操作。

### 核心思想

- 将数据组织成树形结构
    
- 利用树的分支特性快速缩小查找范围
    
- 通过树的高度来控制查找时间复杂度
    
- 支持动态数据集的快速更新
    

### 常见树表结构

|树结构|时间复杂度|特点|
|---|---|---|
|二叉查找树|O(log n)~O(n)|简单但不平衡|
|AVL树|O(log n)|严格平衡二叉树|
|红黑树|O(log n)|近似平衡，插入删除快|
|B树|O(log n)|多路平衡树，适合磁盘存储|
|B+树|O(log n)|B树变体，适合数据库索引|
|2-3树|O(log n)|每个节点2-3个子节点|

## 二叉查找树（BST）

### 定义

二叉查找树是一种特殊的二叉树，满足以下性质：

1. 左子树上所有节点的值均小于根节点的值
    
2. 右子树上所有节点的值均大于根节点的值
    
3. 左右子树也分别为二叉查找树
    

### Java实现

```
import java.util.*;

public class BinarySearchTree {
    
    /**
     * 二叉树节点
     */
    static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        
        TreeNode(int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
        
        TreeNode(int val, TreeNode left, TreeNode right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
        
        @Override
        public String toString() {
            return String.valueOf(val);
        }
    }
    
    private TreeNode root;
    
    public BinarySearchTree() {
        this.root = null;
    }
    
    /**
     * 查找节点
     */
    public TreeNode search(int target) {
        return searchRecursive(root, target);
    }
    
    private TreeNode searchRecursive(TreeNode node, int target) {
        if (node == null || node.val == target) {
            return node;
        }
        
        if (target < node.val) {
            return searchRecursive(node.left, target);
        } else {
            return searchRecursive(node.right, target);
        }
    }
    
    /**
     * 非递归查找
     */
    public TreeNode searchIterative(int target) {
        TreeNode current = root;
        
        while (current != null) {
            if (current.val == target) {
                return current;
            } else if (target < current.val) {
                current = current.left;
            } else {
                current = current.right;
            }
        }
        
        return null;
    }
    
    /**
     * 插入节点
     */
    public void insert(int val) {
        root = insertRecursive(root, val);
    }
    
    private TreeNode insertRecursive(TreeNode node, int val) {
        if (node == null) {
            return new TreeNode(val);
        }
        
        if (val < node.val) {
            node.left = insertRecursive(node.left, val);
        } else if (val > node.val) {
            node.right = insertRecursive(node.right, val);
        }
        // 如果值相等，不插入（BST不允许重复值）
        
        return node;
    }
    
    /**
     * 查找最小值
     */
    public TreeNode findMin() {
        return findMinRecursive(root);
    }
    
    private TreeNode findMinRecursive(TreeNode node) {
        if (node == null) {
            return null;
        }
        
        while (node.left != null) {
            node = node.left;
        }
        
        return node;
    }
    
    /**
     * 查找最大值
     */
    public TreeNode findMax() {
        return findMaxRecursive(root);
    }
    
    private TreeNode findMaxRecursive(TreeNode node) {
        if (node == null) {
            return null;
        }
        
        while (node.right != null) {
            node = node.right;
        }
        
        return node;
    }
    
    /**
     * 删除节点
     */
    public void delete(int val) {
        root = deleteRecursive(root, val);
    }
    
    private TreeNode deleteRecursive(TreeNode node, int val) {
        if (node == null) {
            return null;
        }
        
        if (val < node.val) {
            node.left = deleteRecursive(node.left, val);
        } else if (val > node.val) {
            node.right = deleteRecursive(node.right, val);
        } else {
            // 找到要删除的节点
            if (node.left == null) {
                return node.right;  // 只有右子树或无子树
            } else if (node.right == null) {
                return node.left;   // 只有左子树
            }
            
            // 有两个子节点：用右子树的最小值替换当前节点
            TreeNode minNode = findMinRecursive(node.right);
            node.val = minNode.val;
            node.right = deleteRecursive(node.right, minNode.val);
        }
        
        return node;
    }
    
    /**
     * 中序遍历（有序输出）
     */
    public List<Integer> inorderTraversal() {
        List<Integer> result = new ArrayList<>();
        inorderRecursive(root, result);
        return result;
    }
    
    private void inorderRecursive(TreeNode node, List<Integer> result) {
        if (node == null) {
            return;
        }
        
        inorderRecursive(node.left, result);
        result.add(node.val);
        inorderRecursive(node.right, result);
    }
    
    /**
     * 查找前驱节点
     */
    public TreeNode findPredecessor(int val) {
        TreeNode node = search(val);
        if (node == null) {
            return null;
        }
        
        // 如果有左子树，前驱是左子树的最大值
        if (node.left != null) {
            return findMaxRecursive(node.left);
        }
        
        // 否则，向上找第一个比当前节点小的祖先
        TreeNode current = root;
        TreeNode predecessor = null;
        
        while (current != null) {
            if (current.val < val) {
                predecessor = current;
                current = current.right;
            } else if (current.val > val) {
                current = current.left;
            } else {
                break;
            }
        }
        
        return predecessor;
    }
    
    /**
     * 查找后继节点
     */
    public TreeNode findSuccessor(int val) {
        TreeNode node = search(val);
        if (node == null) {
            return null;
        }
        
        // 如果有右子树，后继是右子树的最小值
        if (node.right != null) {
            return findMinRecursive(node.right);
        }
        
        // 否则，向上找第一个比当前节点大的祖先
        TreeNode current = root;
        TreeNode successor = null;
        
        while (current != null) {
            if (current.val > val) {
                successor = current;
                current = current.left;
            } else if (current.val < val) {
                current = current.right;
            } else {
                break;
            }
        }
        
        return successor;
    }
    
    /**
     * 查找范围内的所有节点
     */
    public List<Integer> rangeSearch(int low, int high) {
        List<Integer> result = new ArrayList<>();
        rangeSearchRecursive(root, low, high, result);
        return result;
    }
    
    private void rangeSearchRecursive(TreeNode node, int low, int high, List<Integer> result) {
        if (node == null) {
            return;
        }
        
        if (node.val > low) {
            rangeSearchRecursive(node.left, low, high, result);
        }
        
        if (node.val >= low && node.val <= high) {
            result.add(node.val);
        }
        
        if (node.val < high) {
            rangeSearchRecursive(node.right, low, high, result);
        }
    }
    
    /**
     * 计算树的高度
     */
    public int height() {
        return heightRecursive(root);
    }
    
    private int heightRecursive(TreeNode node) {
        if (node == null) {
            return 0;
        }
        
        int leftHeight = heightRecursive(node.left);
        int rightHeight = heightRecursive(node.right);
        
        return Math.max(leftHeight, rightHeight) + 1;
    }
    
    /**
     * 判断是否为有效的二叉查找树
     */
    public boolean isValidBST() {
        return isValidBSTRecursive(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }
    
    private boolean isValidBSTRecursive(TreeNode node, long min, long max) {
        if (node == null) {
            return true;
        }
        
        if (node.val <= min || node.val >= max) {
            return false;
        }
        
        return isValidBSTRecursive(node.left, min, node.val) &&
               isValidBSTRecursive(node.right, node.val, max);
    }
    
    /**
     * 显示树的结构
     */
    public void display() {
        if (root == null) {
            System.out.println("树为空");
            return;
        }
        
        List<List<String>> lines = new ArrayList<>();
        List<TreeNode> level = new ArrayList<>();
        List<TreeNode> next = new ArrayList<>();
        
        level.add(root);
        int nn = 1;
        int widest = 0;
        
        while (nn != 0) {
            List<String> line = new ArrayList<>();
            nn = 0;
            
            for (TreeNode node : level) {
                if (node == null) {
                    line.add(null);
                    next.add(null);
                    next.add(null);
                } else {
                    String aa = String.valueOf(node.val);
                    line.add(aa);
                    if (aa.length() > widest) widest = aa.length();
                    
                    next.add(node.left);
                    next.add(node.right);
                    
                    if (node.left != null) nn++;
                    if (node.right != null) nn++;
                }
            }
            
            lines.add(line);
            List<TreeNode> temp = level;
            level = next;
            next = temp;
            next.clear();
        }
        
        int perpiece = lines.get(lines.size() - 1).size() * (widest + 4);
        for (int i = 0; i < lines.size(); i++) {
            List<String> line = lines.get(i);
            int hpw = (int) Math.floor(perpiece / 2f) - 1;
            
            for (int j = 0; j < line.size(); j++) {
                String c = line.get(j);
                if (c == null) c = "";
                int gap1 = (j == 0) ? hpw : (hpw * 2 - 1);
                int gap2 = (j == line.size() - 1) ? hpw : (hpw * 2 - 1);
                
                for (int k = 0; k < gap1; k++) System.out.print(" ");
                System.out.print(c);
                for (int k = 0; k < gap2; k++) System.out.print(" ");
            }
            System.out.println();
        }
    }
    
    public static void main(String[] args) {
        BinarySearchTree bst = new BinarySearchTree();
        
        // 插入数据
        int[] values = {50, 30, 70, 20, 40, 60, 80, 10, 25, 35, 45, 55, 65, 75, 85};
        for (int val : values) {
            bst.insert(val);
        }
        
        System.out.println("=== 二叉查找树演示 ===");
        System.out.println("树的高度: " + bst.height());
        System.out.println("中序遍历: " + bst.inorderTraversal());
        System.out.println("是有效的BST: " + bst.isValidBST());
        
        // 显示树结构
        System.out.println("\n树结构:");
        bst.display();
        
        // 查找测试
        System.out.println("\n=== 查找测试 ===");
        int[] searchValues = {40, 65, 90};
        for (int val : searchValues) {
            TreeNode result = bst.search(val);
            System.out.println("查找 " + val + ": " + 
                (result != null ? "找到" : "未找到"));
        }
        
        // 查找最小值和最大值
        System.out.println("最小值: " + bst.findMin());
        System.out.println("最大值: " + bst.findMax());
        
        // 查找前驱和后继
        System.out.println("\n=== 前驱和后继 ===");
        int target = 40;
        System.out.println(target + "的前驱: " + bst.findPredecessor(target));
        System.out.println(target + "的后继: " + bst.findSuccessor(target));
        
        // 范围查找
        System.out.println("\n=== 范围查找 [30, 60] ===");
        List<Integer> rangeResult = bst.rangeSearch(30, 60);
        System.out.println("范围内的节点: " + rangeResult);
        
        // 删除测试
        System.out.println("\n=== 删除测试 ===");
        System.out.println("删除 40");
        bst.delete(40);
        System.out.println("删除后中序遍历: " + bst.inorderTraversal());
        
        // 查找被删除的节点
        System.out.println("再次查找 40: " + 
            (bst.search(40) != null ? "找到" : "未找到"));
    }
}
```

## 平衡二叉查找树：AVL树

### 定义

AVL树是一种自平衡的二叉查找树，在每次插入和删除后都会通过旋转操作来保持平衡。平衡因子（Balance Factor）定义为左子树高度减去右子树高度，AVL树要求每个节点的平衡因子的绝对值不超过1。

```
import java.util.*;

public class AVLTree {
    
    /**
     * AVL树节点
     */
    static class AVLNode {
        int val;
        int height;
        AVLNode left;
        AVLNode right;
        
        AVLNode(int val) {
            this.val = val;
            this.height = 1;
            this.left = null;
            this.right = null;
        }
    }
    
    private AVLNode root;
    
    public AVLTree() {
        this.root = null;
    }
    
    /**
     * 获取节点高度
     */
    private int height(AVLNode node) {
        return node == null ? 0 : node.height;
    }
    
    /**
     * 获取平衡因子
     */
    private int getBalance(AVLNode node) {
        return node == null ? 0 : height(node.left) - height(node.right);
    }
    
    /**
     * 右旋转
     */
    private AVLNode rightRotate(AVLNode y) {
        AVLNode x = y.left;
        AVLNode T2 = x.right;
        
        // 旋转
        x.right = y;
        y.left = T2;
        
        // 更新高度
        y.height = Math.max(height(y.left), height(y.right)) + 1;
        x.height = Math.max(height(x.left), height(x.right)) + 1;
        
        return x;
    }
    
    /**
     * 左旋转
     */
    private AVLNode leftRotate(AVLNode x) {
        AVLNode y = x.right;
        AVLNode T2 = y.left;
        
        // 旋转
        y.left = x;
        x.right = T2;
        
        // 更新高度
        x.height = Math.max(height(x.left), height(x.right)) + 1;
        y.height = Math.max(height(y.left), height(y.right)) + 1;
        
        return y;
    }
    
    /**
     * 插入节点
     */
    public void insert(int val) {
        root = insertRecursive(root, val);
    }
    
    private AVLNode insertRecursive(AVLNode node, int val) {
        // 1. 标准BST插入
        if (node == null) {
            return new AVLNode(val);
        }
        
        if (val < node.val) {
            node.left = insertRecursive(node.left, val);
        } else if (val > node.val) {
            node.right = insertRecursive(node.right, val);
        } else {
            return node;  // 不允许重复值
        }
        
        // 2. 更新高度
        node.height = Math.max(height(node.left), height(node.right)) + 1;
        
        // 3. 获取平衡因子
        int balance = getBalance(node);
        
        // 4. 如果不平衡，有4种情况
        
        // 左左情况
        if (balance > 1 && val < node.left.val) {
            return rightRotate(node);
        }
        
        // 右右情况
        if (balance < -1 && val > node.right.val) {
            return leftRotate(node);
        }
        
        // 左右情况
        if (balance > 1 && val > node.left.val) {
            node.left = leftRotate(node.left);
            return rightRotate(node);
        }
        
        // 右左情况
        if (balance < -1 && val < node.right.val) {
            node.right = rightRotate(node.right);
            return leftRotate(node);
        }
        
        return node;
    }
    
    /**
     * 查找节点
     */
    public AVLNode search(int target) {
        return searchRecursive(root, target);
    }
    
    private AVLNode searchRecursive(AVLNode node, int target) {
        if (node == null || node.val == target) {
            return node;
        }
        
        if (target < node.val) {
            return searchRecursive(node.left, target);
        } else {
            return searchRecursive(node.right, target);
        }
    }
    
    /**
     * 查找最小值节点
     */
    private AVLNode findMinNode(AVLNode node) {
        AVLNode current = node;
        while (current.left != null) {
            current = current.left;
        }
        return current;
    }
    
    /**
     * 删除节点
     */
    public void delete(int val) {
        root = deleteRecursive(root, val);
    }
    
    private AVLNode deleteRecursive(AVLNode root, int val) {
        // 1. 标准BST删除
        if (root == null) {
            return root;
        }
        
        if (val < root.val) {
            root.left = deleteRecursive(root.left, val);
        } else if (val > root.val) {
            root.right = deleteRecursive(root.right, val);
        } else {
            // 找到要删除的节点
            
            // 节点有一个子节点或无子节点
            if (root.left == null || root.right == null) {
                AVLNode temp = (root.left != null) ? root.left : root.right;
                
                // 无子节点的情况
                if (temp == null) {
                    temp = root;
                    root = null;
                } else {
                    // 有一个子节点的情况
                    root = temp;
                }
            } else {
                // 有两个子节点：用后继节点（右子树的最小值）替换
                AVLNode temp = findMinNode(root.right);
                root.val = temp.val;
                root.right = deleteRecursive(root.right, temp.val);
            }
        }
        
        // 如果树只有一个节点，返回
        if (root == null) {
            return root;
        }
        
        // 2. 更新高度
        root.height = Math.max(height(root.left), height(root.right)) + 1;
        
        // 3. 获取平衡因子
        int balance = getBalance(root);
        
        // 4. 如果不平衡，有4种情况
        
        // 左左情况
        if (balance > 1 && getBalance(root.left) >= 0) {
            return rightRotate(root);
        }
        
        // 左右情况
        if (balance > 1 && getBalance(root.left) < 0) {
            root.left = leftRotate(root.left);
            return rightRotate(root);
        }
        
        // 右右情况
        if (balance < -1 && getBalance(root.right) <= 0) {
            return leftRotate(root);
        }
        
        // 右左情况
        if (balance < -1 && getBalance(root.right) > 0) {
            root.right = rightRotate(root.right);
            return leftRotate(root);
        }
        
        return root;
    }
    
    /**
     * 中序遍历
     */
    public List<Integer> inorderTraversal() {
        List<Integer> result = new ArrayList<>();
        inorderRecursive(root, result);
        return result;
    }
    
    private void inorderRecursive(AVLNode node, List<Integer> result) {
        if (node == null) {
            return;
        }
        
        inorderRecursive(node.left, result);
        result.add(node.val);
        inorderRecursive(node.right, result);
    }
    
    /**
     * 前序遍历
     */
    public List<Integer> preorderTraversal() {
        List<Integer> result = new ArrayList<>();
        preorderRecursive(root, result);
        return result;
    }
    
    private void preorderRecursive(AVLNode node, List<Integer> result) {
        if (node == null) {
            return;
        }
        
        result.add(node.val);
        preorderRecursive(node.left, result);
        preorderRecursive(node.right, result);
    }
    
    /**
     * 验证是否为AVL树
     */
    public boolean isAVLTree() {
        return isAVLTreeRecursive(root);
    }
    
    private boolean isAVLTreeRecursive(AVLNode node) {
        if (node == null) {
            return true;
        }
        
        int balance = getBalance(node);
        if (balance < -1 || balance > 1) {
            return false;
        }
        
        return isAVLTreeRecursive(node.left) && isAVLTreeRecursive(node.right);
    }
    
    /**
     * 获取树的高度
     */
    public int getHeight() {
        return height(root);
    }
    
    /**
     * 打印树的结构
     */
    public void printTree() {
        printTreeRecursive(root, "", true);
    }
    
    private void printTreeRecursive(AVLNode node, String prefix, boolean isLeft) {
        if (node != null) {
            System.out.println(prefix + (isLeft ? "├── " : "└── ") + node.val + 
                             "(h=" + node.height + ", b=" + getBalance(node) + ")");
            printTreeRecursive(node.left, prefix + (isLeft ? "│   " : "    "), true);
            printTreeRecursive(node.right, prefix + (isLeft ? "│   " : "    "), false);
        }
    }
    
    public static void main(String[] args) {
        AVLTree avl = new AVLTree();
        
        System.out.println("=== AVL树演示 ===");
        
        // 插入测试
        int[] insertValues = {10, 20, 30, 40, 50, 25};
        System.out.println("插入顺序: " + Arrays.toString(insertValues));
        
        for (int val : insertValues) {
            avl.insert(val);
            System.out.println("插入 " + val + " 后:");
            avl.printTree();
            System.out.println("是AVL树: " + avl.isAVLTree());
            System.out.println();
        }
        
        System.out.println("中序遍历: " + avl.inorderTraversal());
        System.out.println("前序遍历: " + avl.preorderTraversal());
        System.out.println("树高度: " + avl.getHeight());
        
        // 查找测试
        System.out.println("\n=== 查找测试 ===");
        int[] searchValues = {30, 35, 20};
        for (int val : searchValues) {
            AVLNode result = avl.search(val);
            System.out.println("查找 " + val + ": " + 
                (result != null ? "找到" : "未找到"));
        }
        
        // 删除测试
        System.out.println("\n=== 删除测试 ===");
        System.out.println("删除 40");
        avl.delete(40);
        avl.printTree();
        System.out.println("是AVL树: " + avl.isAVLTree());
        System.out.println("中序遍历: " + avl.inorderTraversal());
    }
}
```

## 红黑树（Red-Black Tree）

### 定义

红黑树是一种自平衡的二叉查找树，具有以下性质：

1. 每个节点是红色或黑色
    
2. 根节点是黑色
    
3. 所有叶子节点（NIL节点）是黑色
    
4. 红色节点的两个子节点都是黑色
    
5. 从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点
    

```
import java.util.*;

public class RedBlackTree {
    
    // 定义颜色常量
    private static final boolean RED = true;
    private static final boolean BLACK = false;
    
    /**
     * 红黑树节点
     */
    static class RBNode {
        int key;
        RBNode left, right, parent;
        boolean color;
        
        RBNode(int key) {
            this.key = key;
            this.color = RED;  // 新节点默认为红色
            this.left = null;
            this.right = null;
            this.parent = null;
        }
    }
    
    private RBNode root;
    private final RBNode NIL;  // 叶子节点（哨兵）
    
    public RedBlackTree() {
        NIL = new RBNode(-1);
        NIL.color = BLACK;
        NIL.left = null;
        NIL.right = null;
        root = NIL;
    }
    
    /**
     * 左旋转
     */
    private void leftRotate(RBNode x) {
        RBNode y = x.right;
        x.right = y.left;
        
        if (y.left != NIL) {
            y.left.parent = x;
        }
        
        y.parent = x.parent;
        
        if (x.parent == null) {
            root = y;
        } else if (x == x.parent.left) {
            x.parent.left = y;
        } else {
            x.parent.right = y;
        }
        
        y.left = x;
        x.parent = y;
    }
    
    /**
     * 右旋转
     */
    private void rightRotate(RBNode x) {
        RBNode y = x.left;
        x.left = y.right;
        
        if (y.right != NIL) {
            y.right.parent = x;
        }
        
        y.parent = x.parent;
        
        if (x.parent == null) {
            root = y;
        } else if (x == x.parent.right) {
            x.parent.right = y;
        } else {
            x.parent.left = y;
        }
        
        y.right = x;
        x.parent = y;
    }
    
    /**
     * 插入节点
     */
    public void insert(int key) {
        RBNode node = new RBNode(key);
        node.left = NIL;
        node.right = NIL;
        
        RBNode y = null;
        RBNode x = root;
        
        // 查找插入位置
        while (x != NIL) {
            y = x;
            if (node.key < x.key) {
                x = x.left;
            } else if (node.key > x.key) {
                x = x.right;
            } else {
                return;  // 不允许重复键
            }
        }
        
        node.parent = y;
        
        if (y == null) {
            root = node;
        } else if (node.key < y.key) {
            y.left = node;
        } else {
            y.right = node;
        }
        
        // 如果新节点是根节点，设置为黑色
        if (node.parent == null) {
            node.color = BLACK;
            return;
        }
        
        // 如果祖父节点为空，返回
        if (node.parent.parent == null) {
            return;
        }
        
        // 修复红黑树性质
        fixInsert(node);
    }
    
    /**
     * 修复插入后的红黑树
     */
    private void fixInsert(RBNode k) {
        RBNode u;
        
        while (k.parent != null && k.parent.color == RED) {
            if (k.parent == k.parent.parent.right) {
                u = k.parent.parent.left;  // 叔叔节点
                
                if (u.color == RED) {
                    // 情况1：叔叔节点是红色
                    u.color = BLACK;
                    k.parent.color = BLACK;
                    k.parent.parent.color = RED;
                    k = k.parent.parent;
                } else {
                    if (k == k.parent.left) {
                        // 情况2：叔叔节点是黑色，k是左孩子
                        k = k.parent;
                        rightRotate(k);
                    }
                    
                    // 情况3：叔叔节点是黑色，k是右孩子
                    k.parent.color = BLACK;
                    k.parent.parent.color = RED;
                    leftRotate(k.parent.parent);
                }
            } else {
                u = k.parent.parent.right;  // 叔叔节点
                
                if (u.color == RED) {
                    // 情况1：叔叔节点是红色
                    u.color = BLACK;
                    k.parent.color = BLACK;
                    k.parent.parent.color = RED;
                    k = k.parent.parent;
                } else {
                    if (k == k.parent.right) {
                        // 情况2：叔叔节点是黑色，k是右孩子
                        k = k.parent;
                        leftRotate(k);
                    }
                    
                    // 情况3：叔叔节点是黑色，k是左孩子
                    k.parent.color = BLACK;
                    k.parent.parent.color = RED;
                    rightRotate(k.parent.parent);
                }
            }
            
            if (k == root) {
                break;
            }
        }
        
        root.color = BLACK;
    }
    
    /**
     * 查找节点
     */
    public RBNode search(int key) {
        return searchRecursive(root, key);
    }
    
    private RBNode searchRecursive(RBNode node, int key) {
        if (node == NIL || key == node.key) {
            return node;
        }
        
        if (key < node.key) {
            return searchRecursive(node.left, key);
        } else {
            return searchRecursive(node.right, key);
        }
    }
    
    /**
     * 查找最小值节点
     */
    private RBNode minimum(RBNode node) {
        while (node.left != NIL) {
            node = node.left;
        }
        return node;
    }
    
    /**
     * 查找最大值节点
     */
    private RBNode maximum(RBNode node) {
        while (node.right != NIL) {
            node = node.right;
        }
        return node;
    }
    
    /**
     * 中序遍历
     */
    public List<Integer> inorderTraversal() {
        List<Integer> result = new ArrayList<>();
        inorderRecursive(root, result);
        return result;
    }
    
    private void inorderRecursive(RBNode node, List<Integer> result) {
        if (node != NIL) {
            inorderRecursive(node.left, result);
            result.add(node.key);
            inorderRecursive(node.right, result);
        }
    }
    
    /**
     * 验证红黑树性质
     */
    public boolean isValidRedBlackTree() {
        if (root == null) {
            return true;
        }
        
        // 性质2：根节点是黑色
        if (root.color != BLACK) {
            System.out.println("违反性质2：根节点不是黑色");
            return false;
        }
        
        // 检查每条路径的黑色节点数
        int blackCount = -1;
        return checkRedBlackProperties(root, 0, blackCount);
    }
    
    private boolean checkRedBlackProperties(RBNode node, int blackCount, int pathBlackCount) {
        if (node == NIL) {
            blackCount++;
            
            if (pathBlackCount == -1) {
                pathBlackCount = blackCount;
            } else if (blackCount != pathBlackCount) {
                System.out.println("违反性质5：不同路径的黑色节点数不同");
                return false;
            }
            return true;
        }
        
        // 性质4：红色节点的两个子节点都是黑色
        if (node.color == RED) {
            if (node.left.color == RED || node.right.color == RED) {
                System.out.println("违反性质4：红色节点有红色子节点");
                return false;
            }
        } else {
            blackCount++;
        }
        
        return checkRedBlackProperties(node.left, blackCount, pathBlackCount) &&
               checkRedBlackProperties(node.right, blackCount, pathBlackCount);
    }
    
    /**
     * 打印树的结构
     */
    public void printTree() {
        printTreeRecursive(root, "", true);
    }
    
    private void printTreeRecursive(RBNode node, String prefix, boolean isLeft) {
        if (node != NIL) {
            System.out.println(prefix + (isLeft ? "├── " : "└── ") + 
                             node.key + "(" + (node.color == RED ? "R" : "B") + ")");
            printTreeRecursive(node.left, prefix + (isLeft ? "│   " : "    "), true);
            printTreeRecursive(node.right, prefix + (isLeft ? "│   " : "    "), false);
        }
    }
    
    /**
     * 获取树的高度
     */
    public int getHeight() {
        return getHeightRecursive(root);
    }
    
    private int getHeightRecursive(RBNode node) {
        if (node == NIL) {
            return 0;
        }
        
        int leftHeight = getHeightRecursive(node.left);
        int rightHeight = getHeightRecursive(node.right);
        
        return Math.max(leftHeight, rightHeight) + 1;
    }
    
    /**
     * 获取黑色高度
     */
    public int getBlackHeight() {
        return getBlackHeightRecursive(root);
    }
    
    private int getBlackHeightRecursive(RBNode node) {
        if (node == NIL) {
            return 1;  // NIL节点是黑色
        }
        
        int leftBlackHeight = getBlackHeightRecursive(node.left);
        int rightBlackHeight = getBlackHeightRecursive(node.right);
        
        if (leftBlackHeight != rightBlackHeight) {
            return -1;  // 不是有效的红黑树
        }
        
        return leftBlackHeight + (node.color == BLACK ? 1 : 0);
    }
    
    public static void main(String[] args) {
        RedBlackTree rbt = new RedBlackTree();
        
        System.out.println("=== 红黑树演示 ===");
        
        // 插入测试
        int[] insertValues = {7, 3, 18, 10, 22, 8, 11, 26, 2, 6, 13};
        System.out.println("插入顺序: " + Arrays.toString(insertValues));
        
        for (int val : insertValues) {
            rbt.insert(val);
            System.out.println("插入 " + val + " 后:");
            rbt.printTree();
            System.out.println("是有效的红黑树: " + rbt.isValidRedBlackTree());
            System.out.println("树高度: " + rbt.getHeight());
            System.out.println("黑色高度: " + rbt.getBlackHeight());
            System.out.println();
        }
        
        System.out.println("中序遍历: " + rbt.inorderTraversal());
        
        // 查找测试
        System.out.println("\n=== 查找测试 ===");
        int[] searchValues = {10, 5, 18, 13};
        for (int val : searchValues) {
            RBNode result = rbt.search(val);
            System.out.println("查找 " + val + ": " + 
                (result != rbt.NIL ? "找到" : "未找到"));
        }
        
        // 查找最小值和最大值
        System.out.println("最小值: " + rbt.minimum(rbt.root).key);
        System.out.println("最大值: " + rbt.maximum(rbt.root).key);
        
        // 性能测试
        System.out.println("\n=== 性能测试 ===");
        RedBlackTree largeTree = new RedBlackTree();
        int size = 1000;
        
        long startTime = System.currentTimeMillis();
        for (int i = 0; i < size; i++) {
            largeTree.insert((int)(Math.random() * 10000));
        }
        long insertTime = System.currentTimeMillis() - startTime;
        
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 1000; i++) {
            largeTree.search((int)(Math.random() * 10000));
        }
        long searchTime = System.currentTimeMillis() - startTime;
        
        System.out.println("插入 " + size + " 个节点用时: " + insertTime + "ms");
        System.out.println("1000 次随机查找用时: " + searchTime + "ms");
        System.out.println("树高度: " + largeTree.getHeight());
        System.out.println("黑色高度: " + largeTree.getBlackHeight());
        System.out.println("是有效的红黑树: " + largeTree.isValidRedBlackTree());
    }
}
```

## B树（B-Tree）

### 定义

B树是一种平衡的多路搜索树，常用于数据库和文件系统的实现。一个m阶B树具有以下性质：

1. 每个节点最多有m个子节点
    
2. 除根节点外，每个非叶子节点至少有⌈m/2⌉个子节点
    
3. 根节点至少有2个子节点（除非是叶子节点）
    
4. 所有叶子节点都在同一层
    
5. 有k个子节点的非叶子节点包含k-1个键
    

```
import java.util.*;

public class BTree {
    
    /**
     * B树节点
     */
    static class BTreeNode {
        List<Integer> keys;  // 存储的键
        List<BTreeNode> children;  // 子节点
        boolean isLeaf;  // 是否为叶子节点
        int t;  // 最小度数
        
        BTreeNode(int t, boolean isLeaf) {
            this.t = t;
            this.isLeaf = isLeaf;
            this.keys = new ArrayList<>();
            this.children = new ArrayList<>();
        }
        
        /**
         * 查找键，返回索引或-1
         */
        int findKey(int k) {
            for (int i = 0; i < keys.size(); i++) {
                if (keys.get(i) == k) {
                    return i;
                } else if (keys.get(i) > k) {
                    return -i - 1;  // 返回应该插入的位置
                }
            }
            return -keys.size() - 1;  // 应该插入到最后
        }
        
        /**
         * 插入到非满节点
         */
        void insertNonFull(int k) {
            int i = keys.size() - 1;
            
            if (isLeaf) {
                // 如果是叶子节点，直接插入
                while (i >= 0 && keys.get(i) > k) {
                    i--;
                }
                keys.add(i + 1, k);
            } else {
                // 找到应该插入的子节点
                while (i >= 0 && keys.get(i) > k) {
                    i--;
                }
                
                BTreeNode child = children.get(i + 1);
                if (child.keys.size() == 2 * t - 1) {
                    // 如果子节点已满，先分裂
                    splitChild(i + 1, child);
                    if (keys.get(i + 1) < k) {
                        i++;
                    }
                }
                children.get(i + 1).insertNonFull(k);
            }
        }
        
        /**
         * 分裂子节点
         */
        void splitChild(int i, BTreeNode y) {
            BTreeNode z = new BTreeNode(y.t, y.isLeaf);
            
            // 复制后t-1个键到新节点
            for (int j = 0; j < t - 1; j++) {
                z.keys.add(y.keys.get(j + t));
            }
            
            // 如果不是叶子节点，复制子节点
            if (!y.isLeaf) {
                for (int j = 0; j < t; j++) {
                    z.children.add(y.children.get(j + t));
                }
            }
            
            // 移除y中多余的键和子节点
            for (int j = 0; j < t - 1; j++) {
                y.keys.remove(y.keys.size() - 1);
            }
            
            if (!y.isLeaf) {
                for (int j = 0; j < t; j++) {
                    y.children.remove(y.children.size() - 1);
                }
            }
            
            // 插入中间键到当前节点
            keys.add(i, y.keys.get(t - 1));
            y.keys.remove(t - 1);
            
            // 插入新子节点
            children.add(i + 1, z);
        }
        
        /**
         * 查找键
         */
        boolean search(int k) {
            int i = 0;
            while (i < keys.size() && k > keys.get(i)) {
                i++;
            }
            
            if (i < keys.size() && keys.get(i) == k) {
                return true;
            }
            
            if (isLeaf) {
                return false;
            }
            
            return children.get(i).search(k);
        }
        
        /**
         * 中序遍历
         */
        void traverse(List<Integer> result) {
            int i;
            for (i = 0; i < keys.size(); i++) {
                if (!isLeaf) {
                    children.get(i).traverse(result);
                }
                result.add(keys.get(i));
            }
            
            if (!isLeaf) {
                children.get(i).traverse(result);
            }
        }
        
        /**
         * 打印节点
         */
        void print(String prefix, boolean isTail) {
            System.out.println(prefix + (isTail ? "└── " : "├── ") + keys);
            
            for (int i = 0; i < children.size() - 1; i++) {
                children.get(i).print(prefix + (isTail ? "    " : "│   "), false);
            }
            
            if (children.size() > 0) {
                children.get(children.size() - 1).print(
                    prefix + (isTail ? "    " : "│   "), true);
            }
        }
    }
    
    private BTreeNode root;
    private int t;  // 最小度数
    
    public BTree(int t) {
        this.t = t;
        root = new BTreeNode(t, true);
    }
    
    /**
     * 查找键
     */
    public boolean search(int k) {
        return root.search(k);
    }
    
    /**
     * 插入键
     */
    public void insert(int k) {
        if (root.keys.size() == 2 * t - 1) {
            // 根节点已满，需要分裂
            BTreeNode s = new BTreeNode(t, false);
            s.children.add(root);
            s.splitChild(0, root);
            
            // 决定插入哪个子节点
            int i = 0;
            if (s.keys.get(0) < k) {
                i++;
            }
            s.children.get(i).insertNonFull(k);
            
            root = s;
        } else {
            root.insertNonFull(k);
        }
    }
    
    /**
     * 中序遍历
     */
    public List<Integer> traverse() {
        List<Integer> result = new ArrayList<>();
        if (root != null) {
            root.traverse(result);
        }
        return result;
    }
    
    /**
     * 打印B树
     */
    public void print() {
        if (root != null) {
            root.print("", true);
        }
    }
    
    /**
     * 获取树的高度
     */
    public int getHeight() {
        return getHeightRecursive(root);
    }
    
    private int getHeightRecursive(BTreeNode node) {
        if (node == null) {
            return 0;
        }
        
        if (node.isLeaf) {
            return 1;
        }
        
        return 1 + getHeightRecursive(node.children.get(0));
    }
    
    /**
     * 验证B树性质
     */
    public boolean isValidBTree() {
        return isValidBTreeRecursive(root, Integer.MIN_VALUE, Integer.MAX_VALUE, true);
    }
    
    private boolean isValidBTreeRecursive(BTreeNode node, int min, int max, boolean isRoot) {
        if (node == null) {
            return true;
        }
        
        // 检查键的数量
        int keyCount = node.keys.size();
        if (!isRoot && keyCount < t - 1) {
            System.out.println("键数量太少: " + keyCount + " < " + (t - 1));
            return false;
        }
        
        if (keyCount > 2 * t - 1) {
            System.out.println("键数量太多: " + keyCount + " > " + (2 * t - 1));
            return false;
        }
        
        // 检查键的顺序
        for (int i = 0; i < keyCount; i++) {
            int key = node.keys.get(i);
            if (key <= min || key >= max) {
                System.out.println("键顺序错误: " + key + " 不在 (" + min + ", " + max + ")");
                return false;
            }
        }
        
        // 递归检查子节点
        if (!node.isLeaf) {
            int childCount = node.children.size();
            
            if (childCount != keyCount + 1) {
                System.out.println("子节点数量错误: " + childCount + " != " + (keyCount + 1));
                return false;
            }
            
            // 检查每个子节点
            for (int i = 0; i < childCount; i++) {
                int childMin = (i == 0) ? min : node.keys.get(i - 1);
                int childMax = (i == childCount - 1) ? max : node.keys.get(i);
                
                if (!isValidBTreeRecursive(node.children.get(i), childMin, childMax, false)) {
                    return false;
                }
            }
        }
        
        return true;
    }
    
    public static void main(String[] args) {
        BTree bTree = new BTree(3);  // 创建最小度为3的B树
        
        System.out.println("=== B树演示 (最小度t=3) ===");
        
        // 插入测试
        int[] insertValues = {10, 20, 5, 6, 12, 30, 7, 17, 3, 2, 1, 8, 9, 15, 18};
        System.out.println("插入顺序: " + Arrays.toString(insertValues));
        
        for (int val : insertValues) {
            bTree.insert(val);
            System.out.println("插入 " + val + " 后:");
            bTree.print();
            System.out.println("是有效的B树: " + bTree.isValidBTree());
            System.out.println("树高度: " + bTree.getHeight());
            System.out.println();
        }
        
        System.out.println("中序遍历: " + bTree.traverse());
        
        // 查找测试
        System.out.println("\n=== 查找测试 ===");
        int[] searchValues = {6, 15, 25, 30, 100};
        for (int val : searchValues) {
            boolean found = bTree.search(val);
            System.out.println("查找 " + val + ": " + (found ? "找到" : "未找到"));
        }
        
        // 性能测试
        System.out.println("\n=== 性能测试 ===");
        BTree largeBTree = new BTree(5);
        int size = 1000;
        
        long startTime = System.currentTimeMillis();
        for (int i = 0; i < size; i++) {
            largeBTree.insert((int)(Math.random() * 10000));
        }
        long insertTime = System.currentTimeMillis() - startTime;
        
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 1000; i++) {
            largeBTree.search((int)(Math.random() * 10000));
        }
        long searchTime = System.currentTimeMillis() - startTime;
        
        System.out.println("插入 " + size + " 个节点用时: " + insertTime + "ms");
        System.out.println("1000 次随机查找用时: " + searchTime + "ms");
        System.out.println("树高度: " + largeBTree.getHeight());
        System.out.println("是有效的B树: " + largeBTree.isValidBTree());
    }
}
```

## 比较和应用场景

### 各种树表查找的比较

|树类型|平均查找|最坏查找|插入/删除|空间|应用场景|
|---|---|---|---|---|---|
|二叉查找树|O(log n)|O(n)|O(log n)~O(n)|O(n)|简单应用，教学|
|AVL树|O(log n)|O(log n)|O(log n)|O(n)|查找频繁，更新少|
|红黑树|O(log n)|O(log n)|O(log n)|O(n)|综合性能好，Java TreeMap|
|B树|O(log n)|O(log n)|O(log n)|O(n)|文件系统，数据库索引|
|B+树|O(log n)|O(log n)|O(log n)|O(n)|数据库索引，文件系统|

### 使用Java内置的树结构

```
import java.util.*;

public class JavaBuiltInTreeExamples {
    
    public static void main(String[] args) {
        System.out.println("=== Java内置树结构演示 ===");
        
        // 1. TreeSet（基于红黑树）
        System.out.println("\n1. TreeSet（有序集合）:");
        TreeSet<Integer> treeSet = new TreeSet<>();
        treeSet.addAll(Arrays.asList(5, 2, 8, 1, 9, 3, 7));
        
        System.out.println("原始集合: " + treeSet);
        System.out.println("查找 8: " + treeSet.contains(8));
        System.out.println("查找 4: " + treeSet.contains(4));
        System.out.println("最小值: " + treeSet.first());
        System.out.println("最大值: " + treeSet.last());
        System.out.println("大于等于4的元素: " + treeSet.ceiling(4));
        System.out.println("小于等于6的元素: " + treeSet.floor(6));
        System.out.println("子集 [3, 8): " + treeSet.subSet(3, 8));
        
        // 2. TreeMap（基于红黑树）
        System.out.println("\n2. TreeMap（有序映射）:");
        TreeMap<String, Integer> treeMap = new TreeMap<>();
        treeMap.put("apple", 5);
        treeMap.put("banana", 3);
        treeMap.put("orange", 8);
        treeMap.put("grape", 2);
        treeMap.put("pear", 6);
        
        System.out.println("原始映射: " + treeMap);
        System.out.println("查找 banana: " + treeMap.get("banana"));
        System.out.println("查找 kiwi: " + treeMap.get("kiwi"));
        System.out.println("第一个键: " + treeMap.firstKey());
        System.out.println("最后一个键: " + treeMap.lastKey());
        System.out.println("大于等于m的第一个键: " + treeMap.ceilingKey("m"));
        System.out.println("子映射 [b, o): " + treeMap.subMap("b", "o"));
        
        // 3. 范围查询演示
        System.out.println("\n3. 范围查询演示:");
        TreeMap<Integer, String> scoreMap = new TreeMap<>();
        scoreMap.put(90, "Alice");
        scoreMap.put(85, "Bob");
        scoreMap.put(92, "Charlie");
        scoreMap.put(78, "David");
        scoreMap.put(95, "Eve");
        scoreMap.put(88, "Frank");
        
        // 查找80-90分的学生
        SortedMap<Integer, String> goodStudents = scoreMap.subMap(80, 90);
        System.out.println("80-89分的学生: " + goodStudents);
        
        // 查找最高的3个分数
        System.out.println("最高的3个分数: " + scoreMap.descendingMap().entrySet()
            .stream().limit(3).collect(LinkedHashMap::new, (m, e) -> m.put(e.getKey(), e.getValue()), Map::putAll));
        
        // 4. 性能比较
        System.out.println("\n4. 性能比较:");
        
        // TreeSet vs HashSet
        int size = 100000;
        
        TreeSet<Integer> treeSetLarge = new TreeSet<>();
        HashSet<Integer> hashSet = new HashSet<>();
        
        // 插入性能
        long start = System.currentTimeMillis();
        for (int i = 0; i < size; i++) {
            treeSetLarge.add(i);
        }
        long treeSetInsertTime = System.currentTimeMillis() - start;
        
        start = System.currentTimeMillis();
        for (int i = 0; i < size; i++) {
            hashSet.add(i);
        }
        long hashSetInsertTime = System.currentTimeMillis() - start;
        
        // 查找性能
        start = System.currentTimeMillis();
        for (int i = 0; i < 10000; i++) {
            treeSetLarge.contains((int)(Math.random() * size));
        }
        long treeSetSearchTime = System.currentTimeMillis() - start;
        
        start = System.currentTimeMillis();
        for (int i = 0; i < 10000; i++) {
            hashSet.contains((int)(Math.random() * size));
        }
        long hashSetSearchTime = System.currentTimeMillis() - start;
        
        System.out.println("插入 " + size + " 个元素:");
        System.out.println("  TreeSet: " + treeSetInsertTime + "ms");
        System.out.println("  HashSet: " + hashSetInsertTime + "ms");
        
        System.out.println("10000 次随机查找:");
        System.out.println("  TreeSet: " + treeSetSearchTime + "ms");
        System.out.println("  HashSet: " + hashSetSearchTime + "ms");
        
        // 内存使用
        System.out.println("TreeSet大小: " + treeSetLarge.size());
        System.out.println("HashSet大小: " + hashSet.size());
    }
}
```

## 总结

树表查找是计算机科学中非常重要的一类查找算法，具有以下特点：

### 核心优势

1. **高效查找**：大多数树结构提供O(log n)的查找时间复杂度
    
2. **动态操作**：支持高效的插入、删除操作
    
3. **有序性**：保持数据的有序性，支持范围查询
    
4. **灵活性**：适用于内存和磁盘存储
    

### 选择建议

1. **简单应用**：使用二叉查找树
    
2. **需要严格平衡**：使用AVL树
    
3. **综合性能要求**：使用红黑树（Java的TreeMap/TreeSet实现）
    
4. **磁盘存储/数据库**：使用B树或B+树
    
5. **只需要存在性检查**：考虑使用哈希表
    

### 学习价值

1. 理解树的基本操作和遍历
    
2. 掌握平衡树的维护机制
    
3. 学习算法设计和优化的思想
    
4. 为学习更高级数据结构（如跳表、Trie树）打下基础
    

树表查找在实际开发中有广泛应用，包括数据库索引、文件系统、路由表、编译器符号表等。理解不同树结构的特性和适用场景，能够帮助你在实际项目中做出正确的技术选型。