你代码中演示的 `File`类方法非常实用，它们主要用于获取文件或目录的属性信息。为了方便你理解和记忆，我将这些方法整理成了表格。

### 📊 文件信息获取方法一览

|方法名|功能说明|返回值类型|代码示例|
|---|---|---|---|
|**`isFile()`**​|判断该 `File`对象是否代表一个**标准文件**（而非目录）。|`boolean`|`f1.isFile()`|
|**`isDirectory()`**​|判断该 `File`对象是否代表一个**目录**（文件夹）。|`boolean`|`f1.isDirectory()`|
|**`getName()`**​|获取文件或目录的**名称**（不包含父路径）。|`String`|`f1.getName()`// 例如 "a.txt"|
|**`getPath()`**​|获取构造 `File`对象时传入的**路径字符串**。|`String`|`f1.getPath()`|
|**`getAbsolutePath()`**​|获取文件或目录的**绝对路径**（完整路径）。|`String`|`f1.getAbsolutePath()`|
|**`getParent()`**​|获取**父级目录的路径**。如果路径中没有父目录，则返回 `null`。|`String`|`f1.getParent()`|
|**`length()`**​|获取文件的**长度（大小）**，单位为**字节**。如果是目录，返回值是未定义的（通常为0）。|`long`|`f1.length()`|
|**`canRead()`**​|判断应用程序**是否可以读取**该文件。|`boolean`|`f1.canRead()`|
|**`canWrite()`**​|判断应用程序**是否可以修改**该文件。|`boolean`|`f1.canWrite()`|
|**`canExecute()`**​|判断应用程序**是否可以执行**该文件（例如，在操作系统层面是否为可执行程序）。|`boolean`|`f1.canExecute()`|
|**`lastModified()`**​|获取文件最后修改时间的**时间戳**（自1970年1月1日以来的毫秒数）。|`long`|`f1.lastModified()`|

### 💡 核心要点与进阶使用

- **`getPath()`vs `getAbsolutePath()`**：`getPath()`返回的是你创建 `File`对象时使用的路径，可能是相对路径（如 `"a.txt"`）；而 `getAbsolutePath()`总是返回一个从根目录开始的完整路径（如 `"I:\java\...\a.txt"`）。
    
- **`lastModified()`的格式化**：`lastModified()`返回的是一个长整型的时间戳，直接阅读不友好。通常需要配合 `SimpleDateFormat`进行格式化，才能显示为 `"yyyy-MM-dd HH:mm:ss"`这样的可读格式。
    
    ```
    long lastModified = f1.lastModified();
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    String formattedTime = sdf.format(new Date(lastModified));
    System.out.println("最后修改时间: " + formattedTime);
    ```
    
- **权限检查的重要性**：在对文件进行读写操作前，先使用 `canRead()`和 `canWrite()`方法检查权限，可以避免程序因权限不足而抛出异常，使代码更加健壮。
    
- **目录的大小**：`length()`方法对目录的返回值是未定义的（通常为0），不能用于获取目录及其包含文件的总大小。如果需要计算目录大小，需要递归遍历目录下的所有文件并累加它们的 `length()`。
    

希望这个整理能帮助你更好地掌握这些方法！如果你对如何遍历目录或过滤文件等其他文件操作感兴趣，我们可以继续探讨。