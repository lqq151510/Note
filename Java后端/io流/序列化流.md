序列化流是Java中用于**将对象转换为字节序列**，以便存储或传输的机制；反序列化则是其逆过程。下面这个表格能帮你快速抓住核心要素。

|核心组件|主要作用|关键方法|
|---|---|---|
|**`ObjectOutputStream`**​|将对象转换为字节流并输出（序列化）|`writeObject(Object obj)`|
|**`ObjectInputStream`**​|从字节流中读取并重建对象（反序列化）|`readObject()`|
|**`Serializable`接口**​|标记性接口，表示类的对象可被序列化|无方法|

### 🔌 核心概念与使用

- **序列化**：指将内存中的Java对象转换成二进制字节流的过程，从而可以保存到文件或通过网络传输。
    
- **反序列化**：将字节流恢复成Java对象的过程。
    

要实现序列化，对象所属的类必须实现 `java.io.Serializable`接口。这是一个**标记接口**，不含任何需要实现的方法，仅用于标识该类允许被序列化。

### 🛠️ 基本使用步骤

**1. 序列化对象（写入）**

使用 `ObjectOutputStream`将对象序列化后存入文件：

```
// 假设Person类已==实现Serializable接口==
Person person = new Person("张三", 25);

try (FileOutputStream fileOut = new FileOutputStream("person.ser");
     ObjectOutputStream out = new ObjectOutputStream(fileOut)) {
    out.writeObject(person); // 核心序列化操作
    System.out.println("对象已序列化并保存");
} catch (IOException e) {
    e.printStackTrace();
}
```

**2. 反序列化对象（读取）**

使用 `ObjectInputStream`从文件中读取并还原对象：

```
try (FileInputStream fileIn = new FileInputStream("person.ser");
     ObjectInputStream in = new ObjectInputStream(fileIn)) {
    Person restoredPerson = (Person) in.readObject(); // 核心反序列化操作，需要强制类型转换
    System.out.println("姓名: " + restoredPerson.getName()); // 输出：姓名: 张三
    System.out.println("年龄: " + restoredPerson.getAge());  // 输出：年龄: 25
} catch (IOException | ClassNotFoundException e) {
    e.printStackTrace();
}
```

### ⚠️ 关键注意事项

1. **`transient`关键字**
    
    如果对象的某些字段包含敏感信息或不需要序列化（如密码、临时计算结果），可以用 `transient`修饰。被修饰的字段在序列化时会被忽略，反序列化后获得其类型的默认值（如对象为 `null`，int为 `0`）。
    
    ```
    public class User implements Serializable {
        private String username;
        private transient String password; // 此字段不会被序列化
    }
    ```
    
2. **`serialVersionUID`的重要性**
    
    它相当于类的序列化版本号。如果序列化后类结构发生变化（如增删字段），且未显式定义 `serialVersionUID`，反序列化可能因版本号不匹配而失败，抛出 `InvalidClassException`。**显式声明**可避免此问题：
    
    ```
    public class YourBean implements Serializable {
        private static final long serialVersionUID = 1L; // 显式声明版本UID
        // ... 其他字段和方法
    }
    ```
    
3. **安全性与性能**
    
    - **安全风险**：不要随意反序列化来自不可信来源的字节流，这可能执行恶意代码。
        
    - **性能考量**：序列化与反序列化有开销。在需要高性能的场景，可考虑JSON、Protocol Buffers等替代方案。
        
    

### 💎 总结

序列化流的核心价值在于实现对象的**持久化存储**与**网络传输**。使用时牢记三点：类必须实现 `Serializable`、善用 `transient`关键字、显式定义 `serialVersionUID`。

希望这些解释能帮助你掌握Java序列化流。如果你对特定场景下的序列化应用（如深克隆、网络通信）有进一步兴趣，我们可以继续探讨。