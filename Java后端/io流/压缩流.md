Java 中的压缩流用于将数据压缩成更小的体积以便存储或传输，主要处理 ZIP 和 GZIP 等格式。下面这个表格汇总了核心的压缩流类，帮助你快速建立整体认知。

|类别|核心类|功能描述|
|---|---|---|
|**压缩流**​|`ZipOutputStream`|将数据压缩为ZIP格式，支持将多个文件/目录打包到一个压缩包中。|
||`GZIPOutputStream`|将数据压缩为GZIP格式，通常用于压缩单个数据流或文件。|
|**解压缩流**​|`ZipInputStream`|读取ZIP格式的压缩包，并可解压其中的各个条目（文件/目录）。|
||`GZIPInputStream`|读取GZIP格式的压缩文件并将其解压。|
|**辅助类**​|`ZipEntry`|代表ZIP压缩包中的一个文件或目录，是操作的基本单元。|

### 🔧 核心压缩流详解

#### 1. ZipOutputStream

`ZipOutputStream`用于创建ZIP格式的压缩文件。它的核心在于使用 `ZipEntry`对象来代表压缩包中的每一个文件或目录。

**基本使用步骤：**

1. 创建一个 `ZipOutputStream`对象，并关联到目标压缩文件。
    
2. 遍历需要压缩的文件。
    
3. 对于每个文件，先调用 `putNextEntry(ZipEntry entry)`方法放入一个新的 `ZipEntry`，这相当于在压缩包里“创建”了一个文件。
    
4. 然后将原文件的内容写入到 `ZipOutputStream`中。
    
5. 一个文件写入完毕后，调用 `closeEntry()`方法关闭当前条目。
    
6. 所有文件处理完成后，关闭流。
    

```
// 压缩单个文件的示例
try (FileOutputStream fos = new FileOutputStream("archive.zip");
     ZipOutputStream zos = new ZipOutputStream(fos);
     FileInputStream fis = new FileInputStream("document.txt")) {

    // 创建ZipEntry，并指定其在压缩包内的名称
    ZipEntry entry = new ZipEntry("document.txt");
    zos.putNextEntry(entry);

    // 将文件内容写入压缩流
    byte[] buffer = new byte[1024];
    int length;
    while ((length = fis.read(buffer)) > 0) {
        zos.write(buffer, 0, length);
    }
    zos.closeEntry(); // 关闭当前条目
    System.out.println("文件压缩完成。");
} catch (IOException e) {
    e.printStackTrace();
}
```

如果需要压缩整个文件夹，需要使用递归来遍历所有子目录和文件，为每个文件创建对应的 `ZipEntry`，并注意维护压缩包内的路径结构。

#### 2. GZIPOutputStream

`GZIPOutputStream`用于GZIP格式压缩，通常针对单个文件或数据流。它的API比ZIP更简单，因为不涉及多文件管理。

```
// 使用GZIP压缩单个文件
try (FileInputStream fis = new FileInputStream("log.txt");
     FileOutputStream fos = new FileOutputStream("log.gz");
     GZIPOutputStream gzos = new GZIPOutputStream(fos)) {

    byte[] buffer = new byte[1024];
    int len;
    while ((len = fis.read(buffer)) != -1) {
        gzos.write(buffer, 0, len);
    }
    System.out.println("GZIP压缩完成。");
} catch (IOException e) {
    e.printStackTrace();
}
```

### 📥 对应的解压缩流

有压缩自然需要解压缩。`ZipInputStream`和 `GZIPInputStream`是上述压缩流的对应解压工具。

- **`ZipInputStream`**：通过循环调用 `getNextEntry()`方法，可以逐个获取压缩包内的 `ZipEntry`，然后读取每个条目的数据并写入到目标文件，从而完成解压。
    
- **`GZIPInputStream`**：包装在已压缩的输入流外，读取其数据时会自动解压，恢复原始内容。
    

### 💡 核心要点与最佳实践

1. **理解 ZipEntry**：操作ZIP格式时，`ZipEntry`是关键。它代表了压缩包内的一个项目（文件或空目录）。压缩时，需要为每个文件创建 `ZipEntry`；解压时，则通过 `ZipEntry`判断当前处理的是文件还是目录。
    
2. **使用缓冲提升性能**：在处理文件时，特别是大文件，建议使用 `BufferedInputStream`和 `BufferedOutputStream`包装底层流，可以显著减少I/O操作次数，提高效率。
    
3. **管理资源**：压缩和解压操作涉及多个流对象，务必使用 **try-with-resources**​ 语句来确保流被正确关闭，避免资源泄漏。
    
4. **处理目录结构**：压缩文件夹时，需要正确构建 `ZipEntry`的名称以反映相对路径。解压时，则需要根据 `ZipEntry`的名称在目标位置创建相应的目录结构。
    

### ⚖️ 主要应用场景

压缩流在以下场景中非常有用：

- **文件备份**：将多个文件或目录打包压缩成一个文件，便于备份和转移。
    
- **网络传输**：压缩数据后再传输，可以减少网络带宽占用，加快传输速度。
    
- **数据存档**：将一些不常用但需要保留的数据压缩存档，以节省存储空间。
    

希望这份梳理能帮助你掌握Java中的压缩流。如果你想了解特定压缩格式的更多细节，或者有具体的应用场景，我们可以继续探讨。