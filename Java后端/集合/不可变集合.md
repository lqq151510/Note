在Java中，**不可变集合**指的是**一旦被创建，其内容（包括元素的数量、值以及顺序）就再也无法被修改**的集合。任何尝试对其进行添加、删除或更新元素的操作都会抛出 `UnsupportedOperationException`异常。

下面这个表格清晰地对比了三种主要的创建方式，帮助你快速把握它们的核心区别。

|特性对比|`Collections.unmodifiableXxx()`|JDK 9+ 的 `of()`/ `copyOf()`方法|Guava 不可变集合|
|---|---|---|---|
|**本质**​|原始集合的**“只读视图”**​|**真正独立**的不可变集合|**真正独立**的不可变集合，功能丰富|
|**底层依赖**​|依赖原始集合，原始集合修改会导致视图变化|不依赖任何外部集合，完全独立|不依赖任何外部集合，完全独立|
|**安全性**​|较低，需确保原始引用不被修改|**高**，创建后完全不可变|**高**，创建后完全不可变|
|**对 `null`值的支持**​|取决于原始集合|**不支持**，会抛出 `NullPointerException`|**不支持**​|
|**适用版本**​|Java 2+|Java 9+|需引入第三方 Guava 库|

### 💡 如何选择？

- **新项目（Java 9+）**：优先使用 **`List.of()`, `Set.of()`, `Map.of()`**​ 以及 **`List.copyOf()`**​ 等方法。它们是现代Java开发的首选，语法简洁且安全性最高。
    
- **遗留项目或需要兼容低版本JDK**：使用 `Collections.unmodifiableXxx()`，但务必记得**先复制数据**（如 `new ArrayList<>(originalList)`）再包装，以确保真正的不可变性。
    
- **需要更丰富的构建API或高级功能**：考虑引入 **Google Guava**​ 库，它的 `ImmutableList`, `ImmutableSet`等类提供了非常灵活的构建器（Builder）和更多的实用方法。
    
   List:直接用
   Set：元素不能重复
   Map：元素不能重复，键值对最多10对，超过使用ofEntries方法
### 🔒 核心优势与适用场景

不可变集合的核心优势在于：

- **线程安全**：因为不可变，所以多个线程可以同时读取它，而无需任何额外的同步开销，非常安全。
    
- **防御性编程**：当你的类需要向外部返回一个内部集合的引用时，返回一个不可变集合可以防止调用方意外修改你的内部数据，从而保护程序的内部状态。
    
- **作为常量**：非常适合用来表示一组固定的、不应改变的值，比如配置项、状态码等。
    

### ⚠️ 注意事项

- **性能权衡**：在需要频繁修改集合内容的场景下，不可变集合可能不是最佳选择，因为每次“修改”实际上都需要创建一个新的集合实例。
    
- **元素本身是否可变**：不可变集合保证的是集合**本身的结构**（即包含哪些元素）不可变，但如果集合中存放的是可变对象，这些对象内部的状态仍然是可以改变的。
    

希望这些解释能帮助你更好地理解和使用Java中的不可变集合。如果你有特定的使用场景，我可以提供更具体的建议。