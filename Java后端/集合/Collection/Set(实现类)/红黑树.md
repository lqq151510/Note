# 红黑树详解：从规则到插入处理

红黑树是一种高效的自平衡二叉搜索树，在Java的TreeMap、TreeSet等集合类中广泛应用。下面这个表格总结了红黑树的核心特性：

|特性|描述|优势|
|---|---|---|
|**平衡性**​|近似平衡的二叉搜索树，最长路径不超过最短路径的2倍|保证基本操作 O(log n) 时间复杂度|
|**旋转频率**​|相比AVL树，旋转操作较少|插入/删除性能更优|
|**存储开销**​|每个节点需要1位存储颜色（红/黑）|空间效率高|
|**实现复杂度**​|比AVL树复杂，但比完全平衡树简单|工程实践中的良好权衡|

## 一、红黑树的五条核心规则

红黑树必须满足以下五个性质：

1. **节点是红色或黑色**
    
2. **根节点是黑色**
    
3. **所有叶子节点（NIL节点）是黑色**
    
4. **红色节点的两个子节点都是黑色**（不能有连续的红色节点）
    
5. **从任一节点到其每个叶子节点的所有路径包含相同数量的黑色节点**
    

下面的流程图展示了红黑树规则的检查顺序和相互关系：

```
flowchart TD
    A[开始检查红黑树规则] --> B{规则1: 节点颜色?}
    B -->|红或黑| C{规则2: 根节点?}
    B -->|其他颜色| Z[违反规则1]
    
    C -->|黑色| D{规则3: 叶子节点?}
    C -->|红色| Z[违反规则2]
    
    D -->|黑色(NIL)| E{规则4: 红色节点子节点?}
    D -->|非黑色| Z[违反规则3]
    
    E -->|都是黑色| F{规则5: 黑色节点数?}
    E -->|有红色子节点| Z[违反规则4]
    
    F -->|所有路径相等| G[红黑树有效]
    F -->|不相等| Z[违反规则5]
```

## 二、红黑树节点结构

```
// 红黑树节点定义
class RBNode<K extends Comparable<K>, V> {
    K key;           // 键
    V value;         // 值
    RBNode<K, V> left;   // 左子节点
    RBNode<K, V> right;  // 右子节点
    RBNode<K, V> parent; // 父节点
    boolean color;       // 颜色：true=红色, false=黑色
    
    public RBNode(K key, V value) {
        this.key = key;
        this.value = value;
        this.color = true;  // 新插入的节点默认为红色
    }
    
    // 获取兄弟节点
    public RBNode<K, V> getSibling() {
        if (parent == null) return null;
        return isLeftChild() ? parent.right : parent.left;
    }
    
    // 判断是否为左子节点
    public boolean isLeftChild() {
        return parent != null && this == parent.left;
    }
    
    // 判断是否为右子节点
    public boolean isRightChild() {
        return parent != null && this == parent.right;
    }
}
```

## 三、红黑树插入处理方案

当插入新节点时，可能会违反红黑树规则。以下是处理插入后的各种情况：

### 情况0：空树

```
if (root == null) {
    root = newNode;
    root.color = BLACK;  // 根节点必须是黑色
    return;
}
```

### 情况1：父节点是黑色

- 直接插入，不影响平衡
    
- 满足所有红黑树规则
    

### 情况2：父节点是红色

父节点是红色时，需要根据叔叔节点的颜色和位置进行调整。下图展示了完整的插入后修复流程：

```
flowchart TD
    Start[插入新节点N<br>颜色为红色] --> A{父节点P颜色?}
    
    A -->|黑色| B[情况1: 直接插入<br>满足所有规则]
    
    A -->|红色| C{叔叔节点U颜色?}
    
    C -->|红色| D[情况2: 重新着色<br>P和U变黑, G变红<br>G作为新N递归处理]
    
    C -->|黑色或null| E{插入节点N与<br>父节点P、祖父节点G的位置?}
    
    E -->|N是P的左子, P是G的左子<br>LL型| F[情况3-LL: 右旋转<br>P和G变色]
    E -->|N是P的右子, P是G的右子<br>RR型| G[情况3-RR: 左旋转<br>P和G变色]
    E -->|N是P的右子, P是G的左子<br>LR型| H[情况3-LR: 先左旋P再右旋G<br>N和G变色]
    E -->|N是P的左子, P是G的右子<br>RL型| I[情况3-RL: 先右旋P再左旋G<br>N和G变色]
    
    B --> End[完成]
    D --> J{祖父节点G是根?}
    J -->|是| K[G变黑]
    J -->|否| D
    F --> End
    G --> End
    H --> End
    I --> End
    K --> End
```

下面是每种情况的具体代码实现：

#### 情况2：叔叔节点是红色

```
private void fixInsertCase2(RBNode<K, V> node) {
    // 父节点和叔叔节点都变为黑色
    node.parent.color = BLACK;
    RBNode<K, V> uncle = getUncle(node);
    if (uncle != null) {
        uncle.color = BLACK;
    }
    
    // 祖父节点变为红色
    RBNode<K, V> grandparent = getGrandparent(node);
    grandparent.color = RED;
    
    // 递归处理祖父节点
    fixInsert(grandparent);
}
```

#### 情况3-LL：左左情况

```
private void fixInsertCase3LL(RBNode<K, V> node) {
    /*
        祖父(G) - 黑色        父(P) - 黑色
           /                     / \
        父(P) - 红色    →      N - 红色   G - 红色
         /
       N - 红色
    */
    RBNode<K, V> parent = node.parent;
    RBNode<K, V> grandparent = parent.parent;
    
    // 1. 右旋转
    rotateRight(grandparent);
    
    // 2. 重新着色
    parent.color = BLACK;
    grandparent.color = RED;
}
```

#### 情况3-RR：右右情况

```
private void fixInsertCase3RR(RBNode<K, V> node) {
    /*
        祖父(G) - 黑色             父(P) - 黑色
            \                     / \
            父(P) - 红色    →    G - 红色   N - 红色
             \
             N - 红色
    */
    RBNode<K, V> parent = node.parent;
    RBNode<K, V> grandparent = parent.parent;
    
    // 1. 左旋转
    rotateLeft(grandparent);
    
    // 2. 重新着色
    parent.color = BLACK;
    grandparent.color = RED;
}
```

#### 情况3-LR：左右情况

```
private void fixInsertCase3LR(RBNode<K, V> node) {
    /*
        祖父(G) - 黑色         N - 黑色
           /                   / \
        父(P) - 红色    →    P - 红色   G - 红色
           \
           N - 红色
    */
    RBNode<K, V> parent = node.parent;
    RBNode<K, V> grandparent = parent.parent;
    
    // 1. 先对父节点左旋转
    rotateLeft(parent);
    
    // 2. 再对祖父节点右旋转
    rotateRight(grandparent);
    
    // 3. 重新着色
    node.color = BLACK;
    grandparent.color = RED;
}
```

#### 情况3-RL：右左情况

```
private void fixInsertCase3RL(RBNode<K, V> node) {
    /*
        祖父(G) - 黑色         N - 黑色
            \                / \
            父(P) - 红色 →  G - 红色   P - 红色
            /
          N - 红色
    */
    RBNode<K, V> parent = node.parent;
    RBNode<K, V> grandparent = parent.parent;
    
    // 1. 先对父节点右旋转
    rotateRight(parent);
    
    // 2. 再对祖父节点左旋转
    rotateLeft(grandparent);
    
    // 3. 重新着色
    node.color = BLACK;
    grandparent.color = RED;
}
```

## 四、完整红黑树实现

```
public class RedBlackTree<K extends Comparable<K>, V> {
    private static final boolean RED = true;
    private static final boolean BLACK = false;
    
    private RBNode<K, V> root;
    
    // 旋转操作
    private void rotateLeft(RBNode<K, V> node) {
        RBNode<K, V> rightChild = node.right;
        
        // 1. 处理node的右子节点
        node.right = rightChild.left;
        if (rightChild.left != null) {
            rightChild.left.parent = node;
        }
        
        // 2. 处理rightChild的父节点
        rightChild.parent = node.parent;
        if (node.parent == null) {
            root = rightChild;
        } else if (node == node.parent.left) {
            node.parent.left = rightChild;
        } else {
            node.parent.right = rightChild;
        }
        
        // 3. 建立node和rightChild的关系
        rightChild.left = node;
        node.parent = rightChild;
    }
    
    private void rotateRight(RBNode<K, V> node) {
        RBNode<K, V> leftChild = node.left;
        
        // 1. 处理node的左子节点
        node.left = leftChild.right;
        if (leftChild.right != null) {
            leftChild.right.parent = node;
        }
        
        // 2. 处理leftChild的父节点
        leftChild.parent = node.parent;
        if (node.parent == null) {
            root = leftChild;
        } else if (node == node.parent.left) {
            node.parent.left = leftChild;
        } else {
            node.parent.right = leftChild;
        }
        
        // 3. 建立node和leftChild的关系
        leftChild.right = node;
        node.parent = leftChild;
    }
    
    // 插入操作
    public void insert(K key, V value) {
        RBNode<K, V> newNode = new RBNode<>(key, value);
        
        // 1. 标准BST插入
        if (root == null) {
            root = newNode;
        } else {
            RBNode<K, V> current = root;
            RBNode<K, V> parent = null;
            
            while (current != null) {
                parent = current;
                int cmp = key.compareTo(current.key);
                if (cmp < 0) {
                    current = current.left;
                } else if (cmp > 0) {
                    current = current.right;
                } else {
                    // 键已存在，更新值
                    current.value = value;
                    return;
                }
            }
            
            newNode.parent = parent;
            int cmp = key.compareTo(parent.key);
            if (cmp < 0) {
                parent.left = newNode;
            } else {
                parent.right = newNode;
            }
        }
        
        // 2. 修复红黑树性质
        fixInsert(newNode);
        
        // 3. 确保根节点为黑色
        root.color = BLACK;
    }
    
    // 插入修复
    private void fixInsert(RBNode<K, V> node) {
        while (node != root && node.parent.color == RED) {
            if (node.parent == node.parent.parent.left) {
                // 父节点是祖父节点的左子节点
                RBNode<K, V> uncle = node.parent.parent.right;
                
                if (uncle != null && uncle.color == RED) {
                    // 情况2：叔叔节点是红色
                    node.parent.color = BLACK;
                    uncle.color = BLACK;
                    node.parent.parent.color = RED;
                    node = node.parent.parent;
                } else {
                    if (node == node.parent.right) {
                        // 情况3-LR：左右情况
                        node = node.parent;
                        rotateLeft(node);
                    }
                    // 情况3-LL：左左情况
                    node.parent.color = BLACK;
                    node.parent.parent.color = RED;
                    rotateRight(node.parent.parent);
                }
            } else {
                // 父节点是祖父节点的右子节点
                RBNode<K, V> uncle = node.parent.parent.left;
                
                if (uncle != null && uncle.color == RED) {
                    // 情况2：叔叔节点是红色
                    node.parent.color = BLACK;
                    uncle.color = BLACK;
                    node.parent.parent.color = RED;
                    node = node.parent.parent;
                } else {
                    if (node == node.parent.left) {
                        // 情况3-RL：右左情况
                        node = node.parent;
                        rotateRight(node);
                    }
                    // 情况3-RR：右右情况
                    node.parent.color = BLACK;
                    node.parent.parent.color = RED;
                    rotateLeft(node.parent.parent);
                }
            }
        }
        
        root.color = BLACK;
    }
    
    // 辅助方法
    private RBNode<K, V> getUncle(RBNode<K, V> node) {
        if (node.parent == null || node.parent.parent == null) {
            return null;
        }
        
        if (node.parent == node.parent.parent.left) {
            return node.parent.parent.right;
        } else {
            return node.parent.parent.left;
        }
    }
    
    private RBNode<K, V> getGrandparent(RBNode<K, V> node) {
        if (node.parent == null) {
            return null;
        }
        return node.parent.parent;
    }
    
    // 中序遍历
    public void inOrderTraversal() {
        inOrderRecursive(root);
        System.out.println();
    }
    
    private void inOrderRecursive(RBNode<K, V> node) {
        if (node != null) {
            inOrderRecursive(node.left);
            System.out.print(node.key + "(" + (node.color ? "红" : "黑") + ") ");
            inOrderRecursive(node.right);
        }
    }
    
    // 验证红黑树性质
    public boolean isValid() {
        if (root == null) return true;
        
        // 规则2：根节点必须是黑色
        if (root.color != BLACK) {
            System.out.println("违反规则2：根节点不是黑色");
            return false;
        }
        
        // 检查所有路径的黑色节点数
        int blackCount = checkBlackCount(root);
        return blackCount != -1;
    }
    
    private int checkBlackCount(RBNode<K, V> node) {
        if (node == null) return 1;  // NIL叶子节点视为黑色
        
        // 检查左子树
        int leftBlackCount = checkBlackCount(node.left);
        if (leftBlackCount == -1) return -1;
        
        // 检查右子树
        int rightBlackCount = checkBlackCount(node.right);
        if (rightBlackCount == -1) return -1;
        
        // 规则5：左右子树黑色节点数必须相同
        if (leftBlackCount != rightBlackCount) {
            System.out.println("违反规则5：黑色节点数不同");
            return -1;
        }
        
        // 规则4：红色节点的子节点必须是黑色
        if (node.color == RED) {
            if ((node.left != null && node.left.color == RED) ||
                (node.right != null && node.right.color == RED)) {
                System.out.println("违反规则4：红色节点有红色子节点");
                return -1;
            }
        }
        
        // 返回当前子树的黑色节点数
        return leftBlackCount + (node.color == BLACK ? 1 : 0);
    }
}
```

## 五、测试示例

```
public class RedBlackTreeExample {
    public static void main(String[] args) {
        RedBlackTree<Integer, String> rbTree = new RedBlackTree<>();
        
        System.out.println("插入顺序: 10, 20, 30, 15, 25, 5, 8");
        
        // 测试插入
        int[] keys = {10, 20, 30, 15, 25, 5, 8};
        for (int key : keys) {
            rbTree.insert(key, "Value-" + key);
            System.out.print("插入 " + key + " 后: ");
            rbTree.inOrderTraversal();
            
            // 验证红黑树性质
            if (!rbTree.isValid()) {
                System.out.println("插入 " + key + " 后违反红黑树规则！");
                break;
            }
        }
        
        System.out.println("\n最终红黑树验证: " + (rbTree.isValid() ? "通过" : "失败"));
        
        // 演示各种情况
        System.out.println("\n=== 红黑树插入情况示例 ===");
        
        // 情况1：父节点是黑色
        System.out.println("情况1示例：");
        RedBlackTree<Integer, String> tree1 = new RedBlackTree<>();
        tree1.insert(10, "A");  // 根节点，自动变黑
        tree1.insert(5, "B");   // 父节点(10)是黑色，直接插入红色
        System.out.print("树1: ");
        tree1.inOrderTraversal();
        
        // 情况2：叔叔节点是红色
        System.out.println("\n情况2示例：");
        RedBlackTree<Integer, String> tree2 = new RedBlackTree<>();
        tree2.insert(10, "A");  // 根(黑)
        tree2.insert(5, "B");   // 红
        tree2.insert(15, "C");  // 红
        tree2.insert(3, "D");   // 触发情况2
        System.out.print("树2: ");
        tree2.inOrderTraversal();
        
        // 情况3-LL：左左
        System.out.println("\n情况3-LL示例：");
        RedBlackTree<Integer, String> tree3 = new RedBlackTree<>();
        tree3.insert(10, "A");  // 根(黑)
        tree3.insert(5, "B");   // 红
        tree3.insert(3, "C");   // 触发情况3-LL
        System.out.print("树3: ");
        tree3.inOrderTraversal();
        
        // 情况3-RR：右右
        System.out.println("\n情况3-RR示例：");
        RedBlackTree<Integer, String> tree4 = new RedBlackTree<>();
        tree4.insert(10, "A");  // 根(黑)
        tree4.insert(15, "B");  // 红
        tree4.insert(20, "C");  // 触发情况3-RR
        System.out.print("树4: ");
        tree4.inOrderTraversal();
    }
}
```

## 六、红黑树与AVL树的对比

|特性|AVL树|红黑树|
|---|---|---|
|**平衡标准**​|严格平衡（高度差≤1）|近似平衡（最长路径≤2×最短路径）|
|**查找效率**​|更高（O(log n)，常数因子小）|稍低（但也是O(log n)）|
|**插入/删除**​|需要更多旋转（最多O(log n)次）|需要较少旋转（最多3次）|
|**旋转类型**​|4种（LL, RR, LR, RL）|2种（左旋、右旋）组合使用|
|**存储开销**​|每个节点存储高度（整数）|每个节点存储颜色（1位）|
|**适用场景**​|查找密集型（如数据库索引）|插入/删除频繁（如Java集合类）|

## 七、Java中的红黑树实现

Java的`TreeMap`和`TreeSet`内部使用红黑树实现：

```
import java.util.TreeMap;
import java.util.Map;

public class JavaRedBlackTreeExample {
    public static void main(String[] args) {
        // TreeMap内部使用红黑树
        TreeMap<Integer, String> treeMap = new TreeMap<>();
        
        treeMap.put(10, "Apple");
        treeMap.put(5, "Banana");
        treeMap.put(15, "Cherry");
        treeMap.put(3, "Date");
        treeMap.put(7, "Elderberry");
        treeMap.put(12, "Fig");
        treeMap.put(18, "Grape");
        
        System.out.println("TreeMap内容（按键排序）：");
        for (Map.Entry<Integer, String> entry : treeMap.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        System.out.println("\n第一个键: " + treeMap.firstKey());
        System.out.println("最后一个键: " + treeMap.lastKey());
        System.out.println("大于等于8的最小键: " + treeMap.ceilingKey(8));
        System.out.println("小于等于8的最大键: " + treeMap.floorKey(8));
        
        // 验证TreeMap的性能
        long startTime = System.nanoTime();
        for (int i = 0; i < 10000; i++) {
            treeMap.put(i, "Value" + i);
        }
        long endTime = System.nanoTime();
        System.out.println("\n插入10000个元素耗时: " + (endTime - startTime) / 1000000.0 + "ms");
    }
}
```

## 八、红黑树应用场景

1. **Java集合框架**：`TreeMap`、`TreeSet`、`ConcurrentSkipListMap`
    
2. **Linux内核**：进程调度、内存管理
    
3. **C++ STL**：`map`、`multimap`、`set`、`multiset`
    
4. **数据库系统**：B+树索引的基础
    
5. **网络路由**：路由表管理
    

## 总结

红黑树通过以下机制保持近似平衡：

1. **颜色规则**：确保没有连续的红色节点
    
2. **黑色高度规则**：确保从任意节点到叶子节点的路径包含相同数量的黑色节点
    
3. **旋转与重新着色**：插入/删除时通过最多3次旋转和重新着色恢复平衡
    

红黑树的优势在于：

- 插入/删除操作最多需要3次旋转
    
- 查找、插入、删除的时间复杂度均为O(log n)
    
- 适合需要频繁更新的场景
    

相比AVL树，红黑树在旋转次数和平衡严格性之间取得了更好的平衡，这也是为什么许多标准库（如Java的`TreeMap`）选择红黑树作为底层实现的原因。