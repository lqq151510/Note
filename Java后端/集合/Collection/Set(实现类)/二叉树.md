# Java 中的树、二叉树和平衡二叉树（含旋转机制）

下面这个表格对比了树、二叉树和平衡二叉树的核心特性：

|特性|树 (Tree)|二叉树 (Binary Tree)|平衡二叉树 (Balanced Binary Tree)|
|---|---|---|---|
|**定义**​|非线性数据结构，由节点和边组成，每个节点有零个或多个子节点|每个节点最多有两个子节点（左/右子节点）|特殊的二叉搜索树，任意节点的左右子树高度差 ≤ 1|
|**结构**​|任意结构，无子节点数限制|严格最多2个子节点|二叉树结构 + 平衡约束|
|**遍历方式**​|前序、后序、层序|前序、中序、后序、层序|同上，但搜索效率更高|
|**时间复杂度**​|取决于具体类型|普通二叉树：O(n)|搜索/插入/删除：O(log n)|
|**常见类型**​|普通树、B树、B+树、Trie树|普通二叉树、二叉搜索树、满二叉树、完全二叉树|AVL树、红黑树、伸展树|
|**应用场景**​|文件系统、数据库索引、XML/HTML解析|表达式树、哈夫曼编码、搜索算法|数据库索引、集合类（TreeMap、TreeSet）、内存分配|

## 1. 树 (Tree)

### 基本概念

树是一种分层的数据结构，由节点（node）和边（edge）组成：

- **根节点**：没有父节点的节点
    
- **子节点/父节点**：节点之间的关系
    
- **叶子节点**：没有子节点的节点
    
- **深度/高度**：从根到节点的边数/从节点到最远叶子的边数
    

### Java 实现

```
// 通用树节点定义
class TreeNode<T> {
    T data;
    List<TreeNode<T>> children;
    
    public TreeNode(T data) {
        this.data = data;
        this.children = new ArrayList<>();
    }
    
    public void addChild(TreeNode<T> child) {
        children.add(child);
    }
}

// 树的基本操作
class Tree<T> {
    private TreeNode<T> root;
    
    public Tree(T rootData) {
        root = new TreeNode<>(rootData);
    }
    
    // 前序遍历
    public void preOrderTraversal(TreeNode<T> node) {
        if (node == null) return;
        
        System.out.print(node.data + " ");
        for (TreeNode<T> child : node.children) {
            preOrderTraversal(child);
        }
    }
    
    // 后序遍历
    public void postOrderTraversal(TreeNode<T> node) {
        if (node == null) return;
        
        for (TreeNode<T> child : node.children) {
            postOrderTraversal(child);
        }
        System.out.print(node.data + " ");
