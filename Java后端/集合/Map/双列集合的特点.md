Java中的**双列集合**特指实现了`Map`接口的集合，用于存储**键值对（Key-Value）**数据。以下是其主要特点：

## 1. **核心结构：键值对**

- 每个元素由**键（Key）**和**值（Value）**组成
    
- 格式：`Key → Value`的映射关系
    
- 键和值可以是任意对象类型
    

## 2. **键的唯一性**

- **键不能重复**，每个键最多映射到一个值
    
- 如果添加重复的键，新值会**覆盖**旧值
    
- 值可以重复，不同键可以对应相同的值
    

```
Map<String, Integer> map = new HashMap<>();
map.put("Alice", 90);  // 添加
map.put("Alice", 95);  // 覆盖，键"Alice"的值变为95
```

## 3. **主要实现类对比**

|实现类|数据结构|线程安全|键顺序|允许null|特点|
|---|---|---|---|---|---|
|**HashMap**​|数组+链表/红黑树|否|无序|键值都可null|最常用，查询O(1)|
|**LinkedHashMap**​|链表+哈希表|否|插入顺序/访问顺序|键值都可null|保持插入顺序|
|**TreeMap**​|红黑树|否|键的自然/自定义排序|键不能null|自动排序|
|**Hashtable**​|数组+链表|是|无序|键值都不能null|遗留的线程安全类|
|**ConcurrentHashMap**​|分段锁+CAS|是|无序|键值都不能null|高并发推荐|

## 4. **常用方法**

```
Map<String, String> map = new HashMap<>();

// 添加/修改
map.put("key1", "value1");
map.putIfAbsent("key1", "value2");  // 不存在才添加

// 获取
String value = map.get("key1");
String orDefault = map.getOrDefault("key3", "默认值");

// 删除
map.remove("key1");
map.remove("key1", "value1");  // 键值都匹配才删除

// 判断
boolean hasKey = map.containsKey("key1");
boolean hasValue = map.containsValue("value1");
boolean isEmpty = map.isEmpty();

// 遍历
for (Map.Entry<String, String> entry : map.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}

// 获取视图
Set<String> keys = map.keySet();      // 所有键
Collection<String> values = map.values();  // 所有值
Set<Map.Entry<String, String>> entries = map.entrySet();  // 所有键值对
```

## 5. **遍历方式**

```
Map<String, Integer> scores = new HashMap<>();
scores.put("Alice", 90);
scores.put("Bob", 85);

// 1. 键值对遍历（推荐）
for (Map.Entry<String, Integer> entry : scores.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}

// 2. 先获取键，再获取值
for (String key : scores.keySet()) {
    System.out.println(key + ": " + scores.get(key));
}

// 3. 只遍历值
for (Integer score : scores.values()) {
    System.out.println(score);
}

// 4. 使用forEach+Lambda（Java 8+）
scores.forEach((key, value) -> 
    System.out.println(key + ": " + value));
```

## 6. **适用场景**

- **HashMap**：最常用，适合大多数键值对存储场景
    
- **LinkedHashMap**：需要保持插入顺序或访问顺序（如LRU缓存）
    
- **TreeMap**：需要按键排序，或进行范围查找
    
- **ConcurrentHashMap**：高并发环境下的线程安全需求
    
- **Hashtable**：遗留代码，不推荐在新代码中使用
    

## 7. **注意事项**

1. **线程安全性**：
    
    - 大部分Map实现**非线程安全**
        
    - 多线程环境可使用：
        
        - `Collections.synchronizedMap(new HashMap<>())`
            
        - `ConcurrentHashMap`（推荐）
            
        
    
2. **性能考虑**：
    
    - HashMap初始容量和负载因子影响性能
        
    - 合理实现键对象的`hashCode()`和`equals()`方法
        
    
3. **特殊Map实现**：
    
    - **WeakHashMap**：弱引用键，适合缓存
        
    - **IdentityHashMap**：使用`==`而不是`equals()`比较键
        
    - **EnumMap**：键为枚举类型，性能高
        
    

双列集合是Java集合框架中非常重要的一环，合理选择和使用Map实现类能显著提高程序效率和代码质量。