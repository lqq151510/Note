MyBatis Plus 在提供强大条件构造器的同时，也完全支持自定义 SQL，以满足复杂查询、多表关联、批量操作等高级需求。自定义 SQL 主要有以下几种实现方式，你可以根据具体场景选择。

### 一、注解方式（最简单直接）

直接在 Mapper 接口的方法上使用 `@Select`、`@Update`、`@Insert`、`@Delete`等注解编写 SQL。

**1. 基础查询**

```
@Mapper
public interface UserMapper extends BaseMapper<User> {
    // 根据ID查询
    @Select("SELECT * FROM user WHERE id = #{id}")
    User selectByIdCustom(Long id);
    
    // 带条件参数
    @Select("SELECT * FROM user WHERE name LIKE CONCAT('%', #{name}, '%') AND age > #{age}")
    List<User> selectByNameAndAge(@Param("name") String name, @Param("age") Integer age);
}
```

**2. 更新/插入操作**

```
@Update("UPDATE user SET name = #{name}, age = #{age} WHERE id = #{id}")
int updateUserCustom(@Param("id") Long id, @Param("name") String name, @Param("age") Integer age);

@Insert("INSERT INTO user (name, age, email) VALUES (#{user.name}, #{user.age}, #{user.email})")
int insertUserCustom(@Param("user") User user);
```

**3. 动态 SQL（使用 `<script>`标签）**

对于稍复杂的条件判断，可以在注解中使用 `<script>`标签。

```
@Select("<script>" +
        "SELECT * FROM user " +
        "WHERE 1=1 " +
        "<if test='name != null'> AND name LIKE CONCAT('%', #{name}, '%') </if>" +
        "<if test='age != null'> AND age > #{age} </if>" +
        "</script>")
List<User> selectByCondition(@Param("name") String name, @Param("age") Integer age);
```

### 二、XML 映射文件方式（最灵活，推荐用于复杂SQL）

这是 MyBatis 原生的方式，MyBatis Plus 完全兼容。将 SQL 写在 XML 文件中，适合编写多表关联、复杂动态 SQL。

**1. 创建 XML 文件（如 `UserMapper.xml`）**

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.mapper.UserMapper">
    <!-- 自定义查询 -->
    <select id="selectCustom" resultType="com.example.entity.User">
        SELECT id, name, age FROM user WHERE status = #{status}
    </select>
    
    <!-- 动态SQL示例 -->
    <select id="selectByDynamicCondition" resultType="User">
        SELECT * FROM user
        <where>
            <if test="name != null and name != ''">
                AND name LIKE CONCAT('%', #{name}, '%')
            </if>
            <if test="minAge != null">
                AND age >= #{minAge}
            </if>
            <if test="maxAge != null">
                AND age &lt;= #{maxAge}
            </if>
            <if test="statusList != null and statusList.size() > 0">
                AND status IN
                <foreach collection="statusList" item="status" open="(" separator="," close=")">
                    #{status}
                </foreach>
            </if>
        </where>
        ORDER BY create_time DESC
    </select>
    
    <!-- 批量更新 -->
    <update id="updateBatch">
        <foreach collection="list" item="item" separator=";">
            UPDATE user
            SET name = #{item.name}, age = #{item.age}
            WHERE id = #{item.id}
        </foreach>
    </update>
</mapper>
```

**2. Mapper 接口中声明对应方法**

```
public interface UserMapper extends BaseMapper<User> {
    List<User> selectCustom(@Param("status") Integer status);
    List<User> selectByDynamicCondition(@Param("name") String name, 
                                        @Param("minAge") Integer minAge,
                                        @Param("maxAge") Integer maxAge,
                                        @Param("statusList") List<Integer> statusList);
    int updateBatch(@Param("list") List<User> userList);
}
```

### 三、与 Wrapper 条件构造器结合（MyBatis Plus 特色）

这是 MyBatis Plus 最强大的特性之一，可以在自定义 SQL 中复用 Wrapper 的动态条件构造能力。

**核心：使用 `${ew.customSqlSegment}`占位符**

该占位符会自动替换为 Wrapper 生成的 **WHERE**​ 语句（包含 WHERE 关键字本身）。

**1. 注解方式结合 Wrapper**

```
@Select("SELECT * FROM user ${ew.customSqlSegment}")
List<User> selectByWrapper(@Param(Constants.WRAPPER) Wrapper<User> wrapper);
```

**调用示例：**

```
LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
wrapper.like(User::getName, "王")
       .gt(User::getAge, 18)
       .orderByDesc(User::getCreateTime);
List<User> list = userMapper.selectByWrapper(wrapper);
// 生成SQL: SELECT * FROM user WHERE name LIKE '%王%' AND age > 18 ORDER BY create_time DESC
```

**2. XML 方式结合 Wrapper**

```
<!-- UserMapper.xml -->
<select id="selectUserList" resultType="User">
    SELECT id, name, age, email
    FROM user
    ${ew.customSqlSegment}  <!-- 自动注入 WHERE 及条件 -->
</select>
```

```
// Mapper接口
List<User> selectUserList(@Param("ew") Wrapper<User> wrapper);
```

**3. 联表查询结合 Wrapper**

```
<select id="selectUserWithRole" resultType="UserVO">
    SELECT u.*, r.role_name
    FROM user u
    LEFT JOIN role r ON u.role_id = r.id
    ${ew.customSqlSegment}
</select>
```

```
// 使用 LambdaWrapper，条件字段需与SQL中的表别名对应
LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
wrapper.like("u.name", "王") // 注意：这里使用了表别名"u"
       .eq("u.status", 1);
List<UserVO> list = userMapper.selectUserWithRole(wrapper);
```

### 四、Provider 方式（动态 SQL 生成）

使用 `@SelectProvider`、`@UpdateProvider`等注解，通过一个 Provider 类来动态生成 SQL 字符串。这种方式特别适合**极其复杂、条件组合多变**的 SQL。

**1. 定义 Provider 类**

```
public class UserSqlProvider {
    // 动态生成查询SQL
    public String selectByComplexCondition(Map<String, Object> params) {
        String name = (String) params.get("name");
        Integer minAge = (Integer) params.get("minAge");
        Integer maxAge = (Integer) params.get("maxAge");
        
        StringBuilder sql = new StringBuilder("SELECT * FROM user WHERE 1=1 ");
        if (name != null && !name.isEmpty()) {
            sql.append("AND name LIKE CONCAT('%', #{name}, '%') ");
        }
        if (minAge != null) {
            sql.append("AND age >= #{minAge} ");
        }
        if (maxAge != null) {
            sql.append("AND age <= #{maxAge} ");
        }
        sql.append("ORDER BY id DESC");
        return sql.toString();
    }
}
```

**2. Mapper 接口中使用 Provider**

```
@SelectProvider(type = UserSqlProvider.class, method = "selectByComplexCondition")
List<User> selectByComplexCondition(@Param("name") String name, 
                                    @Param("minAge") Integer minAge,
                                    @Param("maxAge") Integer maxAge);
```

### 五、重要注意事项

1. **参数命名规则**：当自定义 SQL 方法需要传入 Wrapper 对象作为参数时，**参数名必须为 `ew`**，或者使用 `@Param(Constants.WRAPPER)`注解明确指定。否则会导致 SQL 解析失败。
    
    ```
    // ✅ 正确
    List<User> selectAll(@Param("ew") Wrapper<User> wrapper);
    List<User> selectAll(@Param(Constants.WRAPPER) Wrapper<User> wrapper);
    
    // ❌ 错误
    List<User> selectAll(@Param("condition") Wrapper<User> wrapper);
    ```
    
2. **版本要求**：确保项目中使用的 `mybatis-plus`版本至少为 **3.0.7**，以支持完善的自定义 SQL 功能。
    
3. **防止 SQL 注入**：
    
    - `#{param}`是预编译占位符，MyBatis 会将其处理为 `?`，安全。
        
    - `${param}`是字符串直接替换，**存在 SQL 注入风险**，应避免直接拼接用户输入。
        
    - **例外**：`${ew.customSqlSegment}`是 MyBatis Plus 官方提供的特殊占位符，其内部已做安全处理，可以放心使用。
        
    
4. **表别名问题**：如果自定义 SQL 中使用了表别名（如 `u.name`），那么在构建 Wrapper 条件时，字段名也需要带上相同的别名。
    
    ```
    wrapper.like("u.name", "张"); // SQL中表别名为 u
    ```
    
5. **空 Wrapper 处理**：如果传入的 Wrapper 对象没有构建任何条件，`${ew.customSqlSegment}`会生成空字符串，SQL 语句仍然合法。
    

### 六、总结与建议

|场景|推荐方式|说明|
|---|---|---|
|**简单、固定的查询**​|**注解方式**​|代码简洁，一目了然。|
|**复杂的动态查询、多表关联**​|**XML 映射文件**​|功能最强大，MyBatis 原生支持，可读性好。|
|**需要复用条件构造器逻辑**​|**与 Wrapper 结合**​|MyBatis Plus 特色，避免重复编写动态 WHERE 条件。|
|**SQL 逻辑极其复杂且需编程生成**​|**Provider 方式**​|最大灵活性，可用 Java 代码完整控制 SQL 生成。|

**最佳实践建议**：

- 对于单表复杂条件查询，优先使用 **LambdaQueryWrapper**​ 原生方法，真的无法满足时再考虑自定义 SQL。
    
- 多表关联查询，推荐使用 **XML 文件**​ 编写，清晰易维护。
    
- 若查询条件动态性很强，但 SELECT 部分固定，使用 **与 Wrapper 结合**​ 的方式是最佳选择。
    
- 始终注意 **SQL 注入**​ 防范，谨慎使用 `${}`拼接。