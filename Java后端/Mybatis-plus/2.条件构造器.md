MyBatis Plus 的条件构造器是它的核心功能之一，用于以编程、链式的方式动态构建 SQL 的 WHERE 条件，极大地简化了复杂查询的编写。它主要分为两类：`AbstractWrapper`及其子类。

### 一、核心类介绍

1. **QueryWrapper**
    
    - 用于构建 **SELECT**​ 语句的查询条件。
        
    - 例如：`WHERE column = value AND column LIKE '%str%'`
        
    
2. **UpdateWrapper**
    
    - 用于构建 **UPDATE**​ 语句的 SET 和 WHERE 条件。
        
    - 可以在构造器中同时设置要更新的字段和更新条件。
        
    
3. **LambdaQueryWrapper**​ 和 **LambdaUpdateWrapper**
    
    - 功能与上述对应，但使用 **Lambda 表达式**​ 引用实体类的属性（`Entity::getColumn`），避免魔法值（字符串），提供了**类型安全**和**代码重构友好**的特性。
        
    - **推荐使用**。
        
    

### 二、基本使用示例

假设有一个 `User`实体类，有 `id`， `name`， `age`， `email`属性。

**1. 使用 QueryWrapper (普通方式)**

```
QueryWrapper<User> queryWrapper = new QueryWrapper<>();
queryWrapper
    .eq("age", 25) // WHERE age = 25
    .like("name", "张") // AND name LIKE '%张%'
    .isNotNull("email") // AND email IS NOT NULL
    .ge("age", 20) // AND age >= 20
    .orderByDesc("id"); // ORDER BY id DESC

List<User> userList = userMapper.selectList(queryWrapper);
```

**2. 使用 LambdaQueryWrapper (推荐方式)**

```
LambdaQueryWrapper<User> lambdaQueryWrapper = new LambdaQueryWrapper<>();
lambdaQueryWrapper
    .eq(User::getAge, 25) // 类型安全，编译时检查
    .like(User::getName, "张")
    .isNotNull(User::getEmail)
    .ge(User::getAge, 20)
    .orderByDesc(User::getId);

List<User> userList = userMapper.selectList(lambdaQueryWrapper);
```

也可以使用 `Wrappers.<实体类>lambdaQuery()`的静态方法创建，更简洁：

```
List<User> list = userMapper.selectList(Wrappers.<User>lambdaQuery()
        .eq(User::getAge, 25)
        .like(User::getName, "张")
);
```

**3. 使用 UpdateWrapper**

```
// 更新 age>20 且 name包含‘王’的记录，将 age 设置为 30，email清空
UpdateWrapper<User> updateWrapper = new UpdateWrapper<>();
updateWrapper
    .gt("age", 20) // WHERE age > 20
    .like("name", "王")
    .set("age", 30) // SET age = 30
    .set("email", null); // SET email = NULL

int rows = userMapper.update(null, updateWrapper); // 第一个实体参数传null
```

Lambda 版本：

```
int rows = userMapper.update(null, Wrappers.<User>lambdaUpdate()
        .gt(User::getAge, 20)
        .like(User::getName, "王")
        .set(User::getAge, 30)
        .set(User::getEmail, null)
);
```

### 三、常用条件方法

|方法|说明|SQL 示例|
|---|---|---|
|`eq`|等于 =|`eq("name", "张三")`-> `name = '张三'`|
|`ne`|不等于 <>|`ne("name", "张三")`|
|`gt`|大于 >|`gt("age", 18)`-> `age > 18`|
|`ge`|大于等于 >=|`ge("age", 18)`|
|`lt`|小于 <|`lt("age", 65)`|
|`le`|小于等于 <=|`le("age", 65)`|
|`between`|BETWEEN 值1 AND 值2|`between("age", 18, 30)`|
|`notBetween`|NOT BETWEEN|`notBetween("age", 18, 30)`|
|`like`|LIKE '%值%'|`like("name", "张")`-> `name LIKE '%张%'`|
|`notLike`|NOT LIKE '%值%'||
|`likeLeft`|LIKE '%值'|`likeLeft("name", "明")`-> `name LIKE '%明'`|
|`likeRight`|LIKE '值%'|`likeRight("name", "张")`-> `name LIKE '张%'`|
|`isNull`|字段 IS NULL|`isNull("email")`|
|`isNotNull`|字段 IS NOT NULL|`isNotNull("email")`|
|`in`|字段 IN (v0, v1, ...)|`in("age", 18, 20, 22)`|
|`notIn`|字段 NOT IN (v0, v1, ...)|`notIn("age", 18, 20)`|
|`inSql`|字段 IN (sql 语句)|`inSql("id", "select user_id from role where id=1")`|
|`groupBy`|分组：GROUP BY 字段, ...|`groupBy("dept_id", "status")`|
|`orderByAsc`|排序：ORDER BY 字段, ... ASC|`orderByAsc("id", "create_time")`|
|`orderByDesc`|排序：ORDER BY 字段, ... DESC|`orderByDesc("id")`|
|`or`|拼接 OR（主动调用）|`eq("name","A").or().eq("name","B")`-> `name='A' OR name='B'`|
|`and`|AND 连接（默认，通常无需调用）|`gt("age",10).and(w->w.lt("age",30))`-> `age>10 AND (age<30)`|
|`nested`|正常嵌套，带括号|`nested(wq -> wq.eq(...).or().eq(...))`|
|`apply`|拼接 SQL 片段（有SQL注入风险）|`apply("date_format(create_time, '%Y') = {0}", 2024)`|
|`last`|无视优化规则，直接拼接 SQL 到最后|`last("limit 1")`|
|`exists`|拼接 EXISTS (sql 语句)|`exists("select 1 from role where role.id=user.role_id")`|
|`notExists`|拼接 NOT EXISTS (sql 语句)||

### 四、特殊场景

**1. 嵌套 AND/OR 复杂组合**

```
// (age > 18 AND name LIKE '%张%') OR (email IS NOT NULL)
lambdaQueryWrapper
    .and(wq -> wq.gt(User::getAge, 18).like(User::getName, "张"))
    .or(wq -> wq.isNotNull(User::getEmail));
```

**2. 分页查询**

条件构造器常与分页插件 `PaginationInnerInterceptor`和 `Page`对象一起使用。

```
// 查询第2页，每页10条，条件为 age>=20
Page<User> page = new Page<>(2, 10);
LambdaQueryWrapper<User> wrapper = Wrappers.lambdaQuery();
wrapper.ge(User::getAge, 20);

Page<User> resultPage = userMapper.selectPage(page, wrapper);
List<User> records = resultPage.getRecords(); // 当前页数据
long total = resultPage.getTotal(); // 总记录数
```

**3. 在 Service 层使用**

如果继承了 `ServiceImpl`，可以直接在 Service 中使用 `lambdaQuery()`，`lambdaUpdate()`等方法。

```
// 在 UserServiceImpl 中
List<User> list = this.lambdaQuery()
                     .eq(User::getStatus, 1)
                     .list();
boolean updated = this.lambdaUpdate()
                     .eq(User::getId, 1L)
                     .set(User::getName, "新名字")
                     .update();
```

### 五、重要注意事项

- **防止 SQL 注入**：避免使用 `apply`直接拼接未经校验的用户输入。使用 `{index}`占位符（如 `{0}`）可以防止注入，MP 会将其预处理为 `?`。
    
- **字段名**：非 Lambda 方式使用字符串时，写的是**数据库列名**（默认是实体属性名下划线转换），而非 Java 属性名。Lambda 方式无此困扰。
    
- **事务**：更新和删除操作通常需要在事务中执行，确保数据一致性。
    
- **性能**：对于极其复杂的动态查询，条件构造器可能使代码可读性下降，此时可以考虑直接使用 XML 映射文件编写 SQL。
    

条件构造器是 MyBatis Plus 提升开发效率的“利器”，熟练掌握后，大部分单表 CRUD 操作都无需手写 SQL。建议从 **LambdaQueryWrapper**​ 和 **LambdaUpdateWrapper**​ 开始使用。