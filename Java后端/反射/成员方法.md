通过反射获取成员方法是Java反射机制的核心应用之一，它允许你在运行时动态地探查和调用对象的方法。下面这个表格汇总了最核心的API，能帮你快速建立整体认知。

|操作目标|关键方法|功能说明|
|---|---|---|
|**获取所有公共方法**​|`Method[] getMethods()`|获取类中所有 **`public`**​ 修饰的方法，**包括从父类继承的方法**。|
|**获取所有自身声明的方法**​|`Method[] getDeclaredMethods()`|获取类中**所有**自身声明的方法（包括 `private`, `protected`, 默认），**但不包括继承的方法**。|
|**获取单个公共方法**​|`Method getMethod(String name, Class<?>... parameterTypes)`|根据方法名和参数类型，获取指定的某个 **`public`**​ 方法（包括继承的）。|
|**获取单个任意方法**​|`Method getDeclaredMethod(String name, Class<?>... parameterTypes)`|根据方法名和参数类型，获取指定的某个方法，**不限访问权限，但仅限本类声明**。|

### 🔧 实现步骤详解

**1. 获取类的Class对象**

这是所有反射操作的起点。

```
// 常用方式有三种
Class<?> clazz = Class.forName("com.example.Person"); // 1. 通过全限定类名（最灵活）
Class<Person> clazz = Person.class; // 2. 通过类名.class
Class<? extends Person> clazz = new Person().getClass(); // 3. 通过对象实例
```

**2. 获取Method对象并调用方法**

获取到`Class`对象后，就可以根据上表的方法来获取`Method`对象，然后通过`invoke`来动态调用方法。

```
import java.lang.reflect.Method;

public class ReflectionExample {
    // 定义一个示例类，包含不同权限和方法签名的方法
    static class Person {
        public void publicMethod() {
            System.out.println("这是一个公共无参方法");
        }
        
        private String privateMethod(String input, int times) {
            String result = "私有方法被调用，参数: " + input.repeat(times);
            System.out.println(result);
            return result;
        }
        
        public static void staticMethod() {
            System.out.println("这是一个静态方法");
        }
    }

    public static void main(String[] args) throws Exception {
        Class<?> clazz = Person.class;
        Object instance = clazz.getDeclaredConstructor().newInstance();

        // 场景1：调用公共无参方法
        Method publicMethod = clazz.getMethod("publicMethod");
        publicMethod.invoke(instance); // 输出: 这是一个公共无参方法

        // 场景2：调用私有带参方法（需要setAccessible(true)）
        Method privateMethod = clazz.getDeclaredMethod("privateMethod", String.class, int.class);
        privateMethod.setAccessible(true); // 关键步骤：突破私有访问限制
        String result = (String) privateMethod.invoke(instance, "Hello", 2);
        System.out.println("返回值: " + result);

        // 场景3：调用静态方法（invoke第一个参数传null）
        Method staticMethod = clazz.getMethod("staticMethod");
        staticMethod.invoke(null); // 静态方法属于类，不需要具体实例
    }
}
```

### 💡 核心要点与技巧

**1. 获取方法时的参数匹配**

在获取有参方法时，必须**精确指定每个参数的类型**（使用`.class`字面量），且**顺序必须完全一致**。

```
// 正确：精确匹配参数类型
Method method = clazz.getDeclaredMethod("methodName", String.class, int.class);

// 错误：如果方法实际签名是 (String, int)，这样会抛出 NoSuchMethodException
// Method method = clazz.getDeclaredMethod("methodName");
```

**2. 调用方法的返回值处理**

`invoke`方法返回的是`Object`类型，需要根据实际返回值类型进行**强制类型转换**。如果方法返回`void`，则`invoke`返回`null`。

```
Method stringReturnMethod = clazz.getMethod("getName");
String name = (String) stringReturnMethod.invoke(instance); // 需要强制转换

Method voidMethod = clazz.getMethod("someVoidMethod");
Object result = voidMethod.invoke(instance); // result 为 null
```

**3. 访问私有方法的特殊处理**

要调用`private`方法，必须在调用`invoke`前执行**`method.setAccessible(true)`**。这被称为"暴力反射"，它会取消Java语言的访问检查，从而能够调用私有方法。

### ⚠️ 重要注意事项

1. **异常处理**：反射操作会抛出多个受检异常（如`NoSuchMethodException`, `IllegalAccessException`, `InvocationTargetException`等），必须使用**try-catch**包围或方法声明**throws**。
    
2. **性能考量**：反射调用比直接调用**慢几个数量级**，因为涉及动态解析和方法访问检查。在性能敏感的循环或核心代码中应谨慎使用。
    
3. **单例模式破坏**：通过反射可以调用私有构造方法，这可能破坏单例模式的设计初衷。如果需要防御，可以在构造方法中加入检查逻辑。
    

### 🎯 实际应用场景

- **框架开发**：如Spring的依赖注入、JUnit的测试运行器等，都通过反射动态调用方法。
    
- **通用工具类**：编写可以处理任意对象的工具，如对象拷贝、序列化/反序列化工具。
    
- **动态代理**：在AOP（面向切面编程）中，通过反射在方法调用前后插入额外逻辑。
    

### 💎 总结

反射获取成员方法的核心流程是：**获取Class对象 → 选择正确的API获取Method对象 → 必要时setAccessible(true) → 使用invoke调用**。虽然强大，但反射会带来性能开销和安全隐患，在实际项目中应权衡使用，优先考虑接口编程等更安全的方式。

希望这些详细的步骤和示例能帮助你掌握通过反射获取和操作成员方法的技巧。如果你对特定场景下的应用有更多疑问，我们可以继续深入探讨。